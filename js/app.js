(() => {
    var __webpack_modules__ = {
        807: module => {
            var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
            module.exports = canUseDOM;
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        __webpack_require__.g = function() {
            if (typeof globalThis === "object") return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if (typeof window === "object") return window;
            }
        }();
    })();
    (() => {
        "use strict";
        const modules_flsModules = {};
        function isWebp() {
            function testWebP(callback) {
                let webP = new Image;
                webP.onload = webP.onerror = function() {
                    callback(webP.height == 2);
                };
                webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
            }
            testWebP((function(support) {
                let className = support === true ? "webp" : "no-webp";
                document.documentElement.classList.add(className);
            }));
        }
        let _slideUp = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = `${target.offsetHeight}px`;
                target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                window.setTimeout((() => {
                    target.hidden = !showmore ? true : false;
                    !showmore ? target.style.removeProperty("height") : null;
                    target.style.removeProperty("padding-top");
                    target.style.removeProperty("padding-bottom");
                    target.style.removeProperty("margin-top");
                    target.style.removeProperty("margin-bottom");
                    !showmore ? target.style.removeProperty("overflow") : null;
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideUpDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideDown = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.hidden = target.hidden ? false : null;
                showmore ? target.style.removeProperty("height") : null;
                let height = target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                target.offsetHeight;
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = height + "px";
                target.style.removeProperty("padding-top");
                target.style.removeProperty("padding-bottom");
                target.style.removeProperty("margin-top");
                target.style.removeProperty("margin-bottom");
                window.setTimeout((() => {
                    target.style.removeProperty("height");
                    target.style.removeProperty("overflow");
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideDownDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideToggle = (target, duration = 500) => {
            if (target.hidden) return _slideDown(target, duration); else return _slideUp(target, duration);
        };
        let bodyLockStatus = true;
        let bodyLockToggle = (delay = 500) => {
            if (document.documentElement.classList.contains("lock")) bodyUnlock(delay); else bodyLock(delay);
        };
        let bodyUnlock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    for (let index = 0; index < lock_padding.length; index++) {
                        const el = lock_padding[index];
                        el.style.paddingRight = "0px";
                    }
                    body.style.paddingRight = "0px";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                for (let index = 0; index < lock_padding.length; index++) {
                    const el = lock_padding[index];
                    el.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                }
                body.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        function menuInit() {
            if (document.querySelector(".header__menu-button")) document.addEventListener("click", (function(e) {
                if (bodyLockStatus && e.target.closest(".header__menu-button")) {
                    bodyLockToggle();
                    document.documentElement.classList.toggle("menu-open");
                }
            }));
        }
        function functions_FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        let formValidate = {
            getErrors(form) {
                let error = 0;
                let formRequiredItems = form.querySelectorAll("*[data-required]");
                if (formRequiredItems.length) formRequiredItems.forEach((formRequiredItem => {
                    if ((formRequiredItem.offsetParent !== null || formRequiredItem.tagName === "SELECT") && !formRequiredItem.disabled) error += this.validateInput(formRequiredItem);
                }));
                return error;
            },
            validateInput(formRequiredItem) {
                let error = 0;
                if (formRequiredItem.dataset.required === "email") {
                    formRequiredItem.value = formRequiredItem.value.replace(" ", "");
                    if (this.emailTest(formRequiredItem)) {
                        this.addError(formRequiredItem);
                        error++;
                    } else this.removeError(formRequiredItem);
                } else if (formRequiredItem.type === "checkbox" && !formRequiredItem.checked) {
                    this.addError(formRequiredItem);
                    error++;
                } else if (!formRequiredItem.value.trim()) {
                    this.addError(formRequiredItem);
                    error++;
                } else this.removeError(formRequiredItem);
                return error;
            },
            addError(formRequiredItem) {
                formRequiredItem.classList.add("_form-error");
                formRequiredItem.parentElement.classList.add("_form-error");
                let inputError = formRequiredItem.parentElement.querySelector(".form__error");
                if (inputError) formRequiredItem.parentElement.removeChild(inputError);
                if (formRequiredItem.dataset.error) formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${formRequiredItem.dataset.error}</div>`);
            },
            removeError(formRequiredItem) {
                formRequiredItem.classList.remove("_form-error");
                formRequiredItem.parentElement.classList.remove("_form-error");
                if (formRequiredItem.parentElement.querySelector(".form__error")) formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector(".form__error"));
            },
            formClean(form) {
                form.reset();
                setTimeout((() => {
                    let inputs = form.querySelectorAll("input,textarea");
                    for (let index = 0; index < inputs.length; index++) {
                        const el = inputs[index];
                        el.parentElement.classList.remove("_form-focus");
                        el.classList.remove("_form-focus");
                        formValidate.removeError(el);
                    }
                    let checkboxes = form.querySelectorAll(".checkbox__input");
                    if (checkboxes.length > 0) for (let index = 0; index < checkboxes.length; index++) {
                        const checkbox = checkboxes[index];
                        checkbox.checked = false;
                    }
                    if (modules_flsModules.select) {
                        let selects = form.querySelectorAll(".select");
                        if (selects.length) for (let index = 0; index < selects.length; index++) {
                            const select = selects[index].querySelector("select");
                            modules_flsModules.select.selectBuild(select);
                        }
                    }
                }), 0);
            },
            emailTest(formRequiredItem) {
                return !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(formRequiredItem.value);
            }
        };
        class SelectConstructor {
            constructor(props, data = null) {
                let defaultConfig = {
                    init: true,
                    logging: true,
                    speed: 150
                };
                this.config = Object.assign(defaultConfig, props);
                this.selectClasses = {
                    classSelect: "select",
                    classSelectBody: "select__body",
                    classSelectTitle: "select__title",
                    classSelectValue: "select__value",
                    classSelectLabel: "select__label",
                    classSelectInput: "select__input",
                    classSelectText: "select__text",
                    classSelectLink: "select__link",
                    classSelectOptions: "select__options",
                    classSelectOptionsScroll: "select__scroll",
                    classSelectOption: "select__option",
                    classSelectContent: "select__content",
                    classSelectRow: "select__row",
                    classSelectData: "select__asset",
                    classSelectDisabled: "_select-disabled",
                    classSelectTag: "_select-tag",
                    classSelectOpen: "_select-open",
                    classSelectActive: "_select-active",
                    classSelectFocus: "_select-focus",
                    classSelectMultiple: "_select-multiple",
                    classSelectCheckBox: "_select-checkbox",
                    classSelectOptionSelected: "_select-selected",
                    classSelectPseudoLabel: "_select-pseudo-label"
                };
                this._this = this;
                if (this.config.init) {
                    const selectItems = data ? document.querySelectorAll(data) : document.querySelectorAll("select");
                    if (selectItems.length) {
                        this.selectsInit(selectItems);
                        this.setLogging(`Проснулся, построил селекты: (${selectItems.length})`);
                    } else this.setLogging("Сплю, не вижу ни одного селекта");
                }
            }
            getSelectClass(className) {
                return `.${className}`;
            }
            getSelectElement(selectItem, className) {
                return {
                    originalSelect: selectItem.querySelector("select"),
                    selectElement: selectItem.querySelector(this.getSelectClass(className))
                };
            }
            selectsInit(selectItems) {
                selectItems.forEach(((originalSelect, index) => {
                    this.selectInit(originalSelect, index + 1);
                }));
                document.addEventListener("click", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusin", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusout", function(e) {
                    this.selectsActions(e);
                }.bind(this));
            }
            selectInit(originalSelect, index) {
                const _this = this;
                let selectItem = document.createElement("div");
                selectItem.classList.add(this.selectClasses.classSelect);
                originalSelect.parentNode.insertBefore(selectItem, originalSelect);
                selectItem.appendChild(originalSelect);
                originalSelect.hidden = true;
                index ? originalSelect.dataset.id = index : null;
                if (this.getSelectPlaceholder(originalSelect)) {
                    originalSelect.dataset.placeholder = this.getSelectPlaceholder(originalSelect).value;
                    if (this.getSelectPlaceholder(originalSelect).label.show) {
                        const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                        selectItemTitle.insertAdjacentHTML("afterbegin", `<span class="${this.selectClasses.classSelectLabel}">${this.getSelectPlaceholder(originalSelect).label.text ? this.getSelectPlaceholder(originalSelect).label.text : this.getSelectPlaceholder(originalSelect).value}</span>`);
                    }
                }
                selectItem.insertAdjacentHTML("beforeend", `<div class="${this.selectClasses.classSelectBody}">\n\t\t\t\t<div hidden class="${this.selectClasses.classSelectOptions}"></div>\n\t\t\t</div>`);
                this.selectBuild(originalSelect);
                originalSelect.dataset.speed = originalSelect.dataset.speed ? originalSelect.dataset.speed : this.config.speed;
                this.config.speed = +originalSelect.dataset.speed;
                originalSelect.addEventListener("change", (function(e) {
                    _this.selectChange(e);
                }));
            }
            selectBuild(originalSelect) {
                const selectItem = originalSelect.parentElement;
                selectItem.dataset.id = originalSelect.dataset.id;
                originalSelect.dataset.classModif ? selectItem.classList.add(`select_${originalSelect.dataset.classModif}`) : null;
                originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectMultiple) : selectItem.classList.remove(this.selectClasses.classSelectMultiple);
                originalSelect.hasAttribute("data-checkbox") && originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectCheckBox) : selectItem.classList.remove(this.selectClasses.classSelectCheckBox);
                this.setSelectTitleValue(selectItem, originalSelect);
                this.setOptions(selectItem, originalSelect);
                originalSelect.hasAttribute("data-search") ? this.searchActions(selectItem) : null;
                originalSelect.hasAttribute("data-open") ? this.selectAction(selectItem) : null;
                this.selectDisabled(selectItem, originalSelect);
            }
            selectsActions(e) {
                const targetElement = e.target;
                const targetType = e.type;
                if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect)) || targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                    const selectItem = targetElement.closest(".select") ? targetElement.closest(".select") : document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag)).dataset.selectId}"]`);
                    const originalSelect = this.getSelectElement(selectItem).originalSelect;
                    if (targetType === "click") {
                        if (!originalSelect.disabled) if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                            const targetTag = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag));
                            const optionItem = document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetTag.dataset.selectId}"] .select__option[data-value="${targetTag.dataset.value}"]`);
                            this.optionAction(selectItem, originalSelect, optionItem);
                        } else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTitle))) this.selectAction(selectItem); else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption))) {
                            const optionItem = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption));
                            this.optionAction(selectItem, originalSelect, optionItem);
                        }
                    } else if (targetType === "focusin" || targetType === "focusout") {
                        if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect))) targetType === "focusin" ? selectItem.classList.add(this.selectClasses.classSelectFocus) : selectItem.classList.remove(this.selectClasses.classSelectFocus);
                    } else if (targetType === "keydown" && e.code === "Escape") this.selectsСlose();
                } else this.selectsСlose();
            }
            selectsСlose(selectOneGroup) {
                const selectsGroup = selectOneGroup ? selectOneGroup : document;
                const selectActiveItems = selectsGroup.querySelectorAll(`${this.getSelectClass(this.selectClasses.classSelect)}${this.getSelectClass(this.selectClasses.classSelectOpen)}`);
                if (selectActiveItems.length) selectActiveItems.forEach((selectActiveItem => {
                    this.selectСlose(selectActiveItem);
                }));
            }
            selectСlose(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                if (!selectOptions.classList.contains("_slide")) {
                    selectItem.classList.remove(this.selectClasses.classSelectOpen);
                    _slideUp(selectOptions, originalSelect.dataset.speed);
                    setTimeout((() => {
                        selectItem.style.zIndex = "";
                    }), originalSelect.dataset.speed);
                }
            }
            selectAction(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectOpenzIndex = originalSelect.dataset.zIndex ? originalSelect.dataset.zIndex : 3;
                this.setOptionsPosition(selectItem);
                if (originalSelect.closest("[data-one-select]")) {
                    const selectOneGroup = originalSelect.closest("[data-one-select]");
                    this.selectsСlose(selectOneGroup);
                }
                setTimeout((() => {
                    if (!selectOptions.classList.contains("_slide")) {
                        selectItem.classList.toggle(this.selectClasses.classSelectOpen);
                        _slideToggle(selectOptions, originalSelect.dataset.speed);
                        if (selectItem.classList.contains(this.selectClasses.classSelectOpen)) selectItem.style.zIndex = selectOpenzIndex; else setTimeout((() => {
                            selectItem.style.zIndex = "";
                        }), originalSelect.dataset.speed);
                    }
                }), 0);
            }
            setSelectTitleValue(selectItem, originalSelect) {
                const selectItemBody = this.getSelectElement(selectItem, this.selectClasses.classSelectBody).selectElement;
                const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                if (selectItemTitle) selectItemTitle.remove();
                selectItemBody.insertAdjacentHTML("afterbegin", this.getSelectTitleValue(selectItem, originalSelect));
                originalSelect.hasAttribute("data-search") ? this.searchActions(selectItem) : null;
            }
            getSelectTitleValue(selectItem, originalSelect) {
                let selectTitleValue = this.getSelectedOptionsData(originalSelect, 2).html;
                if (originalSelect.multiple && originalSelect.hasAttribute("data-tags")) {
                    selectTitleValue = this.getSelectedOptionsData(originalSelect).elements.map((option => `<span role="button" data-select-id="${selectItem.dataset.id}" data-value="${option.value}" class="_select-tag">${this.getSelectElementContent(option)}</span>`)).join("");
                    if (originalSelect.dataset.tags && document.querySelector(originalSelect.dataset.tags)) {
                        document.querySelector(originalSelect.dataset.tags).innerHTML = selectTitleValue;
                        if (originalSelect.hasAttribute("data-search")) selectTitleValue = false;
                    }
                }
                selectTitleValue = selectTitleValue.length ? selectTitleValue : originalSelect.dataset.placeholder ? originalSelect.dataset.placeholder : "";
                let pseudoAttribute = "";
                let pseudoAttributeClass = "";
                if (originalSelect.hasAttribute("data-pseudo-label")) {
                    pseudoAttribute = originalSelect.dataset.pseudoLabel ? ` data-pseudo-label="${originalSelect.dataset.pseudoLabel}"` : ` data-pseudo-label="Заповніть атрибут"`;
                    pseudoAttributeClass = ` ${this.selectClasses.classSelectPseudoLabel}`;
                }
                this.getSelectedOptionsData(originalSelect).values.length ? selectItem.classList.add(this.selectClasses.classSelectActive) : selectItem.classList.remove(this.selectClasses.classSelectActive);
                if (originalSelect.hasAttribute("data-search")) return `<div class="${this.selectClasses.classSelectTitle}"><span${pseudoAttribute} class="${this.selectClasses.classSelectValue}"><input autocomplete="off" type="text" placeholder="${selectTitleValue}" data-placeholder="${selectTitleValue}" class="${this.selectClasses.classSelectInput}"></span></div>`; else {
                    const customClass = this.getSelectedOptionsData(originalSelect).elements.length && this.getSelectedOptionsData(originalSelect).elements[0].dataset.class ? ` ${this.getSelectedOptionsData(originalSelect).elements[0].dataset.class}` : "";
                    return `\n\t\t\t\t<button type="button" class="${this.selectClasses.classSelectTitle}">\n\t\t\t\t\t<span${pseudoAttribute} class="${this.selectClasses.classSelectValue}${pseudoAttributeClass}">\n\t\t\t\t\t\t<span class="${this.selectClasses.classSelectContent}${customClass}">\n\t\t\t\t\t\t\t${selectTitleValue}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<div class="select__icon">\n\t\t\t\t\t\t\t<svg xmlns="http://www.w3.org/2000/svg" width="18" height="19" viewBox="0 0 18 19" fill="none">\n\t\t\t\t\t\t\t\t<path d="M14.9401 7.2124L10.0501 12.1024C9.47256 12.6799 8.52756 12.6799 7.95006 12.1024L3.06006 7.2124" stroke="#A7B4C3" stroke-width="1.5" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"/>\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</span>\n\t\t\t\t\t<div class="select__background">\n\t\t\t\t\t\t<svg width="324" height="48" viewBox="0 0 324 48" fill="none" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">\n\t\t\t\t\t\t\t<path d="M0.5434 47.5L4.46007 0.5H323.457L319.54 47.5H0.5434Z"/>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</div>\n\t\t\t\t</button>`;
                }
            }
            getSelectElementContent(selectOption) {
                const selectOptionData = selectOption.dataset.asset ? `${selectOption.dataset.asset}` : "";
                const selectOptionDataHTML = selectOptionData.indexOf("img") >= 0 ? `<img src="${selectOptionData}" alt="">` : selectOptionData;
                let selectOptionContentHTML = ``;
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectRow}">` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectData}">` : "";
                selectOptionContentHTML += selectOptionData ? selectOptionDataHTML : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectText}">` : "";
                selectOptionContentHTML += selectOption.textContent;
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                return selectOptionContentHTML;
            }
            getSelectPlaceholder(originalSelect) {
                const selectPlaceholder = Array.from(originalSelect.options).find((option => !option.value));
                if (selectPlaceholder) return {
                    value: selectPlaceholder.textContent,
                    show: selectPlaceholder.hasAttribute("data-show"),
                    label: {
                        show: selectPlaceholder.hasAttribute("data-label"),
                        text: selectPlaceholder.dataset.label
                    }
                };
            }
            getSelectedOptionsData(originalSelect, type) {
                let selectedOptions = [];
                if (originalSelect.multiple) selectedOptions = Array.from(originalSelect.options).filter((option => option.value)).filter((option => option.selected)); else selectedOptions.push(originalSelect.options[originalSelect.selectedIndex]);
                return {
                    elements: selectedOptions.map((option => option)),
                    values: selectedOptions.filter((option => option.value)).map((option => option.value)),
                    html: selectedOptions.map((option => this.getSelectElementContent(option)))
                };
            }
            getOptions(originalSelect) {
                let selectOptionsScroll = originalSelect.hasAttribute("data-scroll") ? `data-simplebar` : "";
                let selectOptions = Array.from(originalSelect.options);
                if (selectOptions.length > 0) {
                    let selectOptionsHTML = ``;
                    if (this.getSelectPlaceholder(originalSelect) && !this.getSelectPlaceholder(originalSelect).show || originalSelect.multiple) selectOptions = selectOptions.filter((option => option.value));
                    selectOptionsHTML += `<div ${selectOptionsScroll} class="${this.selectClasses.classSelectOptionsScroll}">`;
                    selectOptions.forEach((selectOption => {
                        selectOptionsHTML += this.getOption(selectOption, originalSelect);
                    }));
                    selectOptionsHTML += `\n\t\t\t\t</div>\n\t\t\t\t<div class="select__options-background">\n\t\t\t\t\t<svg width="324" height="48" viewBox="0 0 324 48" fill="none" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">\n\t\t\t\t\t\t<path d="M0.5434 47.5L4.46007 0.5H323.457L319.54 47.5H0.5434Z"/>\n\t\t\t\t\t</svg>\n\t\t\t\t</div>\n\t\t\t`;
                    return selectOptionsHTML;
                }
            }
            getOption(selectOption, originalSelect) {
                const selectOptionSelected = selectOption.selected && originalSelect.multiple ? ` ${this.selectClasses.classSelectOptionSelected}` : "";
                const selectOptionHide = selectOption.selected && !originalSelect.hasAttribute("data-show-selected") && !originalSelect.multiple ? `hidden` : ``;
                const selectOptionClass = selectOption.dataset.class ? ` ${selectOption.dataset.class}` : "";
                const selectOptionLink = selectOption.dataset.href ? selectOption.dataset.href : false;
                const selectOptionLinkTarget = selectOption.hasAttribute("data-href-blank") ? `target="_blank"` : "";
                let selectOptionHTML = ``;
                selectOptionHTML += selectOptionLink ? `<a ${selectOptionLinkTarget} ${selectOptionHide} href="${selectOptionLink}" data-value="${selectOption.value}" class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}">` : `<button ${selectOptionHide} class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}" data-value="${selectOption.value}" type="button">`;
                selectOptionHTML += this.getSelectElementContent(selectOption);
                selectOptionHTML += selectOptionLink ? `</a>` : `</button>`;
                return selectOptionHTML;
            }
            setOptions(selectItem, originalSelect) {
                const selectItemOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                selectItemOptions.innerHTML = this.getOptions(originalSelect);
            }
            setOptionsPosition(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectItemScroll = this.getSelectElement(selectItem, this.selectClasses.classSelectOptionsScroll).selectElement;
                const customMaxHeightValue = +originalSelect.dataset.scroll ? `${+originalSelect.dataset.scroll}px` : ``;
                const selectOptionsPosMargin = +originalSelect.dataset.optionsMargin ? +originalSelect.dataset.optionsMargin : 10;
                if (!selectItem.classList.contains(this.selectClasses.classSelectOpen)) {
                    selectOptions.hidden = false;
                    const selectItemScrollHeight = selectItemScroll.offsetHeight ? selectItemScroll.offsetHeight : parseInt(window.getComputedStyle(selectItemScroll).getPropertyValue("max-height"));
                    const selectOptionsHeight = selectOptions.offsetHeight > selectItemScrollHeight ? selectOptions.offsetHeight : selectItemScrollHeight + selectOptions.offsetHeight;
                    const selectOptionsScrollHeight = selectOptionsHeight - selectItemScrollHeight;
                    selectOptions.hidden = true;
                    const selectItemHeight = selectItem.offsetHeight;
                    const selectItemPos = selectItem.getBoundingClientRect().top;
                    const selectItemTotal = selectItemPos + selectOptionsHeight + selectItemHeight + selectOptionsScrollHeight;
                    const selectItemResult = window.innerHeight - (selectItemTotal + selectOptionsPosMargin);
                    if (selectItemResult < 0) {
                        const newMaxHeightValue = selectOptionsHeight + selectItemResult;
                        if (newMaxHeightValue < 100) {
                            selectItem.classList.add("select_show-top");
                            selectItemScroll.style.maxHeight = selectItemPos < selectOptionsHeight ? `${selectItemPos - (selectOptionsHeight - selectItemPos)}px` : customMaxHeightValue;
                        } else {
                            selectItem.classList.remove("select_show-top");
                            selectItemScroll.style.maxHeight = `${newMaxHeightValue}px`;
                        }
                    }
                } else setTimeout((() => {
                    selectItem.classList.remove("select_show-top");
                    selectItemScroll.style.maxHeight = customMaxHeightValue;
                }), +originalSelect.dataset.speed);
            }
            optionAction(selectItem, originalSelect, optionItem) {
                const selectOptions = selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOptions)}`);
                if (!selectOptions.classList.contains("_slide")) {
                    if (originalSelect.multiple) {
                        optionItem.classList.toggle(this.selectClasses.classSelectOptionSelected);
                        const originalSelectSelectedItems = this.getSelectedOptionsData(originalSelect).elements;
                        originalSelectSelectedItems.forEach((originalSelectSelectedItem => {
                            originalSelectSelectedItem.removeAttribute("selected");
                        }));
                        const selectSelectedItems = selectItem.querySelectorAll(this.getSelectClass(this.selectClasses.classSelectOptionSelected));
                        selectSelectedItems.forEach((selectSelectedItems => {
                            originalSelect.querySelector(`option[value = "${selectSelectedItems.dataset.value}"]`).setAttribute("selected", "selected");
                        }));
                    } else {
                        if (!originalSelect.hasAttribute("data-show-selected")) setTimeout((() => {
                            if (selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`)) selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`).hidden = false;
                            optionItem.hidden = true;
                        }), this.config.speed);
                        originalSelect.value = optionItem.hasAttribute("data-value") ? optionItem.dataset.value : optionItem.textContent;
                        this.selectAction(selectItem);
                    }
                    this.setSelectTitleValue(selectItem, originalSelect);
                    this.setSelectChange(originalSelect);
                }
            }
            selectChange(e) {
                const originalSelect = e.target;
                this.selectBuild(originalSelect);
                this.setSelectChange(originalSelect);
            }
            setSelectChange(originalSelect) {
                if (originalSelect.hasAttribute("data-validate")) formValidate.validateInput(originalSelect);
                if (originalSelect.hasAttribute("data-submit") && originalSelect.value) {
                    let tempButton = document.createElement("button");
                    tempButton.type = "submit";
                    originalSelect.closest("form").append(tempButton);
                    tempButton.click();
                    tempButton.remove();
                }
                const selectItem = originalSelect.parentElement;
                this.selectCallback(selectItem, originalSelect);
            }
            selectDisabled(selectItem, originalSelect) {
                if (originalSelect.disabled) {
                    selectItem.classList.add(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = true;
                } else {
                    selectItem.classList.remove(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = false;
                }
            }
            searchActions(selectItem) {
                this.getSelectElement(selectItem).originalSelect;
                const selectInput = this.getSelectElement(selectItem, this.selectClasses.classSelectInput).selectElement;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectOptionsItems = selectOptions.querySelectorAll(`.${this.selectClasses.classSelectOption} `);
                const _this = this;
                selectInput.addEventListener("input", (function() {
                    selectOptionsItems.forEach((selectOptionsItem => {
                        if (selectOptionsItem.textContent.toUpperCase().includes(selectInput.value.toUpperCase())) selectOptionsItem.hidden = false; else selectOptionsItem.hidden = true;
                    }));
                    selectOptions.hidden === true ? _this.selectAction(selectItem) : null;
                }));
            }
            selectCallback(selectItem, originalSelect) {
                document.dispatchEvent(new CustomEvent("selectCallback", {
                    detail: {
                        select: originalSelect
                    }
                }));
            }
            setLogging(message) {
                this.config.logging ? functions_FLS(`[select]: ${message} `) : null;
            }
        }
        modules_flsModules.select = new SelectConstructor({});
        function ssr_window_esm_isObject(obj) {
            return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target = {}, src = {}) {
            Object.keys(src).forEach((key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            }));
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = typeof document !== "undefined" ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if (typeof setTimeout === "undefined") {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if (typeof setTimeout === "undefined") return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = typeof window !== "undefined" ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function utils_nextTick(callback, delay = 0) {
            return setTimeout(callback, delay);
        }
        function utils_now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis = "x") {
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if (axis === "y") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function utils_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
        }
        function isNode(node) {
            if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
            return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function utils_extend(...args) {
            const to = Object(args[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < args.length; i += 1) {
                const nextSource = args[i];
                if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== void 0 && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll({swiper, targetPosition, side}) {
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (startTime === null) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        function utils_elementChildren(element, selector = "") {
            return [ ...element.children ].filter((el => el.matches(selector)));
        }
        function utils_createElement(tag, classes = []) {
            const el = document.createElement(tag);
            el.classList.add(...Array.isArray(classes) ? classes : [ classes ]);
            return el;
        }
        function elementPrevAll(el, selector) {
            const prevEls = [];
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (prev.matches(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return prevEls;
        }
        function elementNextAll(el, selector) {
            const nextEls = [];
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (next.matches(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return nextEls;
        }
        function elementStyle(el, prop) {
            const window = ssr_window_esm_getWindow();
            return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function utils_elementIndex(el) {
            let child = el;
            let i;
            if (child) {
                i = 0;
                while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i += 1;
                return i;
            }
            return;
        }
        function utils_elementParents(el, selector) {
            const parents = [];
            let parent = el.parentElement;
            while (parent) {
                if (selector) {
                    if (parent.matches(selector)) parents.push(parent);
                } else parents.push(parent);
                parent = parent.parentElement;
            }
            return parents;
        }
        function utils_elementOuterSize(el, size, includeMargins) {
            const window = ssr_window_esm_getWindow();
            if (includeMargins) return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
            return el.offsetWidth;
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice({userAgent} = {}) {
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = platform === "Win32";
            let macos = platform === "MacIntel";
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides = {}) {
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            let needPerspectiveFix = false;
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            if (isSafari()) {
                const ua = String(window.navigator.userAgent);
                if (ua.includes("Version/")) {
                    const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num => Number(num)));
                    needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                }
            }
            return {
                isSafari: needPerspectiveFix || isSafari(),
                needPerspectiveFix,
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize({swiper, on, emit}) {
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((({contentBoxSize, contentRect, target}) => {
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function Observer({swiper, extendParams, on, emit}) {
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = (target, options = {}) => {
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (swiper.__preventObserver__) return;
                    if (mutations.length === 1) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                    childList: typeof options.childList === "undefined" ? true : options.childList,
                    characterData: typeof options.characterData === "undefined" ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = utils_elementParents(swiper.el);
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.el, {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.wrapperEl, {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        const events_emitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                function onceHandler(...args) {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if (typeof handler === "undefined") self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit(...args) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                if (typeof args[0] === "string" || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const el = swiper.el;
            if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
            if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
            if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
            width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
            height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionLabel(property) {
                if (swiper.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if (typeof swiperSize === "undefined") return;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            swiper.virtualSize = -spaceBetween;
            slides.forEach((slideEl => {
                if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
                slideEl.style.marginBottom = "";
                slideEl.style.marginTop = "";
            }));
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slidesLength);
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key => typeof params.breakpoints[key].slidesPerView !== "undefined")).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                let slide;
                if (slides[i]) slide = slides[i];
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
                if (slides[i] && elementStyle(slide, "display") === "none") continue;
                if (params.slidesPerView === "auto") {
                    if (shouldResetSlideSize) slides[i].style[getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) slide.style.transform = "none";
                    if (currentWebKitTransform) slide.style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? utils_elementOuterSize(slide, "width", true) : utils_elementOuterSize(slide, "height", true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide.style.transform = currentTransform;
                    if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
            if (params.setWrapperSize) wrapperEl.style[getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (isVirtual && params.loop) {
                const size = slidesSizesGrid[0] + spaceBetween;
                if (params.slidesPerGroup > 1) {
                    const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                    const groupSize = size * params.slidesPerGroup;
                    for (let i = 0; i < groups; i += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                }
                for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                    if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                    slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                    swiper.virtualSize += size;
                }
            }
            if (snapGrid.length === 0) snapGrid = [ 0 ];
            if (spaceBetween !== 0) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode || params.loop) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).forEach((slideEl => {
                    slideEl.style[key] = `${spaceBetween}px`;
                }));
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const maxSnap = allSlidesSize - swiperSize;
                snapGrid = snapGrid.map((snap => {
                    if (snap < 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                if (allSlidesSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
                return swiper.slides[index];
            };
            if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if (typeof activeSlides[i] !== "undefined") {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
        }
        function updateSlidesProgress(translate = this && this.translate || 0) {
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (slides.length === 0) return;
            if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideVisibleClass);
            }));
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            let spaceBetween = params.spaceBetween;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides[i].classList.add(params.slideVisibleClass);
                }
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
        }
        function updateProgress(translate) {
            const swiper = this;
            if (typeof translate === "undefined") {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd, progressLoop} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (translatesDiff === 0) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                isBeginning = isBeginningRounded || progress <= 0;
                isEnd = isEndRounded || progress >= 1;
                if (isBeginningRounded) progress = 0;
                if (isEndRounded) progress = 1;
            }
            if (params.loop) {
                const firstSlideIndex = swiper.getSlideIndexByData(0);
                const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                const translateAbs = Math.abs(translate);
                if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                if (progressLoop > 1) progressLoop -= 1;
            }
            Object.assign(swiper, {
                progress,
                progressLoop,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, slidesEl, activeIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const getFilteredSlide = selector => utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            }));
            let activeSlide;
            if (isVirtual) if (params.loop) {
                let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else activeSlide = slides[activeIndex];
            if (activeSlide) {
                activeSlide.classList.add(params.slideActiveClass);
                let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !nextSlide) nextSlide = slides[0];
                if (nextSlide) nextSlide.classList.add(params.slideNextClass);
                let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
                if (prevSlide) prevSlide.classList.add(params.slidePrevClass);
            }
            swiper.emitSlidesClasses();
        }
        const processLazyPreloader = (swiper, imageEl) => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
            const slideEl = imageEl.closest(slideSelector());
            if (slideEl) {
                const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (lazyEl) lazyEl.remove();
            }
        };
        const unlazy = (swiper, index) => {
            if (!swiper.slides[index]) return;
            const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
            if (imageEl) imageEl.removeAttribute("loading");
        };
        const preload = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            let amount = swiper.params.lazyPreloadPrevNext;
            const len = swiper.slides.length;
            if (!len || !amount || amount < 0) return;
            amount = Math.min(amount, len);
            const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
            const activeIndex = swiper.activeIndex;
            const slideIndexLastInView = activeIndex + slidesPerView - 1;
            if (swiper.params.rewind) for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                const realIndex = (i % len + len) % len;
                if (realIndex !== activeIndex && realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
            } else for (let i = Math.max(slideIndexLastInView - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) if (i !== activeIndex && i > slideIndexLastInView) unlazy(swiper, i);
        };
        function getActiveIndexByTranslate(swiper) {
            const {slidesGrid, params} = swiper;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            let activeIndex;
            for (let i = 0; i < slidesGrid.length; i += 1) if (typeof slidesGrid[i + 1] !== "undefined") {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
            } else if (translate >= slidesGrid[i]) activeIndex = i;
            if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
            return activeIndex;
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            const getVirtualRealIndex = aIndex => {
                let realIndex = aIndex - swiper.virtual.slidesBefore;
                if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;
                if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;
                return realIndex;
            };
            if (typeof activeIndex === "undefined") activeIndex = getActiveIndexByTranslate(swiper);
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.realIndex = getVirtualRealIndex(activeIndex);
                return;
            }
            let realIndex;
            if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (swiper.slides[activeIndex]) realIndex = parseInt(swiper.slides[activeIndex].getAttribute("data-swiper-slide-index") || activeIndex, 10); else realIndex = activeIndex;
            Object.assign(swiper, {
                previousSnapIndex,
                snapIndex,
                previousRealIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            if (swiper.initialized) preload(swiper);
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit("slideChange");
        }
        function updateClickedSlide(e) {
            const swiper = this;
            const params = swiper.params;
            const slide = e.closest(`.${params.slideClass}, swiper-slide`);
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        const update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis = (this.isHorizontal() ? "x" : "y")) {
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate(wrapperEl, axis);
            currentTranslate += swiper.cssOverflowAdjustment();
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) {
                if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment(); else y -= swiper.cssOverflowAdjustment();
                wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            }
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (speed === 0) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        const translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit({swiper, runCallbacks, direction, step}) {
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === "reset") {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        const transition = {
            setTransition,
            transitionStart,
            transitionEnd
        };
        function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
            if (typeof index === "string") index = parseInt(index, 10);
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if (params.effect !== "slide") swiper.setTranslate(translate);
                if (direction !== "reset") {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (speed === 0) {
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                        swiper._cssModeVirtualInitialSet = true;
                        requestAnimationFrame((() => {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        }));
                    } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._immediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
            if (typeof index === "string") {
                const indexAsNumber = parseInt(index, 10);
                index = indexAsNumber;
            }
            const swiper = this;
            let newIndex = index;
            if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else newIndex = swiper.getSlideIndexByData(newIndex);
            return swiper.slideTo(newIndex, speed, runCallbacks, internal);
        }
        function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {enabled, params, animating} = swiper;
            if (!enabled) return swiper;
            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "next"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {params, snapGrid, slidesGrid, rtlTranslate, enabled, animating} = swiper;
            if (!enabled) return swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "prev"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if (typeof prevSnap === "undefined" && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if (typeof prevSnapIndex !== "undefined") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if (typeof prevSnap !== "undefined") {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = .5) {
            const swiper = this;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        const slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate(slideRealIndex) {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            slides.forEach(((el, index) => {
                el.setAttribute("data-swiper-slide-index", index);
            }));
            swiper.loopFix({
                slideRealIndex,
                direction: params.centeredSlides ? void 0 : "next"
            });
        }
        function loopFix({slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel} = {}) {
            const swiper = this;
            if (!swiper.params.loop) return;
            swiper.emit("beforeLoopFix");
            const {slides, allowSlidePrev, allowSlideNext, slidesEl, params} = swiper;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            if (swiper.virtual && params.virtual.enabled) {
                if (slideTo) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                swiper.emit("loopFix");
                return;
            }
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
            let loopedSlides = params.loopedSlides || slidesPerView;
            if (loopedSlides % params.slidesPerGroup !== 0) loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
            swiper.loopedSlides = loopedSlides;
            const prependSlidesIndexes = [];
            const appendSlidesIndexes = [];
            let activeIndex = swiper.activeIndex;
            if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el => el.classList.contains(params.slideActiveClass)))[0]); else activeIndex = activeSlideIndex;
            const isNext = direction === "next" || !direction;
            const isPrev = direction === "prev" || !direction;
            let slidesPrepended = 0;
            let slidesAppended = 0;
            if (activeSlideIndex < loopedSlides) {
                slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
                for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
                    const index = i - Math.floor(i / slides.length) * slides.length;
                    prependSlidesIndexes.push(slides.length - index - 1);
                }
            } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {
                slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
                for (let i = 0; i < slidesAppended; i += 1) {
                    const index = i - Math.floor(i / slides.length) * slides.length;
                    appendSlidesIndexes.push(index);
                }
            }
            if (isPrev) prependSlidesIndexes.forEach((index => {
                swiper.slides[index].swiperLoopMoveDOM = true;
                slidesEl.prepend(swiper.slides[index]);
                swiper.slides[index].swiperLoopMoveDOM = false;
            }));
            if (isNext) appendSlidesIndexes.forEach((index => {
                swiper.slides[index].swiperLoopMoveDOM = true;
                slidesEl.append(swiper.slides[index]);
                swiper.slides[index].swiperLoopMoveDOM = false;
            }));
            swiper.recalcSlides();
            if (params.slidesPerView === "auto") swiper.updateSlides();
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (slideTo) if (prependSlidesIndexes.length > 0 && isPrev) {
                if (typeof slideRealIndex === "undefined") {
                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                    const diff = newSlideTranslate - currentSlideTranslate;
                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
                        if (setTranslate) swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff;
                    }
                } else if (setTranslate) swiper.slideToLoop(slideRealIndex, 0, false, true);
            } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff;
                }
            } else swiper.slideToLoop(slideRealIndex, 0, false, true);
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.controller && swiper.controller.control && !byController) {
                const loopParams = {
                    slideRealIndex,
                    slideTo: false,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController: true
                };
                if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c => {
                    if (!c.destroyed && c.params.loop) c.loopFix(loopParams);
                })); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix(loopParams);
            }
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            swiper.recalcSlides();
            const newSlidesOrder = [];
            swiper.slides.forEach((slideEl => {
                const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
                newSlidesOrder[index] = slideEl;
            }));
            swiper.slides.forEach((slideEl => {
                slideEl.removeAttribute("data-swiper-slide-index");
            }));
            newSlidesOrder.forEach((slideEl => {
                slidesEl.append(slideEl);
            }));
            swiper.recalcSlides();
            swiper.slideTo(swiper.realIndex, 0);
        }
        const loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        const grab_cursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base = this) {
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const window = ssr_window_esm_getWindow();
            const data = swiper.touchEventsData;
            data.evCache.push(event);
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let targetEl = e.target;
            if (params.touchEventsTarget === "wrapper") if (!swiper.wrapperEl.contains(targetEl)) return;
            if ("which" in e && e.which === 3) return;
            if ("button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
            const eventPath = event.composedPath ? event.composedPath() : event.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
            touches.currentX = e.pageX;
            touches.currentY = e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) if (edgeSwipeDetection === "prevent") event.preventDefault(); else return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = utils_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(data.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === "SELECT") data.isTouched = false;
            }
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            const pointerIndex = data.evCache.findIndex((cachedEv => cachedEv.pointerId === e.pointerId));
            if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
            const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        prevX: swiper.touches.currentX,
                        prevY: swiper.touches.currentY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = utils_now();
                }
                return;
            }
            if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (document.activeElement) if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            if (e.targetTouches && e.targetTouches.length > 1) return;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if (typeof data.isScrolling === "undefined") {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            let diff = swiper.isHorizontal() ? diffX : diffY;
            let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
            if (params.oneWayMovement) {
                diff = Math.abs(diff) * (rtl ? 1 : -1);
                touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
            }
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) {
                diff = -diff;
                touchesDiff = -touchesDiff;
            }
            const prevTouchesDirection = swiper.touchesDirection;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
            const isLoop = swiper.params.loop && !params.cssMode;
            if (!data.isMoved) {
                if (isLoop) swiper.loopFix({
                    direction: swiper.swipeDirection
                });
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) {
                    const evt = new window.CustomEvent("transitionend", {
                        bubbles: true,
                        cancelable: true
                    });
                    swiper.wrapperEl.dispatchEvent(evt);
                }
                data.allowMomentumBounce = false;
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            let loopFixed;
            if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {
                swiper.loopFix({
                    direction: swiper.swipeDirection,
                    setTranslate: true
                });
                loopFixed = true;
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0) {
                if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) swiper.loopFix({
                    direction: "prev",
                    setTranslate: true,
                    activeSlideIndex: 0
                });
                if (data.currentTranslate > swiper.minTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                }
            } else if (diff < 0) {
                if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) swiper.loopFix({
                    direction: "next",
                    setTranslate: true,
                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                });
                if (data.currentTranslate < swiper.maxTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                }
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            const pointerIndex = data.evCache.findIndex((cachedEv => cachedEv.pointerId === event.pointerId));
            if (pointerIndex >= 0) data.evCache.splice(pointerIndex, 1);
            if ([ "pointercancel", "pointerout", "pointerleave" ].includes(event.type)) {
                const proceed = event.type === "pointercancel" && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) return;
            }
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
            const touchEndTime = utils_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = utils_now();
            utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (swiper.params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== "undefined") {
                    if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && el.offsetWidth === 0) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            const isVirtualLoop = isVirtual && params.loop;
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                clearTimeout(swiper.autoplay.resizeTimeout);
                swiper.autoplay.resizeTimeout = setTimeout((() => {
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
                }), 500);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (swiper.translate === 0) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        function onLoad(e) {
            const swiper = this;
            processLazyPreloader(swiper, e.target);
            if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
            swiper.update();
        }
        let dummyEventAttached = false;
        function dummyEventListener() {}
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, el, wrapperEl, device} = swiper;
            const capture = !!params.nested;
            const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            el[domMethod]("pointerdown", swiper.onTouchStart, {
                passive: false
            });
            document[domMethod]("pointermove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("pointerup", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointercancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerout", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerleave", swiper.onTouchEnd, {
                passive: true
            });
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
            el[domMethod]("load", swiper.onLoad, {
                capture: true
            });
        };
        function attachEvents() {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const {params} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            swiper.onLoad = onLoad.bind(swiper);
            if (!dummyEventAttached) {
                document.addEventListener("touchstart", dummyEventListener);
                dummyEventAttached = true;
            }
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        const core_events = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {realIndex, initialized, params, el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                el.classList.add(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            }));
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            }
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base = "window", containerEl) {
            if (!breakpoints || base === "container" && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if (typeof point === "string" && point.indexOf("@") === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if (base === "window") {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        const breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if (typeof item === "object") Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if (typeof item === "string") resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, el, device} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            el.classList.add(...classNames);
            swiper.emitContainerClasses();
        }
        function removeClasses_removeClasses() {
            const swiper = this;
            const {el, classNames} = swiper;
            el.classList.remove(...classNames);
            swiper.emitContainerClasses();
        }
        const classes = {
            addClasses,
            removeClasses: removeClasses_removeClasses
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = swiper.snapGrid.length === 1;
            if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
            if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        const check_overflow = {
            checkOverflow
        };
        const defaults = {
            init: true,
            direction: "horizontal",
            oneWayMovement: false,
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 5,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loop: false,
            loopedSlides: null,
            loopPreventsSliding: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj = {}) {
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if ([ "navigation", "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) params[moduleParamName] = {
                    auto: true
                };
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (params[moduleParamName] === true) params[moduleParamName] = {
                    enabled: true
                };
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter: events_emitter,
            update,
            translate,
            transition,
            slide,
            loop,
            grabCursor: grab_cursor,
            events: core_events,
            breakpoints,
            checkOverflow: check_overflow,
            classes
        };
        const extendedDefaults = {};
        class core_Swiper {
            constructor(...args) {
                let el;
                let params;
                if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                const document = ssr_window_esm_getDocument();
                if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
                    const swipers = [];
                    document.querySelectorAll(params.el).forEach((containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        params,
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return swiper.params.direction === "horizontal";
                    },
                    isVertical() {
                        return swiper.params.direction === "vertical";
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                    },
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        evCache: []
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            getSlideIndex(slideEl) {
                const {slidesEl, params} = this;
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                const firstSlideIndex = utils_elementIndex(slides[0]);
                return utils_elementIndex(slideEl) - firstSlideIndex;
            }
            getSlideIndexByData(index) {
                return this.getSlideIndex(this.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index))[0]);
            }
            recalcSlides() {
                const swiper = this;
                const {slidesEl, params} = swiper;
                swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter((className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0)).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.forEach((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view = "current", exact = false) {
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex].swiperSlideSize;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if (view === "current") for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl);
                }));
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                    setTranslate();
                    if (swiper.params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                        const slides = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                        translated = swiper.slideTo(slides.length - 1, 0, false, true);
                    } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate = true) {
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
                if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
                swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.forEach((slideEl => {
                    if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
                swiper.rtl = direction === "rtl";
                swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
                if (swiper.rtl) {
                    swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(element) {
                const swiper = this;
                if (swiper.mounted) return true;
                let el = element || swiper.params.el;
                if (typeof el === "string") el = document.querySelector(el);
                if (!el) return false;
                el.swiper = swiper;
                if (el.shadowEl) swiper.isElement = true;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = el.shadowRoot.querySelector(getWrapperSelector());
                        return res;
                    }
                    return utils_elementChildren(el, getWrapperSelector())[0];
                };
                let wrapperEl = getWrapper();
                if (!wrapperEl && swiper.params.createElements) {
                    wrapperEl = utils_createElement("div", swiper.params.wrapperClass);
                    el.append(wrapperEl);
                    utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl => {
                        wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    el,
                    wrapperEl,
                    slidesEl: swiper.isElement ? el : wrapperEl,
                    mounted: true,
                    rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
                    rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
                    wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (mounted === false) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                if (swiper.params.loop) swiper.loopCreate();
                swiper.attachEvents();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", (e => {
                        processLazyPreloader(swiper, e.target);
                    }));
                }));
                preload(swiper);
                swiper.initialized = true;
                preload(swiper);
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance = true, cleanStyles = true) {
                const swiper = this;
                const {params, el, wrapperEl, slides} = swiper;
                if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    el.removeAttribute("style");
                    wrapperEl.removeAttribute("style");
                    if (slides && slides.length) slides.forEach((slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                        slideEl.removeAttribute("style");
                        slideEl.removeAttribute("data-swiper-slide-index");
                    }));
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (deleteInstance !== false) {
                    swiper.el.swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!core_Swiper.prototype.__modules__) core_Swiper.prototype.__modules__ = [];
                const modules = core_Swiper.prototype.__modules__;
                if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => core_Swiper.installModule(m)));
                    return core_Swiper;
                }
                core_Swiper.installModule(module);
                return core_Swiper;
            }
        }
        Object.keys(prototypes).forEach((prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
                core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }));
        }));
        core_Swiper.use([ Resize, Observer ]);
        const core = core_Swiper;
        function buildSliders() {
            let sliders = document.querySelectorAll('[class*="__swiper"]:not(.swiper-wrapper)');
            if (sliders) sliders.forEach((slider => {
                slider.parentElement.classList.add("swiper");
                slider.classList.add("swiper-wrapper");
                for (const slide of slider.children) slide.classList.add("swiper-slide");
            }));
        }
        function initSliders() {
            if (document.querySelector(".shop__slider")) new core(".shop__slider", {
                observer: true,
                observeParents: true,
                slidesPerView: 3,
                spaceBetween: 30,
                speed: 800
            });
            if (document.querySelector(".news__slider")) new core(".news__slider", {
                observer: true,
                observeParents: true,
                slidesPerView: 3,
                spaceBetween: 30,
                speed: 800
            });
        }
        window.addEventListener("load", (function(e) {
            buildSliders();
            initSliders();
        }));
        /*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
        function round(v) {
            return v + .5 | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
            return lim(round(v * 2.55), 0, 255);
        }
        function n2b(v) {
            return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
            return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
            return lim(round(v * 100), 0, 100);
        }
        const map$1 = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            A: 10,
            B: 11,
            C: 12,
            D: 13,
            E: 14,
            F: 15,
            a: 10,
            b: 11,
            c: 12,
            d: 13,
            e: 14,
            f: 15
        };
        const hex = [ ..."0123456789ABCDEF" ];
        const h1 = b => hex[b & 15];
        const h2 = b => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = b => (b & 240) >> 4 === (b & 15);
        const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
            var len = str.length;
            var ret;
            if (str[0] === "#") if (len === 4 || len === 5) ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
            }; else if (len === 7 || len === 9) ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
            };
            return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
            var f = isShort(v) ? h1 : h2;
            return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
            const a = s * Math.min(l, 1 - l);
            const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return [ f(0), f(8), f(4) ];
        }
        function hsv2rgbn(h, s, v) {
            const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
            return [ f(5), f(3), f(1) ];
        }
        function hwb2rgbn(h, w, b) {
            const rgb = hsl2rgbn(h, 1, .5);
            let i;
            if (w + b > 1) {
                i = 1 / (w + b);
                w *= i;
                b *= i;
            }
            for (i = 0; i < 3; i++) {
                rgb[i] *= 1 - w - b;
                rgb[i] += w;
            }
            return rgb;
        }
        function hueValue(r, g, b, d, max) {
            if (r === max) return (g - b) / d + (g < b ? 6 : 0);
            if (g === max) return (b - r) / d + 2;
            return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
            const range = 255;
            const r = v.r / range;
            const g = v.g / range;
            const b = v.b / range;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const l = (max + min) / 2;
            let h, s, d;
            if (max !== min) {
                d = max - min;
                s = l > .5 ? d / (2 - max - min) : d / (max + min);
                h = hueValue(r, g, b, d, max);
                h = h * 60 + .5;
            }
            return [ h | 0, s || 0, l ];
        }
        function calln(f, a, b, c) {
            return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
            return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
            return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
            return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
            return (h % 360 + 360) % 360;
        }
        function hueParse(str) {
            const m = HUE_RE.exec(str);
            let a = 255;
            let v;
            if (!m) return;
            if (m[5] !== v) a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
            const h = hue(+m[2]);
            const p1 = +m[3] / 100;
            const p2 = +m[4] / 100;
            if (m[1] === "hwb") v = hwb2rgb(h, p1, p2); else if (m[1] === "hsv") v = hsv2rgb(h, p1, p2); else v = hsl2rgb(h, p1, p2);
            return {
                r: v[0],
                g: v[1],
                b: v[2],
                a
            };
        }
        function rotate(v, deg) {
            var h = rgb2hsl(v);
            h[0] = hue(h[0] + deg);
            h = hsl2rgb(h);
            v.r = h[0];
            v.g = h[1];
            v.b = h[2];
        }
        function hslString(v) {
            if (!v) return;
            const a = rgb2hsl(v);
            const h = a[0];
            const s = n2p(a[1]);
            const l = n2p(a[2]);
            return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
        }
        const map = {
            x: "dark",
            Z: "light",
            Y: "re",
            X: "blu",
            W: "gr",
            V: "medium",
            U: "slate",
            A: "ee",
            T: "ol",
            S: "or",
            B: "ra",
            C: "lateg",
            D: "ights",
            R: "in",
            Q: "turquois",
            E: "hi",
            P: "ro",
            O: "al",
            N: "le",
            M: "de",
            L: "yello",
            F: "en",
            K: "ch",
            G: "arks",
            H: "ea",
            I: "ightg",
            J: "wh"
        };
        const names$1 = {
            OiceXe: "f0f8ff",
            antiquewEte: "faebd7",
            aqua: "ffff",
            aquamarRe: "7fffd4",
            azuY: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "0",
            blanKedOmond: "ffebcd",
            Xe: "ff",
            XeviTet: "8a2be2",
            bPwn: "a52a2a",
            burlywood: "deb887",
            caMtXe: "5f9ea0",
            KartYuse: "7fff00",
            KocTate: "d2691e",
            cSO: "ff7f50",
            cSnflowerXe: "6495ed",
            cSnsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "ffff",
            xXe: "8b",
            xcyan: "8b8b",
            xgTMnPd: "b8860b",
            xWay: "a9a9a9",
            xgYF: "6400",
            xgYy: "a9a9a9",
            xkhaki: "bdb76b",
            xmagFta: "8b008b",
            xTivegYF: "556b2f",
            xSange: "ff8c00",
            xScEd: "9932cc",
            xYd: "8b0000",
            xsOmon: "e9967a",
            xsHgYF: "8fbc8f",
            xUXe: "483d8b",
            xUWay: "2f4f4f",
            xUgYy: "2f4f4f",
            xQe: "ced1",
            xviTet: "9400d3",
            dAppRk: "ff1493",
            dApskyXe: "bfff",
            dimWay: "696969",
            dimgYy: "696969",
            dodgerXe: "1e90ff",
            fiYbrick: "b22222",
            flSOwEte: "fffaf0",
            foYstWAn: "228b22",
            fuKsia: "ff00ff",
            gaRsbSo: "dcdcdc",
            ghostwEte: "f8f8ff",
            gTd: "ffd700",
            gTMnPd: "daa520",
            Way: "808080",
            gYF: "8000",
            gYFLw: "adff2f",
            gYy: "808080",
            honeyMw: "f0fff0",
            hotpRk: "ff69b4",
            RdianYd: "cd5c5c",
            Rdigo: "4b0082",
            ivSy: "fffff0",
            khaki: "f0e68c",
            lavFMr: "e6e6fa",
            lavFMrXsh: "fff0f5",
            lawngYF: "7cfc00",
            NmoncEffon: "fffacd",
            ZXe: "add8e6",
            ZcSO: "f08080",
            Zcyan: "e0ffff",
            ZgTMnPdLw: "fafad2",
            ZWay: "d3d3d3",
            ZgYF: "90ee90",
            ZgYy: "d3d3d3",
            ZpRk: "ffb6c1",
            ZsOmon: "ffa07a",
            ZsHgYF: "20b2aa",
            ZskyXe: "87cefa",
            ZUWay: "778899",
            ZUgYy: "778899",
            ZstAlXe: "b0c4de",
            ZLw: "ffffe0",
            lime: "ff00",
            limegYF: "32cd32",
            lRF: "faf0e6",
            magFta: "ff00ff",
            maPon: "800000",
            VaquamarRe: "66cdaa",
            VXe: "cd",
            VScEd: "ba55d3",
            VpurpN: "9370db",
            VsHgYF: "3cb371",
            VUXe: "7b68ee",
            VsprRggYF: "fa9a",
            VQe: "48d1cc",
            VviTetYd: "c71585",
            midnightXe: "191970",
            mRtcYam: "f5fffa",
            mistyPse: "ffe4e1",
            moccasR: "ffe4b5",
            navajowEte: "ffdead",
            navy: "80",
            Tdlace: "fdf5e6",
            Tive: "808000",
            TivedBb: "6b8e23",
            Sange: "ffa500",
            SangeYd: "ff4500",
            ScEd: "da70d6",
            pOegTMnPd: "eee8aa",
            pOegYF: "98fb98",
            pOeQe: "afeeee",
            pOeviTetYd: "db7093",
            papayawEp: "ffefd5",
            pHKpuff: "ffdab9",
            peru: "cd853f",
            pRk: "ffc0cb",
            plum: "dda0dd",
            powMrXe: "b0e0e6",
            purpN: "800080",
            YbeccapurpN: "663399",
            Yd: "ff0000",
            Psybrown: "bc8f8f",
            PyOXe: "4169e1",
            saddNbPwn: "8b4513",
            sOmon: "fa8072",
            sandybPwn: "f4a460",
            sHgYF: "2e8b57",
            sHshell: "fff5ee",
            siFna: "a0522d",
            silver: "c0c0c0",
            skyXe: "87ceeb",
            UXe: "6a5acd",
            UWay: "708090",
            UgYy: "708090",
            snow: "fffafa",
            sprRggYF: "ff7f",
            stAlXe: "4682b4",
            tan: "d2b48c",
            teO: "8080",
            tEstN: "d8bfd8",
            tomato: "ff6347",
            Qe: "40e0d0",
            viTet: "ee82ee",
            JHt: "f5deb3",
            wEte: "ffffff",
            wEtesmoke: "f5f5f5",
            Lw: "ffff00",
            LwgYF: "9acd32"
        };
        function unpack() {
            const unpacked = {};
            const keys = Object.keys(names$1);
            const tkeys = Object.keys(map);
            let i, j, k, ok, nk;
            for (i = 0; i < keys.length; i++) {
                ok = nk = keys[i];
                for (j = 0; j < tkeys.length; j++) {
                    k = tkeys[j];
                    nk = nk.replace(k, map[k]);
                }
                k = parseInt(names$1[ok], 16);
                unpacked[nk] = [ k >> 16 & 255, k >> 8 & 255, k & 255 ];
            }
            return unpacked;
        }
        let names;
        function nameParse(str) {
            if (!names) {
                names = unpack();
                names.transparent = [ 0, 0, 0, 0 ];
            }
            const a = names[str.toLowerCase()];
            return a && {
                r: a[0],
                g: a[1],
                b: a[2],
                a: a.length === 4 ? a[3] : 255
            };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
            const m = RGB_RE.exec(str);
            let a = 255;
            let r, g, b;
            if (!m) return;
            if (m[7] !== r) {
                const v = +m[7];
                a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
            }
            r = +m[1];
            g = +m[3];
            b = +m[5];
            r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
            g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
            b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
            return {
                r,
                g,
                b,
                a
            };
        }
        function rgbString(v) {
            return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to = v => v <= .0031308 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - .055;
        const from = v => v <= .04045 ? v / 12.92 : Math.pow((v + .055) / 1.055, 2.4);
        function interpolate(rgb1, rgb2, t) {
            const r = from(b2n(rgb1.r));
            const g = from(b2n(rgb1.g));
            const b = from(b2n(rgb1.b));
            return {
                r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
                g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
                b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
                a: rgb1.a + t * (rgb2.a - rgb1.a)
            };
        }
        function modHSL(v, i, ratio) {
            if (v) {
                let tmp = rgb2hsl(v);
                tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
                tmp = hsl2rgb(tmp);
                v.r = tmp[0];
                v.g = tmp[1];
                v.b = tmp[2];
            }
        }
        function clone(v, proto) {
            return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
            var v = {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            };
            if (Array.isArray(input)) {
                if (input.length >= 3) {
                    v = {
                        r: input[0],
                        g: input[1],
                        b: input[2],
                        a: 255
                    };
                    if (input.length > 3) v.a = n2b(input[3]);
                }
            } else {
                v = clone(input, {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                });
                v.a = n2b(v.a);
            }
            return v;
        }
        function functionParse(str) {
            if (str.charAt(0) === "r") return rgbParse(str);
            return hueParse(str);
        }
        class Color {
            constructor(input) {
                if (input instanceof Color) return input;
                const type = typeof input;
                let v;
                if (type === "object") v = fromObject(input); else if (type === "string") v = hexParse(input) || nameParse(input) || functionParse(input);
                this._rgb = v;
                this._valid = !!v;
            }
            get valid() {
                return this._valid;
            }
            get rgb() {
                var v = clone(this._rgb);
                if (v) v.a = b2n(v.a);
                return v;
            }
            set rgb(obj) {
                this._rgb = fromObject(obj);
            }
            rgbString() {
                return this._valid ? rgbString(this._rgb) : void 0;
            }
            hexString() {
                return this._valid ? hexString(this._rgb) : void 0;
            }
            hslString() {
                return this._valid ? hslString(this._rgb) : void 0;
            }
            mix(color, weight) {
                if (color) {
                    const c1 = this.rgb;
                    const c2 = color.rgb;
                    let w2;
                    const p = weight === w2 ? .5 : weight;
                    const w = 2 * p - 1;
                    const a = c1.a - c2.a;
                    const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
                    w2 = 1 - w1;
                    c1.r = 255 & w1 * c1.r + w2 * c2.r + .5;
                    c1.g = 255 & w1 * c1.g + w2 * c2.g + .5;
                    c1.b = 255 & w1 * c1.b + w2 * c2.b + .5;
                    c1.a = p * c1.a + (1 - p) * c2.a;
                    this.rgb = c1;
                }
                return this;
            }
            interpolate(color, t) {
                if (color) this._rgb = interpolate(this._rgb, color._rgb, t);
                return this;
            }
            clone() {
                return new Color(this.rgb);
            }
            alpha(a) {
                this._rgb.a = n2b(a);
                return this;
            }
            clearer(ratio) {
                const rgb = this._rgb;
                rgb.a *= 1 - ratio;
                return this;
            }
            greyscale() {
                const rgb = this._rgb;
                const val = round(rgb.r * .3 + rgb.g * .59 + rgb.b * .11);
                rgb.r = rgb.g = rgb.b = val;
                return this;
            }
            opaquer(ratio) {
                const rgb = this._rgb;
                rgb.a *= 1 + ratio;
                return this;
            }
            negate() {
                const v = this._rgb;
                v.r = 255 - v.r;
                v.g = 255 - v.g;
                v.b = 255 - v.b;
                return this;
            }
            lighten(ratio) {
                modHSL(this._rgb, 2, ratio);
                return this;
            }
            darken(ratio) {
                modHSL(this._rgb, 2, -ratio);
                return this;
            }
            saturate(ratio) {
                modHSL(this._rgb, 1, ratio);
                return this;
            }
            desaturate(ratio) {
                modHSL(this._rgb, 1, -ratio);
                return this;
            }
            rotate(deg) {
                rotate(this._rgb, deg);
                return this;
            }
        }
        /*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
        function noop() {}
        const uid = (() => {
            let id = 0;
            return () => id++;
        })();
        function isNullOrUndef(value) {
            return value === null || typeof value === "undefined";
        }
        function isArray(value) {
            if (Array.isArray && Array.isArray(value)) return true;
            const type = Object.prototype.toString.call(value);
            if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") return true;
            return false;
        }
        function helpers_segment_isObject(value) {
            return value !== null && Object.prototype.toString.call(value) === "[object Object]";
        }
        function isNumberFinite(value) {
            return (typeof value === "number" || value instanceof Number) && isFinite(+value);
        }
        function finiteOrDefault(value, defaultValue) {
            return isNumberFinite(value) ? value : defaultValue;
        }
        function valueOrDefault(value, defaultValue) {
            return typeof value === "undefined" ? defaultValue : value;
        }
        const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
        const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
        function callback(fn, args, thisArg) {
            if (fn && typeof fn.call === "function") return fn.apply(thisArg, args);
        }
        function each(loopable, fn, thisArg, reverse) {
            let i, len, keys;
            if (isArray(loopable)) {
                len = loopable.length;
                if (reverse) for (i = len - 1; i >= 0; i--) fn.call(thisArg, loopable[i], i); else for (i = 0; i < len; i++) fn.call(thisArg, loopable[i], i);
            } else if (helpers_segment_isObject(loopable)) {
                keys = Object.keys(loopable);
                len = keys.length;
                for (i = 0; i < len; i++) fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
        }
        function _elementsEqual(a0, a1) {
            let i, ilen, v0, v1;
            if (!a0 || !a1 || a0.length !== a1.length) return false;
            for (i = 0, ilen = a0.length; i < ilen; ++i) {
                v0 = a0[i];
                v1 = a1[i];
                if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) return false;
            }
            return true;
        }
        function helpers_segment_clone(source) {
            if (isArray(source)) return source.map(helpers_segment_clone);
            if (helpers_segment_isObject(source)) {
                const target = Object.create(null);
                const keys = Object.keys(source);
                const klen = keys.length;
                let k = 0;
                for (;k < klen; ++k) target[keys[k]] = helpers_segment_clone(source[keys[k]]);
                return target;
            }
            return source;
        }
        function isValidKey(key) {
            return [ "__proto__", "prototype", "constructor" ].indexOf(key) === -1;
        }
        function _merger(key, target, source, options) {
            if (!isValidKey(key)) return;
            const tval = target[key];
            const sval = source[key];
            if (helpers_segment_isObject(tval) && helpers_segment_isObject(sval)) merge(tval, sval, options); else target[key] = helpers_segment_clone(sval);
        }
        function merge(target, source, options) {
            const sources = isArray(source) ? source : [ source ];
            const ilen = sources.length;
            if (!helpers_segment_isObject(target)) return target;
            options = options || {};
            const merger = options.merger || _merger;
            let current;
            for (let i = 0; i < ilen; ++i) {
                current = sources[i];
                if (!helpers_segment_isObject(current)) continue;
                const keys = Object.keys(current);
                for (let k = 0, klen = keys.length; k < klen; ++k) merger(keys[k], target, current, options);
            }
            return target;
        }
        function mergeIf(target, source) {
            return merge(target, source, {
                merger: _mergerIf
            });
        }
        function _mergerIf(key, target, source) {
            if (!isValidKey(key)) return;
            const tval = target[key];
            const sval = source[key];
            if (helpers_segment_isObject(tval) && helpers_segment_isObject(sval)) mergeIf(tval, sval); else if (!Object.prototype.hasOwnProperty.call(target, key)) target[key] = helpers_segment_clone(sval);
        }
        const keyResolvers = {
            "": v => v,
            x: o => o.x,
            y: o => o.y
        };
        function _splitKey(key) {
            const parts = key.split(".");
            const keys = [];
            let tmp = "";
            for (const part of parts) {
                tmp += part;
                if (tmp.endsWith("\\")) tmp = tmp.slice(0, -1) + "."; else {
                    keys.push(tmp);
                    tmp = "";
                }
            }
            return keys;
        }
        function _getKeyResolver(key) {
            const keys = _splitKey(key);
            return obj => {
                for (const k of keys) {
                    if (k === "") break;
                    obj = obj && obj[k];
                }
                return obj;
            };
        }
        function resolveObjectKey(obj, key) {
            const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
            return resolver(obj);
        }
        function _capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = value => typeof value !== "undefined";
        const isFunction = value => typeof value === "function";
        const setsEqual = (a, b) => {
            if (a.size !== b.size) return false;
            for (const item of a) if (!b.has(item)) return false;
            return true;
        };
        function _isClickEvent(e) {
            return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
        }
        const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = PI * 2 / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function almostEquals(x, y, epsilon) {
            return Math.abs(x - y) < epsilon;
        }
        function niceNum(range) {
            const roundedRange = Math.round(range);
            range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
            const niceRange = Math.pow(10, Math.floor(log10(range)));
            const fraction = range / niceRange;
            const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
            return niceFraction * niceRange;
        }
        function _factorize(value) {
            const result = [];
            const sqrt = Math.sqrt(value);
            let i;
            for (i = 1; i < sqrt; i++) if (value % i === 0) {
                result.push(i);
                result.push(value / i);
            }
            if (sqrt === (sqrt | 0)) result.push(sqrt);
            result.sort(((a, b) => a - b)).pop();
            return result;
        }
        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostWhole(x, epsilon) {
            const rounded = Math.round(x);
            return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        function _setMinAndMaxByKey(array, target, property) {
            let i, ilen, value;
            for (i = 0, ilen = array.length; i < ilen; i++) {
                value = array[i][property];
                if (!isNaN(value)) {
                    target.min = Math.min(target.min, value);
                    target.max = Math.max(target.max, value);
                }
            }
        }
        function toRadians(degrees) {
            return degrees * (PI / 180);
        }
        function toDegrees(radians) {
            return radians * (180 / PI);
        }
        function _decimalPlaces(x) {
            if (!isNumberFinite(x)) return;
            let e = 1;
            let p = 0;
            while (Math.round(x * e) / e !== x) {
                e *= 10;
                p++;
            }
            return p;
        }
        function getAngleFromPoint(centrePoint, anglePoint) {
            const distanceFromXCenter = anglePoint.x - centrePoint.x;
            const distanceFromYCenter = anglePoint.y - centrePoint.y;
            const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
            let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
            if (angle < -.5 * PI) angle += TAU;
            return {
                angle,
                distance: radialDistanceFromCenter
            };
        }
        function distanceBetweenPoints(pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        }
        function _angleDiff(a, b) {
            return (a - b + PITAU) % TAU - PI;
        }
        function _normalizeAngle(a) {
            return (a % TAU + TAU) % TAU;
        }
        function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
            const a = _normalizeAngle(angle);
            const s = _normalizeAngle(start);
            const e = _normalizeAngle(end);
            const angleToStart = _normalizeAngle(s - a);
            const angleToEnd = _normalizeAngle(e - a);
            const startToAngle = _normalizeAngle(a - s);
            const endToAngle = _normalizeAngle(a - e);
            return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
        }
        function _limitValue(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        function _int16Range(value) {
            return _limitValue(value, -32768, 32767);
        }
        function _isBetween(value, start, end, epsilon = 1e-6) {
            return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
        }
        function _lookup(table, value, cmp) {
            cmp = cmp || (index => table[index] < value);
            let hi = table.length - 1;
            let lo = 0;
            let mid;
            while (hi - lo > 1) {
                mid = lo + hi >> 1;
                if (cmp(mid)) lo = mid; else hi = mid;
            }
            return {
                lo,
                hi
            };
        }
        const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? index => {
            const ti = table[index][key];
            return ti < value || ti === value && table[index + 1][key] === value;
        } : index => table[index][key] < value);
        const _rlookupByKey = (table, key, value) => _lookup(table, value, (index => table[index][key] >= value));
        function _filterBetween(values, min, max) {
            let start = 0;
            let end = values.length;
            while (start < end && values[start] < min) start++;
            while (end > start && values[end - 1] > max) end--;
            return start > 0 || end < values.length ? values.slice(start, end) : values;
        }
        const arrayEvents = [ "push", "pop", "shift", "splice", "unshift" ];
        function listenArrayEvents(array, listener) {
            if (array._chartjs) {
                array._chartjs.listeners.push(listener);
                return;
            }
            Object.defineProperty(array, "_chartjs", {
                configurable: true,
                enumerable: false,
                value: {
                    listeners: [ listener ]
                }
            });
            arrayEvents.forEach((key => {
                const method = "_onData" + _capitalize(key);
                const base = array[key];
                Object.defineProperty(array, key, {
                    configurable: true,
                    enumerable: false,
                    value(...args) {
                        const res = base.apply(this, args);
                        array._chartjs.listeners.forEach((object => {
                            if (typeof object[method] === "function") object[method](...args);
                        }));
                        return res;
                    }
                });
            }));
        }
        function unlistenArrayEvents(array, listener) {
            const stub = array._chartjs;
            if (!stub) return;
            const listeners = stub.listeners;
            const index = listeners.indexOf(listener);
            if (index !== -1) listeners.splice(index, 1);
            if (listeners.length > 0) return;
            arrayEvents.forEach((key => {
                delete array[key];
            }));
            delete array._chartjs;
        }
        function _arrayUnique(items) {
            const set = new Set(items);
            if (set.size === items.length) return items;
            return Array.from(set);
        }
        const requestAnimFrame = function() {
            if (typeof window === "undefined") return function(callback) {
                return callback();
            };
            return window.requestAnimationFrame;
        }();
        function throttled(fn, thisArg) {
            let argsToUse = [];
            let ticking = false;
            return function(...args) {
                argsToUse = args;
                if (!ticking) {
                    ticking = true;
                    requestAnimFrame.call(window, (() => {
                        ticking = false;
                        fn.apply(thisArg, argsToUse);
                    }));
                }
            };
        }
        function debounce(fn, delay) {
            let timeout;
            return function(...args) {
                if (delay) {
                    clearTimeout(timeout);
                    timeout = setTimeout(fn, delay, args);
                } else fn.apply(this, args);
                return delay;
            };
        }
        const _toLeftRightCenter = align => align === "start" ? "left" : align === "end" ? "right" : "center";
        const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
        const _textX = (align, left, right, rtl) => {
            const check = rtl ? "left" : "right";
            return align === check ? right : align === "center" ? (left + right) / 2 : left;
        };
        function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
            const pointCount = points.length;
            let start = 0;
            let count = pointCount;
            if (meta._sorted) {
                const {iScale, _parsed} = meta;
                const axis = iScale.axis;
                const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
                if (minDefined) start = _limitValue(Math.min(_lookupByKey(_parsed, axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
                if (maxDefined) count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start; else count = pointCount - start;
            }
            return {
                start,
                count
            };
        }
        function _scaleRangesChanged(meta) {
            const {xScale, yScale, _scaleRanges} = meta;
            const newRanges = {
                xmin: xScale.min,
                xmax: xScale.max,
                ymin: yScale.min,
                ymax: yScale.max
            };
            if (!_scaleRanges) {
                meta._scaleRanges = newRanges;
                return true;
            }
            const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
            Object.assign(_scaleRanges, newRanges);
            return changed;
        }
        const atEdge = t => t === 0 || t === 1;
        const elasticIn = (t, s, p) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p);
        const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
        const effects = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => -t * (t - 2),
            easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (t -= 1) * t * t + 1,
            easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
            easeInQuart: t => t * t * t * t,
            easeOutQuart: t => -((t -= 1) * t * t * t - 1),
            easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
            easeInQuint: t => t * t * t * t * t,
            easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
            easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
            easeInSine: t => -Math.cos(t * HALF_PI) + 1,
            easeOutSine: t => Math.sin(t * HALF_PI),
            easeInOutSine: t => -.5 * (Math.cos(PI * t) - 1),
            easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
            easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
            easeInOutExpo: t => atEdge(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (t * 2 - 1)) : .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
            easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
            easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
            easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
            easeInElastic: t => atEdge(t) ? t : elasticIn(t, .075, .3),
            easeOutElastic: t => atEdge(t) ? t : elasticOut(t, .075, .3),
            easeInOutElastic(t) {
                const s = .1125;
                const p = .45;
                return atEdge(t) ? t : t < .5 ? .5 * elasticIn(t * 2, s, p) : .5 + .5 * elasticOut(t * 2 - 1, s, p);
            },
            easeInBack(t) {
                const s = 1.70158;
                return t * t * ((s + 1) * t - s);
            },
            easeOutBack(t) {
                const s = 1.70158;
                return (t -= 1) * t * ((s + 1) * t + s) + 1;
            },
            easeInOutBack(t) {
                let s = 1.70158;
                if ((t /= .5) < 1) return .5 * (t * t * (((s *= 1.525) + 1) * t - s));
                return .5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
            },
            easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
            easeOutBounce(t) {
                const m = 7.5625;
                const d = 2.75;
                if (t < 1 / d) return m * t * t;
                if (t < 2 / d) return m * (t -= 1.5 / d) * t + .75;
                if (t < 2.5 / d) return m * (t -= 2.25 / d) * t + .9375;
                return m * (t -= 2.625 / d) * t + .984375;
            },
            easeInOutBounce: t => t < .5 ? effects.easeInBounce(t * 2) * .5 : effects.easeOutBounce(t * 2 - 1) * .5 + .5
        };
        function isPatternOrGradient(value) {
            if (value && typeof value === "object") {
                const type = value.toString();
                return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
            }
            return false;
        }
        function color(value) {
            return isPatternOrGradient(value) ? value : new Color(value);
        }
        function getHoverColor(value) {
            return isPatternOrGradient(value) ? value : new Color(value).saturate(.5).darken(.1).hexString();
        }
        const numbers = [ "x", "y", "borderWidth", "radius", "tension" ];
        const colors = [ "color", "borderColor", "backgroundColor" ];
        function applyAnimationsDefaults(defaults) {
            defaults.set("animation", {
                delay: void 0,
                duration: 1e3,
                easing: "easeOutQuart",
                fn: void 0,
                from: void 0,
                loop: void 0,
                to: void 0,
                type: void 0
            });
            defaults.describe("animation", {
                _fallback: false,
                _indexable: false,
                _scriptable: name => name !== "onProgress" && name !== "onComplete" && name !== "fn"
            });
            defaults.set("animations", {
                colors: {
                    type: "color",
                    properties: colors
                },
                numbers: {
                    type: "number",
                    properties: numbers
                }
            });
            defaults.describe("animations", {
                _fallback: "animation"
            });
            defaults.set("transitions", {
                active: {
                    animation: {
                        duration: 400
                    }
                },
                resize: {
                    animation: {
                        duration: 0
                    }
                },
                show: {
                    animations: {
                        colors: {
                            from: "transparent"
                        },
                        visible: {
                            type: "boolean",
                            duration: 0
                        }
                    }
                },
                hide: {
                    animations: {
                        colors: {
                            to: "transparent"
                        },
                        visible: {
                            type: "boolean",
                            easing: "linear",
                            fn: v => v | 0
                        }
                    }
                }
            });
        }
        function applyLayoutsDefaults(defaults) {
            defaults.set("layout", {
                autoPadding: true,
                padding: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            });
        }
        const intlCache = new Map;
        function getNumberFormat(locale, options) {
            options = options || {};
            const cacheKey = locale + JSON.stringify(options);
            let formatter = intlCache.get(cacheKey);
            if (!formatter) {
                formatter = new Intl.NumberFormat(locale, options);
                intlCache.set(cacheKey, formatter);
            }
            return formatter;
        }
        function formatNumber(num, locale, options) {
            return getNumberFormat(locale, options).format(num);
        }
        const formatters = {
            values(value) {
                return isArray(value) ? value : "" + value;
            },
            numeric(tickValue, index, ticks) {
                if (tickValue === 0) return "0";
                const locale = this.chart.options.locale;
                let notation;
                let delta = tickValue;
                if (ticks.length > 1) {
                    const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
                    if (maxTick < 1e-4 || maxTick > 1e15) notation = "scientific";
                    delta = calculateDelta(tickValue, ticks);
                }
                const logDelta = log10(Math.abs(delta));
                const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
                const options = {
                    notation,
                    minimumFractionDigits: numDecimal,
                    maximumFractionDigits: numDecimal
                };
                Object.assign(options, this.options.ticks.format);
                return formatNumber(tickValue, locale, options);
            },
            logarithmic(tickValue, index, ticks) {
                if (tickValue === 0) return "0";
                const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
                if ([ 1, 2, 3, 5, 10, 15 ].includes(remain) || index > .8 * ticks.length) return formatters.numeric.call(this, tickValue, index, ticks);
                return "";
            }
        };
        function calculateDelta(tickValue, ticks) {
            let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
            if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) delta = tickValue - Math.floor(tickValue);
            return delta;
        }
        var Ticks = {
            formatters
        };
        function applyScaleDefaults(defaults) {
            defaults.set("scale", {
                display: true,
                offset: false,
                reverse: false,
                beginAtZero: false,
                bounds: "ticks",
                clip: true,
                grace: 0,
                grid: {
                    display: true,
                    lineWidth: 1,
                    drawOnChartArea: true,
                    drawTicks: true,
                    tickLength: 8,
                    tickWidth: (_ctx, options) => options.lineWidth,
                    tickColor: (_ctx, options) => options.color,
                    offset: false
                },
                border: {
                    display: true,
                    dash: [],
                    dashOffset: 0,
                    width: 1
                },
                title: {
                    display: false,
                    text: "",
                    padding: {
                        top: 4,
                        bottom: 4
                    }
                },
                ticks: {
                    minRotation: 0,
                    maxRotation: 50,
                    mirror: false,
                    textStrokeWidth: 0,
                    textStrokeColor: "",
                    padding: 3,
                    display: true,
                    autoSkip: true,
                    autoSkipPadding: 3,
                    labelOffset: 0,
                    callback: Ticks.formatters.values,
                    minor: {},
                    major: {},
                    align: "center",
                    crossAlign: "near",
                    showLabelBackdrop: false,
                    backdropColor: "rgba(255, 255, 255, 0.75)",
                    backdropPadding: 2
                }
            });
            defaults.route("scale.ticks", "color", "", "color");
            defaults.route("scale.grid", "color", "", "borderColor");
            defaults.route("scale.border", "color", "", "borderColor");
            defaults.route("scale.title", "color", "", "color");
            defaults.describe("scale", {
                _fallback: false,
                _scriptable: name => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
                _indexable: name => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
            });
            defaults.describe("scales", {
                _fallback: "scale"
            });
            defaults.describe("scale.ticks", {
                _scriptable: name => name !== "backdropPadding" && name !== "callback",
                _indexable: name => name !== "backdropPadding"
            });
        }
        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
            if (!key) return node;
            const keys = key.split(".");
            for (let i = 0, n = keys.length; i < n; ++i) {
                const k = keys[i];
                node = node[k] || (node[k] = Object.create(null));
            }
            return node;
        }
        function set(root, scope, values) {
            if (typeof scope === "string") return merge(getScope$1(root, scope), values);
            return merge(getScope$1(root, ""), scope);
        }
        class Defaults {
            constructor(_descriptors, _appliers) {
                this.animation = void 0;
                this.backgroundColor = "rgba(0,0,0,0.1)";
                this.borderColor = "rgba(0,0,0,0.1)";
                this.color = "#666";
                this.datasets = {};
                this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio();
                this.elements = {};
                this.events = [ "mousemove", "mouseout", "click", "touchstart", "touchmove" ];
                this.font = {
                    family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                    size: 12,
                    style: "normal",
                    lineHeight: 1.2,
                    weight: null
                };
                this.hover = {};
                this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
                this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
                this.hoverColor = (ctx, options) => getHoverColor(options.color);
                this.indexAxis = "x";
                this.interaction = {
                    mode: "nearest",
                    intersect: true,
                    includeInvisible: false
                };
                this.maintainAspectRatio = true;
                this.onHover = null;
                this.onClick = null;
                this.parsing = true;
                this.plugins = {};
                this.responsive = true;
                this.scale = void 0;
                this.scales = {};
                this.showLine = true;
                this.drawActiveElementsOnTop = true;
                this.describe(_descriptors);
                this.apply(_appliers);
            }
            set(scope, values) {
                return set(this, scope, values);
            }
            get(scope) {
                return getScope$1(this, scope);
            }
            describe(scope, values) {
                return set(descriptors, scope, values);
            }
            override(scope, values) {
                return set(overrides, scope, values);
            }
            route(scope, name, targetScope, targetName) {
                const scopeObject = getScope$1(this, scope);
                const targetScopeObject = getScope$1(this, targetScope);
                const privateName = "_" + name;
                Object.defineProperties(scopeObject, {
                    [privateName]: {
                        value: scopeObject[name],
                        writable: true
                    },
                    [name]: {
                        enumerable: true,
                        get() {
                            const local = this[privateName];
                            const target = targetScopeObject[targetName];
                            if (helpers_segment_isObject(local)) return Object.assign({}, target, local);
                            return valueOrDefault(local, target);
                        },
                        set(value) {
                            this[privateName] = value;
                        }
                    }
                });
            }
            apply(appliers) {
                appliers.forEach((apply => apply(this)));
            }
        }
        var helpers_segment_defaults = new Defaults({
            _scriptable: name => !name.startsWith("on"),
            _indexable: name => name !== "events",
            hover: {
                _fallback: "interaction"
            },
            interaction: {
                _scriptable: false,
                _indexable: false
            }
        }, [ applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults ]);
        function toFontString(font) {
            if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) return null;
            return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        function _measureText(ctx, data, gc, longest, string) {
            let textWidth = data[string];
            if (!textWidth) {
                textWidth = data[string] = ctx.measureText(string).width;
                gc.push(string);
            }
            if (textWidth > longest) longest = textWidth;
            return longest;
        }
        function _longestText(ctx, font, arrayOfThings, cache) {
            cache = cache || {};
            let data = cache.data = cache.data || {};
            let gc = cache.garbageCollect = cache.garbageCollect || [];
            if (cache.font !== font) {
                data = cache.data = {};
                gc = cache.garbageCollect = [];
                cache.font = font;
            }
            ctx.save();
            ctx.font = font;
            let longest = 0;
            const ilen = arrayOfThings.length;
            let i, j, jlen, thing, nestedThing;
            for (i = 0; i < ilen; i++) {
                thing = arrayOfThings[i];
                if (thing !== void 0 && thing !== null && !isArray(thing)) longest = _measureText(ctx, data, gc, longest, thing); else if (isArray(thing)) for (j = 0, 
                jlen = thing.length; j < jlen; j++) {
                    nestedThing = thing[j];
                    if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
            }
            ctx.restore();
            const gcLen = gc.length / 2;
            if (gcLen > arrayOfThings.length) {
                for (i = 0; i < gcLen; i++) delete data[gc[i]];
                gc.splice(0, gcLen);
            }
            return longest;
        }
        function _alignPixel(chart, pixel, width) {
            const devicePixelRatio = chart.currentDevicePixelRatio;
            const halfWidth = width !== 0 ? Math.max(width / 2, .5) : 0;
            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        }
        function clearCanvas(canvas, ctx) {
            ctx = ctx || canvas.getContext("2d");
            ctx.save();
            ctx.resetTransform();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
        function drawPoint(ctx, options, x, y) {
            drawPointLegend(ctx, options, x, y, null);
        }
        function drawPointLegend(ctx, options, x, y, w) {
            let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
            const style = options.pointStyle;
            const rotation = options.rotation;
            const radius = options.radius;
            let rad = (rotation || 0) * RAD_PER_DEG;
            if (style && typeof style === "object") {
                type = style.toString();
                if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rad);
                    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                    ctx.restore();
                    return;
                }
            }
            if (isNaN(radius) || radius <= 0) return;
            ctx.beginPath();
            switch (style) {
              default:
                if (w) ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU); else ctx.arc(x, y, radius, 0, TAU);
                ctx.closePath();
                break;

              case "triangle":
                width = w ? w / 2 : radius;
                ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                ctx.closePath();
                break;

              case "rectRounded":
                cornerRadius = radius * .516;
                size = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size;
                xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
                yOffset = Math.sin(rad + QUARTER_PI) * size;
                yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
                ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;

              case "rect":
                if (!rotation) {
                    size = Math.SQRT1_2 * radius;
                    width = w ? w / 2 : size;
                    ctx.rect(x - width, y - size, 2 * width, 2 * size);
                    break;
                }
                rad += QUARTER_PI;

              case "rectRot":
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                ctx.closePath();
                break;

              case "crossRot":
                rad += QUARTER_PI;

              case "cross":
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                break;

              case "star":
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                rad += QUARTER_PI;
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                break;

              case "line":
                xOffset = w ? w / 2 : Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                break;

              case "dash":
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
                break;

              case false:
                ctx.closePath();
                break;
            }
            ctx.fill();
            if (options.borderWidth > 0) ctx.stroke();
        }
        function _isPointInArea(point, area, margin) {
            margin = margin || .5;
            return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
        }
        function clipArea(ctx, area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
            ctx.clip();
        }
        function unclipArea(ctx) {
            ctx.restore();
        }
        function _steppedLineTo(ctx, previous, target, flip, mode) {
            if (!previous) return ctx.lineTo(target.x, target.y);
            if (mode === "middle") {
                const midpoint = (previous.x + target.x) / 2;
                ctx.lineTo(midpoint, previous.y);
                ctx.lineTo(midpoint, target.y);
            } else if (mode === "after" !== !!flip) ctx.lineTo(previous.x, target.y); else ctx.lineTo(target.x, previous.y);
            ctx.lineTo(target.x, target.y);
        }
        function _bezierCurveTo(ctx, previous, target, flip) {
            if (!previous) return ctx.lineTo(target.x, target.y);
            ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
        }
        function setRenderOpts(ctx, opts) {
            if (opts.translation) ctx.translate(opts.translation[0], opts.translation[1]);
            if (!isNullOrUndef(opts.rotation)) ctx.rotate(opts.rotation);
            if (opts.color) ctx.fillStyle = opts.color;
            if (opts.textAlign) ctx.textAlign = opts.textAlign;
            if (opts.textBaseline) ctx.textBaseline = opts.textBaseline;
        }
        function decorateText(ctx, x, y, line, opts) {
            if (opts.strikethrough || opts.underline) {
                const metrics = ctx.measureText(line);
                const left = x - metrics.actualBoundingBoxLeft;
                const right = x + metrics.actualBoundingBoxRight;
                const top = y - metrics.actualBoundingBoxAscent;
                const bottom = y + metrics.actualBoundingBoxDescent;
                const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
                ctx.strokeStyle = ctx.fillStyle;
                ctx.beginPath();
                ctx.lineWidth = opts.decorationWidth || 2;
                ctx.moveTo(left, yDecoration);
                ctx.lineTo(right, yDecoration);
                ctx.stroke();
            }
        }
        function drawBackdrop(ctx, opts) {
            const oldColor = ctx.fillStyle;
            ctx.fillStyle = opts.color;
            ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
            ctx.fillStyle = oldColor;
        }
        function renderText(ctx, text, x, y, font, opts = {}) {
            const lines = isArray(text) ? text : [ text ];
            const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
            let i, line;
            ctx.save();
            ctx.font = font.string;
            setRenderOpts(ctx, opts);
            for (i = 0; i < lines.length; ++i) {
                line = lines[i];
                if (opts.backdrop) drawBackdrop(ctx, opts.backdrop);
                if (stroke) {
                    if (opts.strokeColor) ctx.strokeStyle = opts.strokeColor;
                    if (!isNullOrUndef(opts.strokeWidth)) ctx.lineWidth = opts.strokeWidth;
                    ctx.strokeText(line, x, y, opts.maxWidth);
                }
                ctx.fillText(line, x, y, opts.maxWidth);
                decorateText(ctx, x, y, line, opts);
                y += Number(font.lineHeight);
            }
            ctx.restore();
        }
        function addRoundedRectPath(ctx, rect) {
            const {x, y, w, h, radius} = rect;
            ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
            ctx.lineTo(x, y + h - radius.bottomLeft);
            ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
            ctx.lineTo(x + w - radius.bottomRight, y + h);
            ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
            ctx.lineTo(x + w, y + radius.topRight);
            ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
            ctx.lineTo(x + radius.topLeft, y);
        }
        const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
        const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
        function toLineHeight(value, size) {
            const matches = ("" + value).match(LINE_HEIGHT);
            if (!matches || matches[1] === "normal") return size * 1.2;
            value = +matches[2];
            switch (matches[3]) {
              case "px":
                return value;

              case "%":
                value /= 100;
                break;
            }
            return size * value;
        }
        const numberOrZero = v => +v || 0;
        function _readValueToProps(value, props) {
            const ret = {};
            const objProps = helpers_segment_isObject(props);
            const keys = objProps ? Object.keys(props) : props;
            const read = helpers_segment_isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;
            for (const prop of keys) ret[prop] = numberOrZero(read(prop));
            return ret;
        }
        function toTRBL(value) {
            return _readValueToProps(value, {
                top: "y",
                right: "x",
                bottom: "y",
                left: "x"
            });
        }
        function toTRBLCorners(value) {
            return _readValueToProps(value, [ "topLeft", "topRight", "bottomLeft", "bottomRight" ]);
        }
        function toPadding(value) {
            const obj = toTRBL(value);
            obj.width = obj.left + obj.right;
            obj.height = obj.top + obj.bottom;
            return obj;
        }
        function toFont(options, fallback) {
            options = options || {};
            fallback = fallback || helpers_segment_defaults.font;
            let size = valueOrDefault(options.size, fallback.size);
            if (typeof size === "string") size = parseInt(size, 10);
            let style = valueOrDefault(options.style, fallback.style);
            if (style && !("" + style).match(FONT_STYLE)) {
                console.warn('Invalid font style specified: "' + style + '"');
                style = void 0;
            }
            const font = {
                family: valueOrDefault(options.family, fallback.family),
                lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
                size,
                style,
                weight: valueOrDefault(options.weight, fallback.weight),
                string: ""
            };
            font.string = toFontString(font);
            return font;
        }
        function resolve(inputs, context, index, info) {
            let cacheable = true;
            let i, ilen, value;
            for (i = 0, ilen = inputs.length; i < ilen; ++i) {
                value = inputs[i];
                if (value === void 0) continue;
                if (context !== void 0 && typeof value === "function") {
                    value = value(context);
                    cacheable = false;
                }
                if (index !== void 0 && isArray(value)) {
                    value = value[index % value.length];
                    cacheable = false;
                }
                if (value !== void 0) {
                    if (info && !cacheable) info.cacheable = false;
                    return value;
                }
            }
        }
        function _addGrace(minmax, grace, beginAtZero) {
            const {min, max} = minmax;
            const change = toDimension(grace, (max - min) / 2);
            const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
            return {
                min: keepZero(min, -Math.abs(change)),
                max: keepZero(max, change)
            };
        }
        function createContext(parentContext, context) {
            return Object.assign(Object.create(parentContext), context);
        }
        function _createResolver(scopes, prefixes = [ "" ], rootScopes, fallback, getTarget = (() => scopes[0])) {
            const finalRootScopes = rootScopes || scopes;
            if (typeof fallback === "undefined") fallback = _resolve("_fallback", scopes);
            const cache = {
                [Symbol.toStringTag]: "Object",
                _cacheable: true,
                _scopes: scopes,
                _rootScopes: finalRootScopes,
                _fallback: fallback,
                _getTarget: getTarget,
                override: scope => _createResolver([ scope, ...scopes ], prefixes, finalRootScopes, fallback)
            };
            return new Proxy(cache, {
                deleteProperty(target, prop) {
                    delete target[prop];
                    delete target._keys;
                    delete scopes[0][prop];
                    return true;
                },
                get(target, prop) {
                    return _cached(target, prop, (() => _resolveWithPrefixes(prop, prefixes, scopes, target)));
                },
                getOwnPropertyDescriptor(target, prop) {
                    return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
                },
                getPrototypeOf() {
                    return Reflect.getPrototypeOf(scopes[0]);
                },
                has(target, prop) {
                    return getKeysFromAllScopes(target).includes(prop);
                },
                ownKeys(target) {
                    return getKeysFromAllScopes(target);
                },
                set(target, prop, value) {
                    const storage = target._storage || (target._storage = getTarget());
                    target[prop] = storage[prop] = value;
                    delete target._keys;
                    return true;
                }
            });
        }
        function _attachContext(proxy, context, subProxy, descriptorDefaults) {
            const cache = {
                _cacheable: false,
                _proxy: proxy,
                _context: context,
                _subProxy: subProxy,
                _stack: new Set,
                _descriptors: _descriptors(proxy, descriptorDefaults),
                setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
                override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
            };
            return new Proxy(cache, {
                deleteProperty(target, prop) {
                    delete target[prop];
                    delete proxy[prop];
                    return true;
                },
                get(target, prop, receiver) {
                    return _cached(target, prop, (() => _resolveWithContext(target, prop, receiver)));
                },
                getOwnPropertyDescriptor(target, prop) {
                    return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                        enumerable: true,
                        configurable: true
                    } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
                },
                getPrototypeOf() {
                    return Reflect.getPrototypeOf(proxy);
                },
                has(target, prop) {
                    return Reflect.has(proxy, prop);
                },
                ownKeys() {
                    return Reflect.ownKeys(proxy);
                },
                set(target, prop, value) {
                    proxy[prop] = value;
                    delete target[prop];
                    return true;
                }
            });
        }
        function _descriptors(proxy, defaults = {
            scriptable: true,
            indexable: true
        }) {
            const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;
            return {
                allKeys: _allKeys,
                scriptable: _scriptable,
                indexable: _indexable,
                isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
                isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
            };
        }
        const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) => helpers_segment_isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
        function _cached(target, prop, resolve) {
            if (Object.prototype.hasOwnProperty.call(target, prop)) return target[prop];
            const value = resolve();
            target[prop] = value;
            return value;
        }
        function _resolveWithContext(target, prop, receiver) {
            const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
            let value = _proxy[prop];
            if (isFunction(value) && descriptors.isScriptable(prop)) value = _resolveScriptable(prop, value, target, receiver);
            if (isArray(value) && value.length) value = _resolveArray(prop, value, target, descriptors.isIndexable);
            if (needsSubResolver(prop, value)) value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
            return value;
        }
        function _resolveScriptable(prop, getValue, target, receiver) {
            const {_proxy, _context, _subProxy, _stack} = target;
            if (_stack.has(prop)) throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
            _stack.add(prop);
            let value = getValue(_context, _subProxy || receiver);
            _stack.delete(prop);
            if (needsSubResolver(prop, value)) value = createSubResolver(_proxy._scopes, _proxy, prop, value);
            return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
            const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
            if (typeof _context.index !== "undefined" && isIndexable(prop)) return value[_context.index % value.length]; else if (helpers_segment_isObject(value[0])) {
                const arr = value;
                const scopes = _proxy._scopes.filter((s => s !== arr));
                value = [];
                for (const item of arr) {
                    const resolver = createSubResolver(scopes, _proxy, prop, item);
                    value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
                }
            }
            return value;
        }
        function resolveFallback(fallback, prop, value) {
            return isFunction(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
        function addScopes(set, parentScopes, key, parentFallback, value) {
            for (const parent of parentScopes) {
                const scope = getScope(key, parent);
                if (scope) {
                    set.add(scope);
                    const fallback = resolveFallback(scope._fallback, key, value);
                    if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) return fallback;
                } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) return null;
            }
            return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
            const rootScopes = resolver._rootScopes;
            const fallback = resolveFallback(resolver._fallback, prop, value);
            const allScopes = [ ...parentScopes, ...rootScopes ];
            const set = new Set;
            set.add(value);
            let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
            if (key === null) return false;
            if (typeof fallback !== "undefined" && fallback !== prop) {
                key = addScopesFromKey(set, allScopes, fallback, key, value);
                if (key === null) return false;
            }
            return _createResolver(Array.from(set), [ "" ], rootScopes, fallback, (() => subGetTarget(resolver, prop, value)));
        }
        function addScopesFromKey(set, allScopes, key, fallback, item) {
            while (key) key = addScopes(set, allScopes, key, fallback, item);
            return key;
        }
        function subGetTarget(resolver, prop, value) {
            const parent = resolver._getTarget();
            if (!(prop in parent)) parent[prop] = {};
            const target = parent[prop];
            if (isArray(target) && helpers_segment_isObject(value)) return value;
            return target || {};
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
            let value;
            for (const prefix of prefixes) {
                value = _resolve(readKey(prefix, prop), scopes);
                if (typeof value !== "undefined") return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
        }
        function _resolve(key, scopes) {
            for (const scope of scopes) {
                if (!scope) continue;
                const value = scope[key];
                if (typeof value !== "undefined") return value;
            }
        }
        function getKeysFromAllScopes(target) {
            let keys = target._keys;
            if (!keys) keys = target._keys = resolveKeysFromAllScopes(target._scopes);
            return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
            const set = new Set;
            for (const scope of scopes) for (const key of Object.keys(scope).filter((k => !k.startsWith("_")))) set.add(key);
            return Array.from(set);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
            const {iScale} = meta;
            const {key = "r"} = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
                index = i + start;
                item = data[index];
                parsed[i] = {
                    r: iScale.parse(resolveObjectKey(item, key), index)
                };
            }
            return parsed;
        }
        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
        const getValueAxis = indexAxis => indexAxis === "x" ? "y" : "x";
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
            const previous = firstPoint.skip ? middlePoint : firstPoint;
            const current = middlePoint;
            const next = afterPoint.skip ? middlePoint : afterPoint;
            const d01 = distanceBetweenPoints(current, previous);
            const d12 = distanceBetweenPoints(next, current);
            let s01 = d01 / (d01 + d12);
            let s12 = d12 / (d01 + d12);
            s01 = isNaN(s01) ? 0 : s01;
            s12 = isNaN(s12) ? 0 : s12;
            const fa = t * s01;
            const fb = t * s12;
            return {
                previous: {
                    x: current.x - fa * (next.x - previous.x),
                    y: current.y - fa * (next.y - previous.y)
                },
                next: {
                    x: current.x + fb * (next.x - previous.x),
                    y: current.y + fb * (next.y - previous.y)
                }
            };
        }
        function monotoneAdjust(points, deltaK, mK) {
            const pointsLen = points.length;
            let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
            let pointAfter = getPoint(points, 0);
            for (let i = 0; i < pointsLen - 1; ++i) {
                pointCurrent = pointAfter;
                pointAfter = getPoint(points, i + 1);
                if (!pointCurrent || !pointAfter) continue;
                if (almostEquals(deltaK[i], 0, EPSILON)) {
                    mK[i] = mK[i + 1] = 0;
                    continue;
                }
                alphaK = mK[i] / deltaK[i];
                betaK = mK[i + 1] / deltaK[i];
                squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
                if (squaredMagnitude <= 9) continue;
                tauK = 3 / Math.sqrt(squaredMagnitude);
                mK[i] = alphaK * tauK * deltaK[i];
                mK[i + 1] = betaK * tauK * deltaK[i];
            }
        }
        function monotoneCompute(points, mK, indexAxis = "x") {
            const valueAxis = getValueAxis(indexAxis);
            const pointsLen = points.length;
            let delta, pointBefore, pointCurrent;
            let pointAfter = getPoint(points, 0);
            for (let i = 0; i < pointsLen; ++i) {
                pointBefore = pointCurrent;
                pointCurrent = pointAfter;
                pointAfter = getPoint(points, i + 1);
                if (!pointCurrent) continue;
                const iPixel = pointCurrent[indexAxis];
                const vPixel = pointCurrent[valueAxis];
                if (pointBefore) {
                    delta = (iPixel - pointBefore[indexAxis]) / 3;
                    pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
                    pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
                }
                if (pointAfter) {
                    delta = (pointAfter[indexAxis] - iPixel) / 3;
                    pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
                    pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
                }
            }
        }
        function splineCurveMonotone(points, indexAxis = "x") {
            const valueAxis = getValueAxis(indexAxis);
            const pointsLen = points.length;
            const deltaK = Array(pointsLen).fill(0);
            const mK = Array(pointsLen);
            let i, pointBefore, pointCurrent;
            let pointAfter = getPoint(points, 0);
            for (i = 0; i < pointsLen; ++i) {
                pointBefore = pointCurrent;
                pointCurrent = pointAfter;
                pointAfter = getPoint(points, i + 1);
                if (!pointCurrent) continue;
                if (pointAfter) {
                    const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
                    deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
                }
                mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
            }
            monotoneAdjust(points, deltaK, mK);
            monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt, min, max) {
            return Math.max(Math.min(pt, max), min);
        }
        function capBezierPoints(points, area) {
            let i, ilen, point, inArea, inAreaPrev;
            let inAreaNext = _isPointInArea(points[0], area);
            for (i = 0, ilen = points.length; i < ilen; ++i) {
                inAreaPrev = inArea;
                inArea = inAreaNext;
                inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
                if (!inArea) continue;
                point = points[i];
                if (inAreaPrev) {
                    point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
                    point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
                }
                if (inAreaNext) {
                    point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
                    point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
                }
            }
        }
        function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
            let i, ilen, point, controlPoints;
            if (options.spanGaps) points = points.filter((pt => !pt.skip));
            if (options.cubicInterpolationMode === "monotone") splineCurveMonotone(points, indexAxis); else {
                let prev = loop ? points[points.length - 1] : points[0];
                for (i = 0, ilen = points.length; i < ilen; ++i) {
                    point = points[i];
                    controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
                    point.cp1x = controlPoints.previous.x;
                    point.cp1y = controlPoints.previous.y;
                    point.cp2x = controlPoints.next.x;
                    point.cp2y = controlPoints.next.y;
                    prev = point;
                }
            }
            if (options.capBezierPoints) capBezierPoints(points, area);
        }
        function _isDomSupported() {
            return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function _getParentNode(domNode) {
            let parent = domNode.parentNode;
            if (parent && parent.toString() === "[object ShadowRoot]") parent = parent.host;
            return parent;
        }
        function parseMaxStyle(styleValue, node, parentProperty) {
            let valueInPixels;
            if (typeof styleValue === "string") {
                valueInPixels = parseInt(styleValue, 10);
                if (styleValue.indexOf("%") !== -1) valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            } else valueInPixels = styleValue;
            return valueInPixels;
        }
        const helpers_segment_getComputedStyle = element => element.ownerDocument.defaultView.getComputedStyle(element, null);
        function getStyle(el, property) {
            return helpers_segment_getComputedStyle(el).getPropertyValue(property);
        }
        const positions = [ "top", "right", "bottom", "left" ];
        function getPositionedStyle(styles, style, suffix) {
            const result = {};
            suffix = suffix ? "-" + suffix : "";
            for (let i = 0; i < 4; i++) {
                const pos = positions[i];
                result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
            }
            result.width = result.left + result.right;
            result.height = result.top + result.bottom;
            return result;
        }
        const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
        function getCanvasPosition(e, canvas) {
            const touches = e.touches;
            const source = touches && touches.length ? touches[0] : e;
            const {offsetX, offsetY} = source;
            let box = false;
            let x, y;
            if (useOffsetPos(offsetX, offsetY, e.target)) {
                x = offsetX;
                y = offsetY;
            } else {
                const rect = canvas.getBoundingClientRect();
                x = source.clientX - rect.left;
                y = source.clientY - rect.top;
                box = true;
            }
            return {
                x,
                y,
                box
            };
        }
        function getRelativePosition(event, chart) {
            if ("native" in event) return event;
            const {canvas, currentDevicePixelRatio} = chart;
            const style = helpers_segment_getComputedStyle(canvas);
            const borderBox = style.boxSizing === "border-box";
            const paddings = getPositionedStyle(style, "padding");
            const borders = getPositionedStyle(style, "border", "width");
            const {x, y, box} = getCanvasPosition(event, canvas);
            const xOffset = paddings.left + (box && borders.left);
            const yOffset = paddings.top + (box && borders.top);
            let {width, height} = chart;
            if (borderBox) {
                width -= paddings.width + borders.width;
                height -= paddings.height + borders.height;
            }
            return {
                x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
                y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
            };
        }
        function getContainerSize(canvas, width, height) {
            let maxWidth, maxHeight;
            if (width === void 0 || height === void 0) {
                const container = _getParentNode(canvas);
                if (!container) {
                    width = canvas.clientWidth;
                    height = canvas.clientHeight;
                } else {
                    const rect = container.getBoundingClientRect();
                    const containerStyle = helpers_segment_getComputedStyle(container);
                    const containerBorder = getPositionedStyle(containerStyle, "border", "width");
                    const containerPadding = getPositionedStyle(containerStyle, "padding");
                    width = rect.width - containerPadding.width - containerBorder.width;
                    height = rect.height - containerPadding.height - containerBorder.height;
                    maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
                    maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
                }
            }
            return {
                width,
                height,
                maxWidth: maxWidth || INFINITY,
                maxHeight: maxHeight || INFINITY
            };
        }
        const round1 = v => Math.round(v * 10) / 10;
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
            const style = helpers_segment_getComputedStyle(canvas);
            const margins = getPositionedStyle(style, "margin");
            const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
            const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
            const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
            let {width, height} = containerSize;
            if (style.boxSizing === "content-box") {
                const borders = getPositionedStyle(style, "border", "width");
                const paddings = getPositionedStyle(style, "padding");
                width -= paddings.width + borders.width;
                height -= paddings.height + borders.height;
            }
            width = Math.max(0, width - margins.width);
            height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
            width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
            height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
            if (width && !height) height = round1(width / 2);
            const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
            if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
                height = containerSize.height;
                width = round1(Math.floor(height * aspectRatio));
            }
            return {
                width,
                height
            };
        }
        function retinaScale(chart, forceRatio, forceStyle) {
            const pixelRatio = forceRatio || 1;
            const deviceHeight = Math.floor(chart.height * pixelRatio);
            const deviceWidth = Math.floor(chart.width * pixelRatio);
            chart.height = Math.floor(chart.height);
            chart.width = Math.floor(chart.width);
            const canvas = chart.canvas;
            if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
                canvas.style.height = `${chart.height}px`;
                canvas.style.width = `${chart.width}px`;
            }
            if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
                chart.currentDevicePixelRatio = pixelRatio;
                canvas.height = deviceHeight;
                canvas.width = deviceWidth;
                chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                return true;
            }
            return false;
        }
        const supportsEventListenerOptions = function() {
            let passiveSupported = false;
            try {
                const options = {
                    get passive() {
                        passiveSupported = true;
                        return false;
                    }
                };
                window.addEventListener("test", null, options);
                window.removeEventListener("test", null, options);
            } catch (e) {}
            return passiveSupported;
        }();
        function readUsedSize(element, property) {
            const value = getStyle(element, property);
            const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
            return matches ? +matches[1] : void 0;
        }
        function _pointInLine(p1, p2, t, mode) {
            return {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y)
            };
        }
        function _steppedInterpolation(p1, p2, t, mode) {
            return {
                x: p1.x + t * (p2.x - p1.x),
                y: mode === "middle" ? t < .5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
            };
        }
        function _bezierInterpolation(p1, p2, t, mode) {
            const cp1 = {
                x: p1.cp2x,
                y: p1.cp2y
            };
            const cp2 = {
                x: p2.cp1x,
                y: p2.cp1y
            };
            const a = _pointInLine(p1, cp1, t);
            const b = _pointInLine(cp1, cp2, t);
            const c = _pointInLine(cp2, p2, t);
            const d = _pointInLine(a, b, t);
            const e = _pointInLine(b, c, t);
            return _pointInLine(d, e, t);
        }
        const getRightToLeftAdapter = function(rectX, width) {
            return {
                x(x) {
                    return rectX + rectX + width - x;
                },
                setWidth(w) {
                    width = w;
                },
                textAlign(align) {
                    if (align === "center") return align;
                    return align === "right" ? "left" : "right";
                },
                xPlus(x, value) {
                    return x - value;
                },
                leftForLtr(x, itemWidth) {
                    return x - itemWidth;
                }
            };
        };
        const getLeftToRightAdapter = function() {
            return {
                x(x) {
                    return x;
                },
                setWidth(w) {},
                textAlign(align) {
                    return align;
                },
                xPlus(x, value) {
                    return x + value;
                },
                leftForLtr(x, _itemWidth) {
                    return x;
                }
            };
        };
        function getRtlAdapter(rtl, rectX, width) {
            return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
            let style, original;
            if (direction === "ltr" || direction === "rtl") {
                style = ctx.canvas.style;
                original = [ style.getPropertyValue("direction"), style.getPropertyPriority("direction") ];
                style.setProperty("direction", direction, "important");
                ctx.prevTextDirection = original;
            }
        }
        function restoreTextDirection(ctx, original) {
            if (original !== void 0) {
                delete ctx.prevTextDirection;
                ctx.canvas.style.setProperty("direction", original[0], original[1]);
            }
        }
        function propertyFn(property) {
            if (property === "angle") return {
                between: _angleBetween,
                compare: _angleDiff,
                normalize: _normalizeAngle
            };
            return {
                between: _isBetween,
                compare: (a, b) => a - b,
                normalize: x => x
            };
        }
        function normalizeSegment({start, end, count, loop, style}) {
            return {
                start: start % count,
                end: end % count,
                loop: loop && (end - start + 1) % count === 0,
                style
            };
        }
        function getSegment(segment, points, bounds) {
            const {property, start: startBound, end: endBound} = bounds;
            const {between, normalize} = propertyFn(property);
            const count = points.length;
            let {start, end, loop} = segment;
            let i, ilen;
            if (loop) {
                start += count;
                end += count;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    if (!between(normalize(points[start % count][property]), startBound, endBound)) break;
                    start--;
                    end--;
                }
                start %= count;
                end %= count;
            }
            if (end < start) end += count;
            return {
                start,
                end,
                loop,
                style: segment.style
            };
        }
        function _boundSegment(segment, points, bounds) {
            if (!bounds) return [ segment ];
            const {property, start: startBound, end: endBound} = bounds;
            const count = points.length;
            const {compare, between, normalize} = propertyFn(property);
            const {start, end, loop, style} = getSegment(segment, points, bounds);
            const result = [];
            let inside = false;
            let subStart = null;
            let value, point, prevValue;
            const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
            const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
            const shouldStart = () => inside || startIsBefore();
            const shouldStop = () => !inside || endIsBefore();
            for (let i = start, prev = start; i <= end; ++i) {
                point = points[i % count];
                if (point.skip) continue;
                value = normalize(point[property]);
                if (value === prevValue) continue;
                inside = between(value, startBound, endBound);
                if (subStart === null && shouldStart()) subStart = compare(value, startBound) === 0 ? i : prev;
                if (subStart !== null && shouldStop()) {
                    result.push(normalizeSegment({
                        start: subStart,
                        end: i,
                        loop,
                        count,
                        style
                    }));
                    subStart = null;
                }
                prev = i;
                prevValue = value;
            }
            if (subStart !== null) result.push(normalizeSegment({
                start: subStart,
                end,
                loop,
                count,
                style
            }));
            return result;
        }
        function _boundSegments(line, bounds) {
            const result = [];
            const segments = line.segments;
            for (let i = 0; i < segments.length; i++) {
                const sub = _boundSegment(segments[i], line.points, bounds);
                if (sub.length) result.push(...sub);
            }
            return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
            let start = 0;
            let end = count - 1;
            if (loop && !spanGaps) while (start < count && !points[start].skip) start++;
            while (start < count && points[start].skip) start++;
            start %= count;
            if (loop) end += start;
            while (end > start && points[end % count].skip) end--;
            end %= count;
            return {
                start,
                end
            };
        }
        function solidSegments(points, start, max, loop) {
            const count = points.length;
            const result = [];
            let last = start;
            let prev = points[start];
            let end;
            for (end = start + 1; end <= max; ++end) {
                const cur = points[end % count];
                if (cur.skip || cur.stop) {
                    if (!prev.skip) {
                        loop = false;
                        result.push({
                            start: start % count,
                            end: (end - 1) % count,
                            loop
                        });
                        start = last = cur.stop ? end : null;
                    }
                } else {
                    last = end;
                    if (prev.skip) start = end;
                }
                prev = cur;
            }
            if (last !== null) result.push({
                start: start % count,
                end: last % count,
                loop
            });
            return result;
        }
        function _computeSegments(line, segmentOptions) {
            const points = line.points;
            const spanGaps = line.options.spanGaps;
            const count = points.length;
            if (!count) return [];
            const loop = !!line._loop;
            const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
            if (spanGaps === true) return splitByStyles(line, [ {
                start,
                end,
                loop
            } ], points, segmentOptions);
            const max = end < start ? end + count : end;
            const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
            return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
        }
        function splitByStyles(line, segments, points, segmentOptions) {
            if (!segmentOptions || !segmentOptions.setContext || !points) return segments;
            return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
            const chartContext = line._chart.getContext();
            const baseStyle = readStyle(line.options);
            const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;
            const count = points.length;
            const result = [];
            let prevStyle = baseStyle;
            let start = segments[0].start;
            let i = start;
            function addStyle(s, e, l, st) {
                const dir = spanGaps ? -1 : 1;
                if (s === e) return;
                s += count;
                while (points[s % count].skip) s -= dir;
                while (points[e % count].skip) e += dir;
                if (s % count !== e % count) {
                    result.push({
                        start: s % count,
                        end: e % count,
                        loop: l,
                        style: st
                    });
                    prevStyle = st;
                    start = e % count;
                }
            }
            for (const segment of segments) {
                start = spanGaps ? start : segment.start;
                let prev = points[start % count];
                let style;
                for (i = start + 1; i <= segment.end; i++) {
                    const pt = points[i % count];
                    style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                        type: "segment",
                        p0: prev,
                        p1: pt,
                        p0DataIndex: (i - 1) % count,
                        p1DataIndex: i % count,
                        datasetIndex
                    })));
                    if (styleChanged(style, prevStyle)) addStyle(start, i - 1, segment.loop, prevStyle);
                    prev = pt;
                    prevStyle = style;
                }
                if (start < i - 1) addStyle(start, i - 1, segment.loop, prevStyle);
            }
            return result;
        }
        function readStyle(options) {
            return {
                backgroundColor: options.backgroundColor,
                borderCapStyle: options.borderCapStyle,
                borderDash: options.borderDash,
                borderDashOffset: options.borderDashOffset,
                borderJoinStyle: options.borderJoinStyle,
                borderWidth: options.borderWidth,
                borderColor: options.borderColor
            };
        }
        function styleChanged(style, prevStyle) {
            if (!prevStyle) return false;
            const cache = [];
            const replacer = function(key, value) {
                if (!isPatternOrGradient(value)) return value;
                if (!cache.includes(value)) cache.push(value);
                return cache.indexOf(value);
            };
            return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
        }
        /*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
        class Animator {
            constructor() {
                this._request = null;
                this._charts = new Map;
                this._running = false;
                this._lastDate = void 0;
            }
            _notify(chart, anims, date, type) {
                const callbacks = anims.listeners[type];
                const numSteps = anims.duration;
                callbacks.forEach((fn => fn({
                    chart,
                    initial: anims.initial,
                    numSteps,
                    currentStep: Math.min(date - anims.start, numSteps)
                })));
            }
            _refresh() {
                if (this._request) return;
                this._running = true;
                this._request = requestAnimFrame.call(window, (() => {
                    this._update();
                    this._request = null;
                    if (this._running) this._refresh();
                }));
            }
            _update(date = Date.now()) {
                let remaining = 0;
                this._charts.forEach(((anims, chart) => {
                    if (!anims.running || !anims.items.length) return;
                    const items = anims.items;
                    let i = items.length - 1;
                    let draw = false;
                    let item;
                    for (;i >= 0; --i) {
                        item = items[i];
                        if (item._active) {
                            if (item._total > anims.duration) anims.duration = item._total;
                            item.tick(date);
                            draw = true;
                        } else {
                            items[i] = items[items.length - 1];
                            items.pop();
                        }
                    }
                    if (draw) {
                        chart.draw();
                        this._notify(chart, anims, date, "progress");
                    }
                    if (!items.length) {
                        anims.running = false;
                        this._notify(chart, anims, date, "complete");
                        anims.initial = false;
                    }
                    remaining += items.length;
                }));
                this._lastDate = date;
                if (remaining === 0) this._running = false;
            }
            _getAnims(chart) {
                const charts = this._charts;
                let anims = charts.get(chart);
                if (!anims) {
                    anims = {
                        running: false,
                        initial: true,
                        items: [],
                        listeners: {
                            complete: [],
                            progress: []
                        }
                    };
                    charts.set(chart, anims);
                }
                return anims;
            }
            listen(chart, event, cb) {
                this._getAnims(chart).listeners[event].push(cb);
            }
            add(chart, items) {
                if (!items || !items.length) return;
                this._getAnims(chart).items.push(...items);
            }
            has(chart) {
                return this._getAnims(chart).items.length > 0;
            }
            start(chart) {
                const anims = this._charts.get(chart);
                if (!anims) return;
                anims.running = true;
                anims.start = Date.now();
                anims.duration = anims.items.reduce(((acc, cur) => Math.max(acc, cur._duration)), 0);
                this._refresh();
            }
            running(chart) {
                if (!this._running) return false;
                const anims = this._charts.get(chart);
                if (!anims || !anims.running || !anims.items.length) return false;
                return true;
            }
            stop(chart) {
                const anims = this._charts.get(chart);
                if (!anims || !anims.items.length) return;
                const items = anims.items;
                let i = items.length - 1;
                for (;i >= 0; --i) items[i].cancel();
                anims.items = [];
                this._notify(chart, anims, Date.now(), "complete");
            }
            remove(chart) {
                return this._charts.delete(chart);
            }
        }
        var animator = new Animator;
        const transparent = "transparent";
        const interpolators = {
            boolean(from, to, factor) {
                return factor > .5 ? to : from;
            },
            color(from, to, factor) {
                const c0 = color(from || transparent);
                const c1 = c0.valid && color(to || transparent);
                return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
            },
            number(from, to, factor) {
                return from + (to - from) * factor;
            }
        };
        class Animation {
            constructor(cfg, target, prop, to) {
                const currentValue = target[prop];
                to = resolve([ cfg.to, to, currentValue, cfg.from ]);
                const from = resolve([ cfg.from, currentValue, to ]);
                this._active = true;
                this._fn = cfg.fn || interpolators[cfg.type || typeof from];
                this._easing = effects[cfg.easing] || effects.linear;
                this._start = Math.floor(Date.now() + (cfg.delay || 0));
                this._duration = this._total = Math.floor(cfg.duration);
                this._loop = !!cfg.loop;
                this._target = target;
                this._prop = prop;
                this._from = from;
                this._to = to;
                this._promises = void 0;
            }
            active() {
                return this._active;
            }
            update(cfg, to, date) {
                if (this._active) {
                    this._notify(false);
                    const currentValue = this._target[this._prop];
                    const elapsed = date - this._start;
                    const remain = this._duration - elapsed;
                    this._start = date;
                    this._duration = Math.floor(Math.max(remain, cfg.duration));
                    this._total += elapsed;
                    this._loop = !!cfg.loop;
                    this._to = resolve([ cfg.to, to, currentValue, cfg.from ]);
                    this._from = resolve([ cfg.from, currentValue, to ]);
                }
            }
            cancel() {
                if (this._active) {
                    this.tick(Date.now());
                    this._active = false;
                    this._notify(false);
                }
            }
            tick(date) {
                const elapsed = date - this._start;
                const duration = this._duration;
                const prop = this._prop;
                const from = this._from;
                const loop = this._loop;
                const to = this._to;
                let factor;
                this._active = from !== to && (loop || elapsed < duration);
                if (!this._active) {
                    this._target[prop] = to;
                    this._notify(true);
                    return;
                }
                if (elapsed < 0) {
                    this._target[prop] = from;
                    return;
                }
                factor = elapsed / duration % 2;
                factor = loop && factor > 1 ? 2 - factor : factor;
                factor = this._easing(Math.min(1, Math.max(0, factor)));
                this._target[prop] = this._fn(from, to, factor);
            }
            wait() {
                const promises = this._promises || (this._promises = []);
                return new Promise(((res, rej) => {
                    promises.push({
                        res,
                        rej
                    });
                }));
            }
            _notify(resolved) {
                const method = resolved ? "res" : "rej";
                const promises = this._promises || [];
                for (let i = 0; i < promises.length; i++) promises[i][method]();
            }
        }
        class Animations {
            constructor(chart, config) {
                this._chart = chart;
                this._properties = new Map;
                this.configure(config);
            }
            configure(config) {
                if (!helpers_segment_isObject(config)) return;
                const animationOptions = Object.keys(helpers_segment_defaults.animation);
                const animatedProps = this._properties;
                Object.getOwnPropertyNames(config).forEach((key => {
                    const cfg = config[key];
                    if (!helpers_segment_isObject(cfg)) return;
                    const resolved = {};
                    for (const option of animationOptions) resolved[option] = cfg[option];
                    (isArray(cfg.properties) && cfg.properties || [ key ]).forEach((prop => {
                        if (prop === key || !animatedProps.has(prop)) animatedProps.set(prop, resolved);
                    }));
                }));
            }
            _animateOptions(target, values) {
                const newOptions = values.options;
                const options = resolveTargetOptions(target, newOptions);
                if (!options) return [];
                const animations = this._createAnimations(options, newOptions);
                if (newOptions.$shared) awaitAll(target.options.$animations, newOptions).then((() => {
                    target.options = newOptions;
                }), (() => {}));
                return animations;
            }
            _createAnimations(target, values) {
                const animatedProps = this._properties;
                const animations = [];
                const running = target.$animations || (target.$animations = {});
                const props = Object.keys(values);
                const date = Date.now();
                let i;
                for (i = props.length - 1; i >= 0; --i) {
                    const prop = props[i];
                    if (prop.charAt(0) === "$") continue;
                    if (prop === "options") {
                        animations.push(...this._animateOptions(target, values));
                        continue;
                    }
                    const value = values[prop];
                    let animation = running[prop];
                    const cfg = animatedProps.get(prop);
                    if (animation) if (cfg && animation.active()) {
                        animation.update(cfg, value, date);
                        continue;
                    } else animation.cancel();
                    if (!cfg || !cfg.duration) {
                        target[prop] = value;
                        continue;
                    }
                    running[prop] = animation = new Animation(cfg, target, prop, value);
                    animations.push(animation);
                }
                return animations;
            }
            update(target, values) {
                if (this._properties.size === 0) {
                    Object.assign(target, values);
                    return;
                }
                const animations = this._createAnimations(target, values);
                if (animations.length) {
                    animator.add(this._chart, animations);
                    return true;
                }
            }
        }
        function awaitAll(animations, properties) {
            const running = [];
            const keys = Object.keys(properties);
            for (let i = 0; i < keys.length; i++) {
                const anim = animations[keys[i]];
                if (anim && anim.active()) running.push(anim.wait());
            }
            return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
            if (!newOptions) return;
            let options = target.options;
            if (!options) {
                target.options = newOptions;
                return;
            }
            if (options.$shared) target.options = options = Object.assign({}, options, {
                $shared: false,
                $animations: {}
            });
            return options;
        }
        function scaleClip(scale, allowedOverflow) {
            const opts = scale && scale.options || {};
            const reverse = opts.reverse;
            const min = opts.min === void 0 ? allowedOverflow : 0;
            const max = opts.max === void 0 ? allowedOverflow : 0;
            return {
                start: reverse ? max : min,
                end: reverse ? min : max
            };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
            if (allowedOverflow === false) return false;
            const x = scaleClip(xScale, allowedOverflow);
            const y = scaleClip(yScale, allowedOverflow);
            return {
                top: y.end,
                right: x.end,
                bottom: y.start,
                left: x.start
            };
        }
        function toClip(value) {
            let t, r, b, l;
            if (helpers_segment_isObject(value)) {
                t = value.top;
                r = value.right;
                b = value.bottom;
                l = value.left;
            } else t = r = b = l = value;
            return {
                top: t,
                right: r,
                bottom: b,
                left: l,
                disabled: value === false
            };
        }
        function getSortedDatasetIndices(chart, filterVisible) {
            const keys = [];
            const metasets = chart._getSortedDatasetMetas(filterVisible);
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) keys.push(metasets[i].index);
            return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
            const keys = stack.keys;
            const singleMode = options.mode === "single";
            let i, ilen, datasetIndex, otherValue;
            if (value === null) return;
            for (i = 0, ilen = keys.length; i < ilen; ++i) {
                datasetIndex = +keys[i];
                if (datasetIndex === dsIndex) {
                    if (options.all) continue;
                    break;
                }
                otherValue = stack.values[datasetIndex];
                if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) value += otherValue;
            }
            return value;
        }
        function convertObjectDataToArray(data) {
            const keys = Object.keys(data);
            const adata = new Array(keys.length);
            let i, ilen, key;
            for (i = 0, ilen = keys.length; i < ilen; ++i) {
                key = keys[i];
                adata[i] = {
                    x: key,
                    y: data[key]
                };
            }
            return adata;
        }
        function isStacked(scale, meta) {
            const stacked = scale && scale.options.stacked;
            return stacked || stacked === void 0 && meta.stack !== void 0;
        }
        function getStackKey(indexScale, valueScale, meta) {
            return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
            const {min, max, minDefined, maxDefined} = scale.getUserBounds();
            return {
                min: minDefined ? min : Number.NEGATIVE_INFINITY,
                max: maxDefined ? max : Number.POSITIVE_INFINITY
            };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
            const subStack = stacks[stackKey] || (stacks[stackKey] = {});
            return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
            for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
                const value = stack[meta.index];
                if (positive && value > 0 || !positive && value < 0) return meta.index;
            }
            return null;
        }
        function updateStacks(controller, parsed) {
            const {chart, _cachedMeta: meta} = controller;
            const stacks = chart._stacks || (chart._stacks = {});
            const {iScale, vScale, index: datasetIndex} = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const key = getStackKey(iScale, vScale, meta);
            const ilen = parsed.length;
            let stack;
            for (let i = 0; i < ilen; ++i) {
                const item = parsed[i];
                const {[iAxis]: index, [vAxis]: value} = item;
                const itemStacks = item._stacks || (item._stacks = {});
                stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
                stack[datasetIndex] = value;
                stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
                stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
                const visualValues = stack._visualValues || (stack._visualValues = {});
                visualValues[datasetIndex] = value;
            }
        }
        function getFirstScaleId(chart, axis) {
            const scales = chart.scales;
            return Object.keys(scales).filter((key => scales[key].axis === axis)).shift();
        }
        function createDatasetContext(parent, index) {
            return createContext(parent, {
                active: false,
                dataset: void 0,
                datasetIndex: index,
                index,
                mode: "default",
                type: "dataset"
            });
        }
        function createDataContext(parent, index, element) {
            return createContext(parent, {
                active: false,
                dataIndex: index,
                parsed: void 0,
                raw: void 0,
                element,
                index,
                mode: "default",
                type: "data"
            });
        }
        function clearStacks(meta, items) {
            const datasetIndex = meta.controller.index;
            const axis = meta.vScale && meta.vScale.axis;
            if (!axis) return;
            items = items || meta._parsed;
            for (const parsed of items) {
                const stacks = parsed._stacks;
                if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) return;
                delete stacks[axis][datasetIndex];
                if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) delete stacks[axis]._visualValues[datasetIndex];
            }
        }
        const isDirectUpdateMode = mode => mode === "reset" || mode === "none";
        const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
            keys: getSortedDatasetIndices(chart, true),
            values: null
        };
        class DatasetController {
            static defaults={};
            static datasetElementType=null;
            static dataElementType=null;
            constructor(chart, datasetIndex) {
                this.chart = chart;
                this._ctx = chart.ctx;
                this.index = datasetIndex;
                this._cachedDataOpts = {};
                this._cachedMeta = this.getMeta();
                this._type = this._cachedMeta.type;
                this.options = void 0;
                this._parsing = false;
                this._data = void 0;
                this._objectData = void 0;
                this._sharedOptions = void 0;
                this._drawStart = void 0;
                this._drawCount = void 0;
                this.enableOptionSharing = false;
                this.supportsDecimation = false;
                this.$context = void 0;
                this._syncList = [];
                this.datasetElementType = new.target.datasetElementType;
                this.dataElementType = new.target.dataElementType;
                this.initialize();
            }
            initialize() {
                const meta = this._cachedMeta;
                this.configure();
                this.linkScales();
                meta._stacked = isStacked(meta.vScale, meta);
                this.addElements();
                if (this.options.fill && !this.chart.isPluginEnabled("filler")) console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
            }
            updateIndex(datasetIndex) {
                if (this.index !== datasetIndex) clearStacks(this._cachedMeta);
                this.index = datasetIndex;
            }
            linkScales() {
                const chart = this.chart;
                const meta = this._cachedMeta;
                const dataset = this.getDataset();
                const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
                const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
                const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
                const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
                const indexAxis = meta.indexAxis;
                const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
                const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
                meta.xScale = this.getScaleForId(xid);
                meta.yScale = this.getScaleForId(yid);
                meta.rScale = this.getScaleForId(rid);
                meta.iScale = this.getScaleForId(iid);
                meta.vScale = this.getScaleForId(vid);
            }
            getDataset() {
                return this.chart.data.datasets[this.index];
            }
            getMeta() {
                return this.chart.getDatasetMeta(this.index);
            }
            getScaleForId(scaleID) {
                return this.chart.scales[scaleID];
            }
            _getOtherScale(scale) {
                const meta = this._cachedMeta;
                return scale === meta.iScale ? meta.vScale : meta.iScale;
            }
            reset() {
                this._update("reset");
            }
            _destroy() {
                const meta = this._cachedMeta;
                if (this._data) unlistenArrayEvents(this._data, this);
                if (meta._stacked) clearStacks(meta);
            }
            _dataCheck() {
                const dataset = this.getDataset();
                const data = dataset.data || (dataset.data = []);
                const _data = this._data;
                if (helpers_segment_isObject(data)) this._data = convertObjectDataToArray(data); else if (_data !== data) {
                    if (_data) {
                        unlistenArrayEvents(_data, this);
                        const meta = this._cachedMeta;
                        clearStacks(meta);
                        meta._parsed = [];
                    }
                    if (data && Object.isExtensible(data)) listenArrayEvents(data, this);
                    this._syncList = [];
                    this._data = data;
                }
            }
            addElements() {
                const meta = this._cachedMeta;
                this._dataCheck();
                if (this.datasetElementType) meta.dataset = new this.datasetElementType;
            }
            buildOrUpdateElements(resetNewElements) {
                const meta = this._cachedMeta;
                const dataset = this.getDataset();
                let stackChanged = false;
                this._dataCheck();
                const oldStacked = meta._stacked;
                meta._stacked = isStacked(meta.vScale, meta);
                if (meta.stack !== dataset.stack) {
                    stackChanged = true;
                    clearStacks(meta);
                    meta.stack = dataset.stack;
                }
                this._resyncElements(resetNewElements);
                if (stackChanged || oldStacked !== meta._stacked) updateStacks(this, meta._parsed);
            }
            configure() {
                const config = this.chart.config;
                const scopeKeys = config.datasetScopeKeys(this._type);
                const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
                this.options = config.createResolver(scopes, this.getContext());
                this._parsing = this.options.parsing;
                this._cachedDataOpts = {};
            }
            parse(start, count) {
                const {_cachedMeta: meta, _data: data} = this;
                const {iScale, _stacked} = meta;
                const iAxis = iScale.axis;
                let sorted = start === 0 && count === data.length ? true : meta._sorted;
                let prev = start > 0 && meta._parsed[start - 1];
                let i, cur, parsed;
                if (this._parsing === false) {
                    meta._parsed = data;
                    meta._sorted = true;
                    parsed = data;
                } else {
                    if (isArray(data[start])) parsed = this.parseArrayData(meta, data, start, count); else if (helpers_segment_isObject(data[start])) parsed = this.parseObjectData(meta, data, start, count); else parsed = this.parsePrimitiveData(meta, data, start, count);
                    const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
                    for (i = 0; i < count; ++i) {
                        meta._parsed[i + start] = cur = parsed[i];
                        if (sorted) {
                            if (isNotInOrderComparedToPrev()) sorted = false;
                            prev = cur;
                        }
                    }
                    meta._sorted = sorted;
                }
                if (_stacked) updateStacks(this, parsed);
            }
            parsePrimitiveData(meta, data, start, count) {
                const {iScale, vScale} = meta;
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                const labels = iScale.getLabels();
                const singleScale = iScale === vScale;
                const parsed = new Array(count);
                let i, ilen, index;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    index = i + start;
                    parsed[i] = {
                        [iAxis]: singleScale || iScale.parse(labels[index], index),
                        [vAxis]: vScale.parse(data[index], index)
                    };
                }
                return parsed;
            }
            parseArrayData(meta, data, start, count) {
                const {xScale, yScale} = meta;
                const parsed = new Array(count);
                let i, ilen, index, item;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    index = i + start;
                    item = data[index];
                    parsed[i] = {
                        x: xScale.parse(item[0], index),
                        y: yScale.parse(item[1], index)
                    };
                }
                return parsed;
            }
            parseObjectData(meta, data, start, count) {
                const {xScale, yScale} = meta;
                const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
                const parsed = new Array(count);
                let i, ilen, index, item;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    index = i + start;
                    item = data[index];
                    parsed[i] = {
                        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
                    };
                }
                return parsed;
            }
            getParsed(index) {
                return this._cachedMeta._parsed[index];
            }
            getDataElement(index) {
                return this._cachedMeta.data[index];
            }
            applyStack(scale, parsed, mode) {
                const chart = this.chart;
                const meta = this._cachedMeta;
                const value = parsed[scale.axis];
                const stack = {
                    keys: getSortedDatasetIndices(chart, true),
                    values: parsed._stacks[scale.axis]._visualValues
                };
                return applyStack(stack, value, meta.index, {
                    mode
                });
            }
            updateRangeFromParsed(range, scale, parsed, stack) {
                const parsedValue = parsed[scale.axis];
                let value = parsedValue === null ? NaN : parsedValue;
                const values = stack && parsed._stacks[scale.axis];
                if (stack && values) {
                    stack.values = values;
                    value = applyStack(stack, parsedValue, this._cachedMeta.index);
                }
                range.min = Math.min(range.min, value);
                range.max = Math.max(range.max, value);
            }
            getMinMax(scale, canStack) {
                const meta = this._cachedMeta;
                const _parsed = meta._parsed;
                const sorted = meta._sorted && scale === meta.iScale;
                const ilen = _parsed.length;
                const otherScale = this._getOtherScale(scale);
                const stack = createStack(canStack, meta, this.chart);
                const range = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                };
                const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
                let i, parsed;
                function _skip() {
                    parsed = _parsed[i];
                    const otherValue = parsed[otherScale.axis];
                    return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
                }
                for (i = 0; i < ilen; ++i) {
                    if (_skip()) continue;
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    if (sorted) break;
                }
                if (sorted) for (i = ilen - 1; i >= 0; --i) {
                    if (_skip()) continue;
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    break;
                }
                return range;
            }
            getAllParsedValues(scale) {
                const parsed = this._cachedMeta._parsed;
                const values = [];
                let i, ilen, value;
                for (i = 0, ilen = parsed.length; i < ilen; ++i) {
                    value = parsed[i][scale.axis];
                    if (isNumberFinite(value)) values.push(value);
                }
                return values;
            }
            getMaxOverflow() {
                return false;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const iScale = meta.iScale;
                const vScale = meta.vScale;
                const parsed = this.getParsed(index);
                return {
                    label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
                    value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
                };
            }
            _update(mode) {
                const meta = this._cachedMeta;
                this.update(mode || "default");
                meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
            }
            update(mode) {}
            draw() {
                const ctx = this._ctx;
                const chart = this.chart;
                const meta = this._cachedMeta;
                const elements = meta.data || [];
                const area = chart.chartArea;
                const active = [];
                const start = this._drawStart || 0;
                const count = this._drawCount || elements.length - start;
                const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
                let i;
                if (meta.dataset) meta.dataset.draw(ctx, area, start, count);
                for (i = start; i < start + count; ++i) {
                    const element = elements[i];
                    if (element.hidden) continue;
                    if (element.active && drawActiveElementsOnTop) active.push(element); else element.draw(ctx, area);
                }
                for (i = 0; i < active.length; ++i) active[i].draw(ctx, area);
            }
            getStyle(index, active) {
                const mode = active ? "active" : "default";
                return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
            }
            getContext(index, active, mode) {
                const dataset = this.getDataset();
                let context;
                if (index >= 0 && index < this._cachedMeta.data.length) {
                    const element = this._cachedMeta.data[index];
                    context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
                    context.parsed = this.getParsed(index);
                    context.raw = dataset.data[index];
                    context.index = context.dataIndex = index;
                } else {
                    context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
                    context.dataset = dataset;
                    context.index = context.datasetIndex = this.index;
                }
                context.active = !!active;
                context.mode = mode;
                return context;
            }
            resolveDatasetElementOptions(mode) {
                return this._resolveElementOptions(this.datasetElementType.id, mode);
            }
            resolveDataElementOptions(index, mode) {
                return this._resolveElementOptions(this.dataElementType.id, mode, index);
            }
            _resolveElementOptions(elementType, mode = "default", index) {
                const active = mode === "active";
                const cache = this._cachedDataOpts;
                const cacheKey = elementType + "-" + mode;
                const cached = cache[cacheKey];
                const sharing = this.enableOptionSharing && defined(index);
                if (cached) return cloneIfNotShared(cached, sharing);
                const config = this.chart.config;
                const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
                const prefixes = active ? [ `${elementType}Hover`, "hover", elementType, "" ] : [ elementType, "" ];
                const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                const names = Object.keys(helpers_segment_defaults.elements[elementType]);
                const context = () => this.getContext(index, active, mode);
                const values = config.resolveNamedOptions(scopes, names, context, prefixes);
                if (values.$shared) {
                    values.$shared = sharing;
                    cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
                }
                return values;
            }
            _resolveAnimations(index, transition, active) {
                const chart = this.chart;
                const cache = this._cachedDataOpts;
                const cacheKey = `animation-${transition}`;
                const cached = cache[cacheKey];
                if (cached) return cached;
                let options;
                if (chart.options.animation !== false) {
                    const config = this.chart.config;
                    const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
                    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                    options = config.createResolver(scopes, this.getContext(index, active, transition));
                }
                const animations = new Animations(chart, options && options.animations);
                if (options && options._cacheable) cache[cacheKey] = Object.freeze(animations);
                return animations;
            }
            getSharedOptions(options) {
                if (!options.$shared) return;
                return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
            }
            includeOptions(mode, sharedOptions) {
                return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
            }
            _getSharedOptions(start, mode) {
                const firstOpts = this.resolveDataElementOptions(start, mode);
                const previouslySharedOptions = this._sharedOptions;
                const sharedOptions = this.getSharedOptions(firstOpts);
                const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
                this.updateSharedOptions(sharedOptions, mode, firstOpts);
                return {
                    sharedOptions,
                    includeOptions
                };
            }
            updateElement(element, index, properties, mode) {
                if (isDirectUpdateMode(mode)) Object.assign(element, properties); else this._resolveAnimations(index, mode).update(element, properties);
            }
            updateSharedOptions(sharedOptions, mode, newOptions) {
                if (sharedOptions && !isDirectUpdateMode(mode)) this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
            }
            _setStyle(element, index, mode, active) {
                element.active = active;
                const options = this.getStyle(index, active);
                this._resolveAnimations(index, mode, active).update(element, {
                    options: !active && this.getSharedOptions(options) || options
                });
            }
            removeHoverStyle(element, datasetIndex, index) {
                this._setStyle(element, index, "active", false);
            }
            setHoverStyle(element, datasetIndex, index) {
                this._setStyle(element, index, "active", true);
            }
            _removeDatasetHoverStyle() {
                const element = this._cachedMeta.dataset;
                if (element) this._setStyle(element, void 0, "active", false);
            }
            _setDatasetHoverStyle() {
                const element = this._cachedMeta.dataset;
                if (element) this._setStyle(element, void 0, "active", true);
            }
            _resyncElements(resetNewElements) {
                const data = this._data;
                const elements = this._cachedMeta.data;
                for (const [method, arg1, arg2] of this._syncList) this[method](arg1, arg2);
                this._syncList = [];
                const numMeta = elements.length;
                const numData = data.length;
                const count = Math.min(numData, numMeta);
                if (count) this.parse(0, count);
                if (numData > numMeta) this._insertElements(numMeta, numData - numMeta, resetNewElements); else if (numData < numMeta) this._removeElements(numData, numMeta - numData);
            }
            _insertElements(start, count, resetNewElements = true) {
                const meta = this._cachedMeta;
                const data = meta.data;
                const end = start + count;
                let i;
                const move = arr => {
                    arr.length += count;
                    for (i = arr.length - 1; i >= end; i--) arr[i] = arr[i - count];
                };
                move(data);
                for (i = start; i < end; ++i) data[i] = new this.dataElementType;
                if (this._parsing) move(meta._parsed);
                this.parse(start, count);
                if (resetNewElements) this.updateElements(data, start, count, "reset");
            }
            updateElements(element, start, count, mode) {}
            _removeElements(start, count) {
                const meta = this._cachedMeta;
                if (this._parsing) {
                    const removed = meta._parsed.splice(start, count);
                    if (meta._stacked) clearStacks(meta, removed);
                }
                meta.data.splice(start, count);
            }
            _sync(args) {
                if (this._parsing) this._syncList.push(args); else {
                    const [method, arg1, arg2] = args;
                    this[method](arg1, arg2);
                }
                this.chart._dataChanges.push([ this.index, ...args ]);
            }
            _onDataPush() {
                const count = arguments.length;
                this._sync([ "_insertElements", this.getDataset().data.length - count, count ]);
            }
            _onDataPop() {
                this._sync([ "_removeElements", this._cachedMeta.data.length - 1, 1 ]);
            }
            _onDataShift() {
                this._sync([ "_removeElements", 0, 1 ]);
            }
            _onDataSplice(start, count) {
                if (count) this._sync([ "_removeElements", start, count ]);
                const newCount = arguments.length - 2;
                if (newCount) this._sync([ "_insertElements", start, newCount ]);
            }
            _onDataUnshift() {
                this._sync([ "_insertElements", 0, arguments.length ]);
            }
        }
        function getAllScaleValues(scale, type) {
            if (!scale._cache.$bar) {
                const visibleMetas = scale.getMatchingVisibleMetas(type);
                let values = [];
                for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
                scale._cache.$bar = _arrayUnique(values.sort(((a, b) => a - b)));
            }
            return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
            const scale = meta.iScale;
            const values = getAllScaleValues(scale, meta.type);
            let min = scale._length;
            let i, ilen, curr, prev;
            const updateMinAndPrev = () => {
                if (curr === 32767 || curr === -32768) return;
                if (defined(prev)) min = Math.min(min, Math.abs(curr - prev) || min);
                prev = curr;
            };
            for (i = 0, ilen = values.length; i < ilen; ++i) {
                curr = scale.getPixelForValue(values[i]);
                updateMinAndPrev();
            }
            prev = void 0;
            for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
                curr = scale.getPixelForTick(i);
                updateMinAndPrev();
            }
            return min;
        }
        function computeFitCategoryTraits(index, ruler, options, stackCount) {
            const thickness = options.barThickness;
            let size, ratio;
            if (isNullOrUndef(thickness)) {
                size = ruler.min * options.categoryPercentage;
                ratio = options.barPercentage;
            } else {
                size = thickness * stackCount;
                ratio = 1;
            }
            return {
                chunk: size / stackCount,
                ratio,
                start: ruler.pixels[index] - size / 2
            };
        }
        function computeFlexCategoryTraits(index, ruler, options, stackCount) {
            const pixels = ruler.pixels;
            const curr = pixels[index];
            let prev = index > 0 ? pixels[index - 1] : null;
            let next = index < pixels.length - 1 ? pixels[index + 1] : null;
            const percent = options.categoryPercentage;
            if (prev === null) prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
            if (next === null) next = curr + curr - prev;
            const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
            const size = Math.abs(next - prev) / 2 * percent;
            return {
                chunk: size / stackCount,
                ratio: options.barPercentage,
                start
            };
        }
        function parseFloatBar(entry, item, vScale, i) {
            const startValue = vScale.parse(entry[0], i);
            const endValue = vScale.parse(entry[1], i);
            const min = Math.min(startValue, endValue);
            const max = Math.max(startValue, endValue);
            let barStart = min;
            let barEnd = max;
            if (Math.abs(min) > Math.abs(max)) {
                barStart = max;
                barEnd = min;
            }
            item[vScale.axis] = barEnd;
            item._custom = {
                barStart,
                barEnd,
                start: startValue,
                end: endValue,
                min,
                max
            };
        }
        function parseValue(entry, item, vScale, i) {
            if (isArray(entry)) parseFloatBar(entry, item, vScale, i); else item[vScale.axis] = vScale.parse(entry, i);
            return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = [];
            let i, ilen, item, entry;
            for (i = start, ilen = start + count; i < ilen; ++i) {
                entry = data[i];
                item = {};
                item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
                parsed.push(parseValue(entry, item, vScale, i));
            }
            return parsed;
        }
        function isFloatBar(custom) {
            return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
        }
        function barSign(size, vScale, actualBase) {
            if (size !== 0) return sign(size);
            return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
        }
        function borderProps(properties) {
            let reverse, start, end, top, bottom;
            if (properties.horizontal) {
                reverse = properties.base > properties.x;
                start = "left";
                end = "right";
            } else {
                reverse = properties.base < properties.y;
                start = "bottom";
                end = "top";
            }
            if (reverse) {
                top = "end";
                bottom = "start";
            } else {
                top = "start";
                bottom = "end";
            }
            return {
                start,
                end,
                reverse,
                top,
                bottom
            };
        }
        function setBorderSkipped(properties, options, stack, index) {
            let edge = options.borderSkipped;
            const res = {};
            if (!edge) {
                properties.borderSkipped = res;
                return;
            }
            if (edge === true) {
                properties.borderSkipped = {
                    top: true,
                    right: true,
                    bottom: true,
                    left: true
                };
                return;
            }
            const {start, end, reverse, top, bottom} = borderProps(properties);
            if (edge === "middle" && stack) {
                properties.enableBorderRadius = true;
                if ((stack._top || 0) === index) edge = top; else if ((stack._bottom || 0) === index) edge = bottom; else {
                    res[parseEdge(bottom, start, end, reverse)] = true;
                    edge = top;
                }
            }
            res[parseEdge(edge, start, end, reverse)] = true;
            properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
            if (reverse) {
                edge = swap(edge, a, b);
                edge = startEnd(edge, b, a);
            } else edge = startEnd(edge, a, b);
            return edge;
        }
        function swap(orig, v1, v2) {
            return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
            return v === "start" ? start : v === "end" ? end : v;
        }
        function setInflateAmount(properties, {inflateAmount}, ratio) {
            properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? .33 : 0 : inflateAmount;
        }
        class BarController extends DatasetController {
            static id="bar";
            static defaults={
                datasetElementType: false,
                dataElementType: "bar",
                categoryPercentage: .8,
                barPercentage: .9,
                grouped: true,
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "base", "width", "height" ]
                    }
                }
            };
            static overrides={
                scales: {
                    _index_: {
                        type: "category",
                        offset: true,
                        grid: {
                            offset: true
                        }
                    },
                    _value_: {
                        type: "linear",
                        beginAtZero: true
                    }
                }
            };
            parsePrimitiveData(meta, data, start, count) {
                return parseArrayOrPrimitive(meta, data, start, count);
            }
            parseArrayData(meta, data, start, count) {
                return parseArrayOrPrimitive(meta, data, start, count);
            }
            parseObjectData(meta, data, start, count) {
                const {iScale, vScale} = meta;
                const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
                const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
                const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
                const parsed = [];
                let i, ilen, item, obj;
                for (i = start, ilen = start + count; i < ilen; ++i) {
                    obj = data[i];
                    item = {};
                    item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
                    parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
                }
                return parsed;
            }
            updateRangeFromParsed(range, scale, parsed, stack) {
                super.updateRangeFromParsed(range, scale, parsed, stack);
                const custom = parsed._custom;
                if (custom && scale === this._cachedMeta.vScale) {
                    range.min = Math.min(range.min, custom.min);
                    range.max = Math.max(range.max, custom.max);
                }
            }
            getMaxOverflow() {
                return 0;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const {iScale, vScale} = meta;
                const parsed = this.getParsed(index);
                const custom = parsed._custom;
                const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
                return {
                    label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
                    value
                };
            }
            initialize() {
                this.enableOptionSharing = true;
                super.initialize();
                const meta = this._cachedMeta;
                meta.stack = this.getDataset().stack;
            }
            update(mode) {
                const meta = this._cachedMeta;
                this.updateElements(meta.data, 0, meta.data.length, mode);
            }
            updateElements(bars, start, count, mode) {
                const reset = mode === "reset";
                const {index, _cachedMeta: {vScale}} = this;
                const base = vScale.getBasePixel();
                const horizontal = vScale.isHorizontal();
                const ruler = this._getRuler();
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                for (let i = start; i < start + count; i++) {
                    const parsed = this.getParsed(i);
                    const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
                        base,
                        head: base
                    } : this._calculateBarValuePixels(i);
                    const ipixels = this._calculateBarIndexPixels(i, ruler);
                    const stack = (parsed._stacks || {})[vScale.axis];
                    const properties = {
                        horizontal,
                        base: vpixels.base,
                        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                        x: horizontal ? vpixels.head : ipixels.center,
                        y: horizontal ? ipixels.center : vpixels.head,
                        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
                    };
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
                    const options = properties.options || bars[i].options;
                    setBorderSkipped(properties, options, stack, index);
                    setInflateAmount(properties, options, ruler.ratio);
                    this.updateElement(bars[i], i, properties, mode);
                }
            }
            _getStacks(last, dataIndex) {
                const {iScale} = this._cachedMeta;
                const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta => meta.controller.options.grouped));
                const stacked = iScale.options.stacked;
                const stacks = [];
                const skipNull = meta => {
                    const parsed = meta.controller.getParsed(dataIndex);
                    const val = parsed && parsed[meta.vScale.axis];
                    if (isNullOrUndef(val) || isNaN(val)) return true;
                };
                for (const meta of metasets) {
                    if (dataIndex !== void 0 && skipNull(meta)) continue;
                    if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) stacks.push(meta.stack);
                    if (meta.index === last) break;
                }
                if (!stacks.length) stacks.push(void 0);
                return stacks;
            }
            _getStackCount(index) {
                return this._getStacks(void 0, index).length;
            }
            _getStackIndex(datasetIndex, name, dataIndex) {
                const stacks = this._getStacks(datasetIndex, dataIndex);
                const index = name !== void 0 ? stacks.indexOf(name) : -1;
                return index === -1 ? stacks.length - 1 : index;
            }
            _getRuler() {
                const opts = this.options;
                const meta = this._cachedMeta;
                const iScale = meta.iScale;
                const pixels = [];
                let i, ilen;
                for (i = 0, ilen = meta.data.length; i < ilen; ++i) pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
                const barThickness = opts.barThickness;
                const min = barThickness || computeMinSampleSize(meta);
                return {
                    min,
                    pixels,
                    start: iScale._startPixel,
                    end: iScale._endPixel,
                    stackCount: this._getStackCount(),
                    scale: iScale,
                    grouped: opts.grouped,
                    ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
                };
            }
            _calculateBarValuePixels(index) {
                const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;
                const actualBase = baseValue || 0;
                const parsed = this.getParsed(index);
                const custom = parsed._custom;
                const floating = isFloatBar(custom);
                let value = parsed[vScale.axis];
                let start = 0;
                let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
                let head, size;
                if (length !== value) {
                    start = length - value;
                    length = value;
                }
                if (floating) {
                    value = custom.barStart;
                    length = custom.barEnd - custom.barStart;
                    if (value !== 0 && sign(value) !== sign(custom.barEnd)) start = 0;
                    start += value;
                }
                const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
                let base = vScale.getPixelForValue(startValue);
                if (this.chart.getDataVisibility(index)) head = vScale.getPixelForValue(start + length); else head = base;
                size = head - base;
                if (Math.abs(size) < minBarLength) {
                    size = barSign(size, vScale, actualBase) * minBarLength;
                    if (value === actualBase) base -= size / 2;
                    const startPixel = vScale.getPixelForDecimal(0);
                    const endPixel = vScale.getPixelForDecimal(1);
                    const min = Math.min(startPixel, endPixel);
                    const max = Math.max(startPixel, endPixel);
                    base = Math.max(Math.min(base, max), min);
                    head = base + size;
                    if (_stacked && !floating) parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
                }
                if (base === vScale.getPixelForValue(actualBase)) {
                    const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
                    base += halfGrid;
                    size -= halfGrid;
                }
                return {
                    size,
                    base,
                    head,
                    center: head + size / 2
                };
            }
            _calculateBarIndexPixels(index, ruler) {
                const scale = ruler.scale;
                const options = this.options;
                const skipNull = options.skipNull;
                const maxBarThickness = valueOrDefault(options.maxBarThickness, 1 / 0);
                let center, size;
                if (ruler.grouped) {
                    const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
                    const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
                    const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
                    center = range.start + range.chunk * stackIndex + range.chunk / 2;
                    size = Math.min(maxBarThickness, range.chunk * range.ratio);
                } else {
                    center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
                    size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
                }
                return {
                    base: center - size / 2,
                    head: center + size / 2,
                    center,
                    size
                };
            }
            draw() {
                const meta = this._cachedMeta;
                const vScale = meta.vScale;
                const rects = meta.data;
                const ilen = rects.length;
                let i = 0;
                for (;i < ilen; ++i) if (this.getParsed(i)[vScale.axis] !== null) rects[i].draw(this._ctx);
            }
        }
        class BubbleController extends DatasetController {
            static id="bubble";
            static defaults={
                datasetElementType: false,
                dataElementType: "point",
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "borderWidth", "radius" ]
                    }
                }
            };
            static overrides={
                scales: {
                    x: {
                        type: "linear"
                    },
                    y: {
                        type: "linear"
                    }
                }
            };
            initialize() {
                this.enableOptionSharing = true;
                super.initialize();
            }
            parsePrimitiveData(meta, data, start, count) {
                const parsed = super.parsePrimitiveData(meta, data, start, count);
                for (let i = 0; i < parsed.length; i++) parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
                return parsed;
            }
            parseArrayData(meta, data, start, count) {
                const parsed = super.parseArrayData(meta, data, start, count);
                for (let i = 0; i < parsed.length; i++) {
                    const item = data[start + i];
                    parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
                }
                return parsed;
            }
            parseObjectData(meta, data, start, count) {
                const parsed = super.parseObjectData(meta, data, start, count);
                for (let i = 0; i < parsed.length; i++) {
                    const item = data[start + i];
                    parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
                }
                return parsed;
            }
            getMaxOverflow() {
                const data = this._cachedMeta.data;
                let max = 0;
                for (let i = data.length - 1; i >= 0; --i) max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
                return max > 0 && max;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const labels = this.chart.data.labels || [];
                const {xScale, yScale} = meta;
                const parsed = this.getParsed(index);
                const x = xScale.getLabelForValue(parsed.x);
                const y = yScale.getLabelForValue(parsed.y);
                const r = parsed._custom;
                return {
                    label: labels[index] || "",
                    value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
                };
            }
            update(mode) {
                const points = this._cachedMeta.data;
                this.updateElements(points, 0, points.length, mode);
            }
            updateElements(points, start, count, mode) {
                const reset = mode === "reset";
                const {iScale, vScale} = this._cachedMeta;
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                for (let i = start; i < start + count; i++) {
                    const point = points[i];
                    const parsed = !reset && this.getParsed(i);
                    const properties = {};
                    const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(.5) : iScale.getPixelForValue(parsed[iAxis]);
                    const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel);
                    if (includeOptions) {
                        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                        if (reset) properties.options.radius = 0;
                    }
                    this.updateElement(point, i, properties, mode);
                }
            }
            resolveDataElementOptions(index, mode) {
                const parsed = this.getParsed(index);
                let values = super.resolveDataElementOptions(index, mode);
                if (values.$shared) values = Object.assign({}, values, {
                    $shared: false
                });
                const radius = values.radius;
                if (mode !== "active") values.radius = 0;
                values.radius += valueOrDefault(parsed && parsed._custom, radius);
                return values;
            }
        }
        function getRatioAndOffset(rotation, circumference, cutout) {
            let ratioX = 1;
            let ratioY = 1;
            let offsetX = 0;
            let offsetY = 0;
            if (circumference < TAU) {
                const startAngle = rotation;
                const endAngle = startAngle + circumference;
                const startX = Math.cos(startAngle);
                const startY = Math.sin(startAngle);
                const endX = Math.cos(endAngle);
                const endY = Math.sin(endAngle);
                const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
                const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
                const maxX = calcMax(0, startX, endX);
                const maxY = calcMax(HALF_PI, startY, endY);
                const minX = calcMin(PI, startX, endX);
                const minY = calcMin(PI + HALF_PI, startY, endY);
                ratioX = (maxX - minX) / 2;
                ratioY = (maxY - minY) / 2;
                offsetX = -(maxX + minX) / 2;
                offsetY = -(maxY + minY) / 2;
            }
            return {
                ratioX,
                ratioY,
                offsetX,
                offsetY
            };
        }
        class DoughnutController extends DatasetController {
            static id="doughnut";
            static defaults={
                datasetElementType: false,
                dataElementType: "arc",
                animation: {
                    animateRotate: true,
                    animateScale: false
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing" ]
                    }
                },
                cutout: "50%",
                rotation: 0,
                circumference: 360,
                radius: "100%",
                spacing: 0,
                indexAxis: "r"
            };
            static descriptors={
                _scriptable: name => name !== "spacing",
                _indexable: name => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
            };
            static overrides={
                aspectRatio: 1,
                plugins: {
                    legend: {
                        labels: {
                            generateLabels(chart) {
                                const data = chart.data;
                                if (data.labels.length && data.datasets.length) {
                                    const {labels: {pointStyle, color}} = chart.legend.options;
                                    return data.labels.map(((label, i) => {
                                        const meta = chart.getDatasetMeta(0);
                                        const style = meta.controller.getStyle(i);
                                        return {
                                            text: label,
                                            fillStyle: style.backgroundColor,
                                            strokeStyle: style.borderColor,
                                            fontColor: color,
                                            lineWidth: style.borderWidth,
                                            pointStyle,
                                            hidden: !chart.getDataVisibility(i),
                                            index: i
                                        };
                                    }));
                                }
                                return [];
                            }
                        },
                        onClick(e, legendItem, legend) {
                            legend.chart.toggleDataVisibility(legendItem.index);
                            legend.chart.update();
                        }
                    }
                }
            };
            constructor(chart, datasetIndex) {
                super(chart, datasetIndex);
                this.enableOptionSharing = true;
                this.innerRadius = void 0;
                this.outerRadius = void 0;
                this.offsetX = void 0;
                this.offsetY = void 0;
            }
            linkScales() {}
            parse(start, count) {
                const data = this.getDataset().data;
                const meta = this._cachedMeta;
                if (this._parsing === false) meta._parsed = data; else {
                    let getter = i => +data[i];
                    if (helpers_segment_isObject(data[start])) {
                        const {key = "value"} = this._parsing;
                        getter = i => +resolveObjectKey(data[i], key);
                    }
                    let i, ilen;
                    for (i = start, ilen = start + count; i < ilen; ++i) meta._parsed[i] = getter(i);
                }
            }
            _getRotation() {
                return toRadians(this.options.rotation - 90);
            }
            _getCircumference() {
                return toRadians(this.options.circumference);
            }
            _getRotationExtents() {
                let min = TAU;
                let max = -TAU;
                for (let i = 0; i < this.chart.data.datasets.length; ++i) if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                    const controller = this.chart.getDatasetMeta(i).controller;
                    const rotation = controller._getRotation();
                    const circumference = controller._getCircumference();
                    min = Math.min(min, rotation);
                    max = Math.max(max, rotation + circumference);
                }
                return {
                    rotation: min,
                    circumference: max - min
                };
            }
            update(mode) {
                const chart = this.chart;
                const {chartArea} = chart;
                const meta = this._cachedMeta;
                const arcs = meta.data;
                const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
                const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
                const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
                const chartWeight = this._getRingWeight(this.index);
                const {circumference, rotation} = this._getRotationExtents();
                const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
                const maxWidth = (chartArea.width - spacing) / ratioX;
                const maxHeight = (chartArea.height - spacing) / ratioY;
                const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
                const outerRadius = toDimension(this.options.radius, maxRadius);
                const innerRadius = Math.max(outerRadius * cutout, 0);
                const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
                this.offsetX = offsetX * outerRadius;
                this.offsetY = offsetY * outerRadius;
                meta.total = this.calculateTotal();
                this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
                this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
                this.updateElements(arcs, 0, arcs.length, mode);
            }
            _circumference(i, reset) {
                const opts = this.options;
                const meta = this._cachedMeta;
                const circumference = this._getCircumference();
                if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) return 0;
                return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
            }
            updateElements(arcs, start, count, mode) {
                const reset = mode === "reset";
                const chart = this.chart;
                const chartArea = chart.chartArea;
                const opts = chart.options;
                const animationOpts = opts.animation;
                const centerX = (chartArea.left + chartArea.right) / 2;
                const centerY = (chartArea.top + chartArea.bottom) / 2;
                const animateScale = reset && animationOpts.animateScale;
                const innerRadius = animateScale ? 0 : this.innerRadius;
                const outerRadius = animateScale ? 0 : this.outerRadius;
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                let startAngle = this._getRotation();
                let i;
                for (i = 0; i < start; ++i) startAngle += this._circumference(i, reset);
                for (i = start; i < start + count; ++i) {
                    const circumference = this._circumference(i, reset);
                    const arc = arcs[i];
                    const properties = {
                        x: centerX + this.offsetX,
                        y: centerY + this.offsetY,
                        startAngle,
                        endAngle: startAngle + circumference,
                        circumference,
                        outerRadius,
                        innerRadius
                    };
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
                    startAngle += circumference;
                    this.updateElement(arc, i, properties, mode);
                }
            }
            calculateTotal() {
                const meta = this._cachedMeta;
                const metaData = meta.data;
                let total = 0;
                let i;
                for (i = 0; i < metaData.length; i++) {
                    const value = meta._parsed[i];
                    if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) total += Math.abs(value);
                }
                return total;
            }
            calculateCircumference(value) {
                const total = this._cachedMeta.total;
                if (total > 0 && !isNaN(value)) return TAU * (Math.abs(value) / total);
                return 0;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const chart = this.chart;
                const labels = chart.data.labels || [];
                const value = formatNumber(meta._parsed[index], chart.options.locale);
                return {
                    label: labels[index] || "",
                    value
                };
            }
            getMaxBorderWidth(arcs) {
                let max = 0;
                const chart = this.chart;
                let i, ilen, meta, controller, options;
                if (!arcs) for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) if (chart.isDatasetVisible(i)) {
                    meta = chart.getDatasetMeta(i);
                    arcs = meta.data;
                    controller = meta.controller;
                    break;
                }
                if (!arcs) return 0;
                for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                    options = controller.resolveDataElementOptions(i);
                    if (options.borderAlign !== "inner") max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
                }
                return max;
            }
            getMaxOffset(arcs) {
                let max = 0;
                for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
                    const options = this.resolveDataElementOptions(i);
                    max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
                }
                return max;
            }
            _getRingWeightOffset(datasetIndex) {
                let ringWeightOffset = 0;
                for (let i = 0; i < datasetIndex; ++i) if (this.chart.isDatasetVisible(i)) ringWeightOffset += this._getRingWeight(i);
                return ringWeightOffset;
            }
            _getRingWeight(datasetIndex) {
                return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
            }
            _getVisibleDatasetWeightTotal() {
                return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
            }
        }
        class LineController extends DatasetController {
            static id="line";
            static defaults={
                datasetElementType: "line",
                dataElementType: "point",
                showLine: true,
                spanGaps: false
            };
            static overrides={
                scales: {
                    _index_: {
                        type: "category"
                    },
                    _value_: {
                        type: "linear"
                    }
                }
            };
            initialize() {
                this.enableOptionSharing = true;
                this.supportsDecimation = true;
                super.initialize();
            }
            update(mode) {
                const meta = this._cachedMeta;
                const {dataset: line, data: points = [], _dataset} = meta;
                const animationsDisabled = this.chart._animationsDisabled;
                let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
                this._drawStart = start;
                this._drawCount = count;
                if (_scaleRangesChanged(meta)) {
                    start = 0;
                    count = points.length;
                }
                line._chart = this.chart;
                line._datasetIndex = this.index;
                line._decimated = !!_dataset._decimated;
                line.points = points;
                const options = this.resolveDatasetElementOptions(mode);
                if (!this.options.showLine) options.borderWidth = 0;
                options.segment = this.options.segment;
                this.updateElement(line, void 0, {
                    animated: !animationsDisabled,
                    options
                }, mode);
                this.updateElements(points, start, count, mode);
            }
            updateElements(points, start, count, mode) {
                const reset = mode === "reset";
                const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                const {spanGaps, segment} = this.options;
                const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
                const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
                const end = start + count;
                const pointsCount = points.length;
                let prevParsed = start > 0 && this.getParsed(start - 1);
                for (let i = 0; i < pointsCount; ++i) {
                    const point = points[i];
                    const properties = directUpdate ? point : {};
                    if (i < start || i >= end) {
                        properties.skip = true;
                        continue;
                    }
                    const parsed = this.getParsed(i);
                    const nullData = isNullOrUndef(parsed[vAxis]);
                    const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                    const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                    properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                    if (segment) {
                        properties.parsed = parsed;
                        properties.raw = _dataset.data[i];
                    }
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    if (!directUpdate) this.updateElement(point, i, properties, mode);
                    prevParsed = parsed;
                }
            }
            getMaxOverflow() {
                const meta = this._cachedMeta;
                const dataset = meta.dataset;
                const border = dataset.options && dataset.options.borderWidth || 0;
                const data = meta.data || [];
                if (!data.length) return border;
                const firstPoint = data[0].size(this.resolveDataElementOptions(0));
                const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(border, firstPoint, lastPoint) / 2;
            }
            draw() {
                const meta = this._cachedMeta;
                meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
                super.draw();
            }
        }
        class PolarAreaController extends DatasetController {
            static id="polarArea";
            static defaults={
                dataElementType: "arc",
                animation: {
                    animateRotate: true,
                    animateScale: true
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius" ]
                    }
                },
                indexAxis: "r",
                startAngle: 0
            };
            static overrides={
                aspectRatio: 1,
                plugins: {
                    legend: {
                        labels: {
                            generateLabels(chart) {
                                const data = chart.data;
                                if (data.labels.length && data.datasets.length) {
                                    const {labels: {pointStyle, color}} = chart.legend.options;
                                    return data.labels.map(((label, i) => {
                                        const meta = chart.getDatasetMeta(0);
                                        const style = meta.controller.getStyle(i);
                                        return {
                                            text: label,
                                            fillStyle: style.backgroundColor,
                                            strokeStyle: style.borderColor,
                                            fontColor: color,
                                            lineWidth: style.borderWidth,
                                            pointStyle,
                                            hidden: !chart.getDataVisibility(i),
                                            index: i
                                        };
                                    }));
                                }
                                return [];
                            }
                        },
                        onClick(e, legendItem, legend) {
                            legend.chart.toggleDataVisibility(legendItem.index);
                            legend.chart.update();
                        }
                    }
                },
                scales: {
                    r: {
                        type: "radialLinear",
                        angleLines: {
                            display: false
                        },
                        beginAtZero: true,
                        grid: {
                            circular: true
                        },
                        pointLabels: {
                            display: false
                        },
                        startAngle: 0
                    }
                }
            };
            constructor(chart, datasetIndex) {
                super(chart, datasetIndex);
                this.innerRadius = void 0;
                this.outerRadius = void 0;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const chart = this.chart;
                const labels = chart.data.labels || [];
                const value = formatNumber(meta._parsed[index].r, chart.options.locale);
                return {
                    label: labels[index] || "",
                    value
                };
            }
            parseObjectData(meta, data, start, count) {
                return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
            }
            update(mode) {
                const arcs = this._cachedMeta.data;
                this._updateRadius();
                this.updateElements(arcs, 0, arcs.length, mode);
            }
            getMinMax() {
                const meta = this._cachedMeta;
                const range = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                };
                meta.data.forEach(((element, index) => {
                    const parsed = this.getParsed(index).r;
                    if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                        if (parsed < range.min) range.min = parsed;
                        if (parsed > range.max) range.max = parsed;
                    }
                }));
                return range;
            }
            _updateRadius() {
                const chart = this.chart;
                const chartArea = chart.chartArea;
                const opts = chart.options;
                const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                const outerRadius = Math.max(minSize / 2, 0);
                const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
                const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
                this.outerRadius = outerRadius - radiusLength * this.index;
                this.innerRadius = this.outerRadius - radiusLength;
            }
            updateElements(arcs, start, count, mode) {
                const reset = mode === "reset";
                const chart = this.chart;
                const opts = chart.options;
                const animationOpts = opts.animation;
                const scale = this._cachedMeta.rScale;
                const centerX = scale.xCenter;
                const centerY = scale.yCenter;
                const datasetStartAngle = scale.getIndexAngle(0) - .5 * PI;
                let angle = datasetStartAngle;
                let i;
                const defaultAngle = 360 / this.countVisibleElements();
                for (i = 0; i < start; ++i) angle += this._computeAngle(i, mode, defaultAngle);
                for (i = start; i < start + count; i++) {
                    const arc = arcs[i];
                    let startAngle = angle;
                    let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
                    let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
                    angle = endAngle;
                    if (reset) {
                        if (animationOpts.animateScale) outerRadius = 0;
                        if (animationOpts.animateRotate) startAngle = endAngle = datasetStartAngle;
                    }
                    const properties = {
                        x: centerX,
                        y: centerY,
                        innerRadius: 0,
                        outerRadius,
                        startAngle,
                        endAngle,
                        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
                    };
                    this.updateElement(arc, i, properties, mode);
                }
            }
            countVisibleElements() {
                const meta = this._cachedMeta;
                let count = 0;
                meta.data.forEach(((element, index) => {
                    if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) count++;
                }));
                return count;
            }
            _computeAngle(index, mode, defaultAngle) {
                return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
            }
        }
        class PieController extends DoughnutController {
            static id="pie";
            static defaults={
                cutout: 0,
                rotation: 0,
                circumference: 360,
                radius: "100%"
            };
        }
        class RadarController extends DatasetController {
            static id="radar";
            static defaults={
                datasetElementType: "line",
                dataElementType: "point",
                indexAxis: "r",
                showLine: true,
                elements: {
                    line: {
                        fill: "start"
                    }
                }
            };
            static overrides={
                aspectRatio: 1,
                scales: {
                    r: {
                        type: "radialLinear"
                    }
                }
            };
            getLabelAndValue(index) {
                const vScale = this._cachedMeta.vScale;
                const parsed = this.getParsed(index);
                return {
                    label: vScale.getLabels()[index],
                    value: "" + vScale.getLabelForValue(parsed[vScale.axis])
                };
            }
            parseObjectData(meta, data, start, count) {
                return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
            }
            update(mode) {
                const meta = this._cachedMeta;
                const line = meta.dataset;
                const points = meta.data || [];
                const labels = meta.iScale.getLabels();
                line.points = points;
                if (mode !== "resize") {
                    const options = this.resolveDatasetElementOptions(mode);
                    if (!this.options.showLine) options.borderWidth = 0;
                    const properties = {
                        _loop: true,
                        _fullLoop: labels.length === points.length,
                        options
                    };
                    this.updateElement(line, void 0, properties, mode);
                }
                this.updateElements(points, 0, points.length, mode);
            }
            updateElements(points, start, count, mode) {
                const scale = this._cachedMeta.rScale;
                const reset = mode === "reset";
                for (let i = start; i < start + count; i++) {
                    const point = points[i];
                    const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
                    const x = reset ? scale.xCenter : pointPosition.x;
                    const y = reset ? scale.yCenter : pointPosition.y;
                    const properties = {
                        x,
                        y,
                        angle: pointPosition.angle,
                        skip: isNaN(x) || isNaN(y),
                        options
                    };
                    this.updateElement(point, i, properties, mode);
                }
            }
        }
        class ScatterController extends DatasetController {
            static id="scatter";
            static defaults={
                datasetElementType: false,
                dataElementType: "point",
                showLine: false,
                fill: false
            };
            static overrides={
                interaction: {
                    mode: "point"
                },
                scales: {
                    x: {
                        type: "linear"
                    },
                    y: {
                        type: "linear"
                    }
                }
            };
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const labels = this.chart.data.labels || [];
                const {xScale, yScale} = meta;
                const parsed = this.getParsed(index);
                const x = xScale.getLabelForValue(parsed.x);
                const y = yScale.getLabelForValue(parsed.y);
                return {
                    label: labels[index] || "",
                    value: "(" + x + ", " + y + ")"
                };
            }
            update(mode) {
                const meta = this._cachedMeta;
                const {data: points = []} = meta;
                const animationsDisabled = this.chart._animationsDisabled;
                let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
                this._drawStart = start;
                this._drawCount = count;
                if (_scaleRangesChanged(meta)) {
                    start = 0;
                    count = points.length;
                }
                if (this.options.showLine) {
                    if (!this.datasetElementType) this.addElements();
                    const {dataset: line, _dataset} = meta;
                    line._chart = this.chart;
                    line._datasetIndex = this.index;
                    line._decimated = !!_dataset._decimated;
                    line.points = points;
                    const options = this.resolveDatasetElementOptions(mode);
                    options.segment = this.options.segment;
                    this.updateElement(line, void 0, {
                        animated: !animationsDisabled,
                        options
                    }, mode);
                } else if (this.datasetElementType) {
                    delete meta.dataset;
                    this.datasetElementType = false;
                }
                this.updateElements(points, start, count, mode);
            }
            addElements() {
                const {showLine} = this.options;
                if (!this.datasetElementType && showLine) this.datasetElementType = this.chart.registry.getElement("line");
                super.addElements();
            }
            updateElements(points, start, count, mode) {
                const reset = mode === "reset";
                const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
                const firstOpts = this.resolveDataElementOptions(start, mode);
                const sharedOptions = this.getSharedOptions(firstOpts);
                const includeOptions = this.includeOptions(mode, sharedOptions);
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                const {spanGaps, segment} = this.options;
                const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
                const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
                let prevParsed = start > 0 && this.getParsed(start - 1);
                for (let i = start; i < start + count; ++i) {
                    const point = points[i];
                    const parsed = this.getParsed(i);
                    const properties = directUpdate ? point : {};
                    const nullData = isNullOrUndef(parsed[vAxis]);
                    const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                    const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                    properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                    if (segment) {
                        properties.parsed = parsed;
                        properties.raw = _dataset.data[i];
                    }
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    if (!directUpdate) this.updateElement(point, i, properties, mode);
                    prevParsed = parsed;
                }
                this.updateSharedOptions(sharedOptions, mode, firstOpts);
            }
            getMaxOverflow() {
                const meta = this._cachedMeta;
                const data = meta.data || [];
                if (!this.options.showLine) {
                    let max = 0;
                    for (let i = data.length - 1; i >= 0; --i) max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
                    return max > 0 && max;
                }
                const dataset = meta.dataset;
                const border = dataset.options && dataset.options.borderWidth || 0;
                if (!data.length) return border;
                const firstPoint = data[0].size(this.resolveDataElementOptions(0));
                const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(border, firstPoint, lastPoint) / 2;
            }
        }
        var controllers = Object.freeze({
            __proto__: null,
            BarController,
            BubbleController,
            DoughnutController,
            LineController,
            PieController,
            PolarAreaController,
            RadarController,
            ScatterController
        });
        function chart_abstract() {
            throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
        }
        class DateAdapterBase {
            static override(members) {
                Object.assign(DateAdapterBase.prototype, members);
            }
            options;
            constructor(options) {
                this.options = options || {};
            }
            init() {}
            formats() {
                return chart_abstract();
            }
            parse() {
                return chart_abstract();
            }
            format() {
                return chart_abstract();
            }
            add() {
                return chart_abstract();
            }
            diff() {
                return chart_abstract();
            }
            startOf() {
                return chart_abstract();
            }
            endOf() {
                return chart_abstract();
            }
        }
        var adapters = {
            _date: DateAdapterBase
        };
        function binarySearch(metaset, axis, value, intersect) {
            const {controller, data, _sorted} = metaset;
            const iScale = controller._cachedMeta.iScale;
            if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
                const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
                if (!intersect) return lookupMethod(data, axis, value); else if (controller._sharedOptions) {
                    const el = data[0];
                    const range = typeof el.getRange === "function" && el.getRange(axis);
                    if (range) {
                        const start = lookupMethod(data, axis, value - range);
                        const end = lookupMethod(data, axis, value + range);
                        return {
                            lo: start.lo,
                            hi: end.hi
                        };
                    }
                }
            }
            return {
                lo: 0,
                hi: data.length - 1
            };
        }
        function evaluateInteractionItems(chart, axis, position, handler, intersect) {
            const metasets = chart.getSortedVisibleDatasetMetas();
            const value = position[axis];
            for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
                const {index, data} = metasets[i];
                const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
                for (let j = lo; j <= hi; ++j) {
                    const element = data[j];
                    if (!element.skip) handler(element, index, j);
                }
            }
        }
        function getDistanceMetricForAxis(axis) {
            const useX = axis.indexOf("x") !== -1;
            const useY = axis.indexOf("y") !== -1;
            return function(pt1, pt2) {
                const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
                const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
                return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
            };
        }
        function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
            const items = [];
            if (!includeInvisible && !chart.isPointInArea(position)) return items;
            const evaluationFunc = function(element, datasetIndex, index) {
                if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) return;
                if (element.inRange(position.x, position.y, useFinalPosition)) items.push({
                    element,
                    datasetIndex,
                    index
                });
            };
            evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
            return items;
        }
        function getNearestRadialItems(chart, position, axis, useFinalPosition) {
            let items = [];
            function evaluationFunc(element, datasetIndex, index) {
                const {startAngle, endAngle} = element.getProps([ "startAngle", "endAngle" ], useFinalPosition);
                const {angle} = getAngleFromPoint(element, {
                    x: position.x,
                    y: position.y
                });
                if (_angleBetween(angle, startAngle, endAngle)) items.push({
                    element,
                    datasetIndex,
                    index
                });
            }
            evaluateInteractionItems(chart, axis, position, evaluationFunc);
            return items;
        }
        function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
            let items = [];
            const distanceMetric = getDistanceMetricForAxis(axis);
            let minDistance = Number.POSITIVE_INFINITY;
            function evaluationFunc(element, datasetIndex, index) {
                const inRange = element.inRange(position.x, position.y, useFinalPosition);
                if (intersect && !inRange) return;
                const center = element.getCenterPoint(useFinalPosition);
                const pointInArea = !!includeInvisible || chart.isPointInArea(center);
                if (!pointInArea && !inRange) return;
                const distance = distanceMetric(position, center);
                if (distance < minDistance) {
                    items = [ {
                        element,
                        datasetIndex,
                        index
                    } ];
                    minDistance = distance;
                } else if (distance === minDistance) items.push({
                    element,
                    datasetIndex,
                    index
                });
            }
            evaluateInteractionItems(chart, axis, position, evaluationFunc);
            return items;
        }
        function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
            if (!includeInvisible && !chart.isPointInArea(position)) return [];
            return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
        }
        function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
            const items = [];
            const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
            let intersectsItem = false;
            evaluateInteractionItems(chart, axis, position, ((element, datasetIndex, index) => {
                if (element[rangeMethod](position[axis], useFinalPosition)) {
                    items.push({
                        element,
                        datasetIndex,
                        index
                    });
                    intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
                }
            }));
            if (intersect && !intersectsItem) return [];
            return items;
        }
        var Interaction = {
            evaluateInteractionItems,
            modes: {
                index(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "x";
                    const includeInvisible = options.includeInvisible || false;
                    const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
                    const elements = [];
                    if (!items.length) return [];
                    chart.getSortedVisibleDatasetMetas().forEach((meta => {
                        const index = items[0].index;
                        const element = meta.data[index];
                        if (element && !element.skip) elements.push({
                            element,
                            datasetIndex: meta.index,
                            index
                        });
                    }));
                    return elements;
                },
                dataset(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "xy";
                    const includeInvisible = options.includeInvisible || false;
                    let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
                    if (items.length > 0) {
                        const datasetIndex = items[0].datasetIndex;
                        const data = chart.getDatasetMeta(datasetIndex).data;
                        items = [];
                        for (let i = 0; i < data.length; ++i) items.push({
                            element: data[i],
                            datasetIndex,
                            index: i
                        });
                    }
                    return items;
                },
                point(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "xy";
                    const includeInvisible = options.includeInvisible || false;
                    return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
                },
                nearest(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "xy";
                    const includeInvisible = options.includeInvisible || false;
                    return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
                },
                x(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
                },
                y(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
                }
            }
        };
        const STATIC_POSITIONS = [ "left", "top", "right", "bottom" ];
        function filterByPosition(array, position) {
            return array.filter((v => v.pos === position));
        }
        function filterDynamicPositionByAxis(array, axis) {
            return array.filter((v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis));
        }
        function sortByWeight(array, reverse) {
            return array.sort(((a, b) => {
                const v0 = reverse ? b : a;
                const v1 = reverse ? a : b;
                return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
            }));
        }
        function wrapBoxes(boxes) {
            const layoutBoxes = [];
            let i, ilen, box, pos, stack, stackWeight;
            for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
                box = boxes[i];
                ({position: pos, options: {stack, stackWeight = 1}} = box);
                layoutBoxes.push({
                    index: i,
                    box,
                    pos,
                    horizontal: box.isHorizontal(),
                    weight: box.weight,
                    stack: stack && pos + stack,
                    stackWeight
                });
            }
            return layoutBoxes;
        }
        function buildStacks(layouts) {
            const stacks = {};
            for (const wrap of layouts) {
                const {stack, pos, stackWeight} = wrap;
                if (!stack || !STATIC_POSITIONS.includes(pos)) continue;
                const _stack = stacks[stack] || (stacks[stack] = {
                    count: 0,
                    placed: 0,
                    weight: 0,
                    size: 0
                });
                _stack.count++;
                _stack.weight += stackWeight;
            }
            return stacks;
        }
        function setLayoutDims(layouts, params) {
            const stacks = buildStacks(layouts);
            const {vBoxMaxWidth, hBoxMaxHeight} = params;
            let i, ilen, layout;
            for (i = 0, ilen = layouts.length; i < ilen; ++i) {
                layout = layouts[i];
                const {fullSize} = layout.box;
                const stack = stacks[layout.stack];
                const factor = stack && layout.stackWeight / stack.weight;
                if (layout.horizontal) {
                    layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
                    layout.height = hBoxMaxHeight;
                } else {
                    layout.width = vBoxMaxWidth;
                    layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
                }
            }
            return stacks;
        }
        function buildLayoutBoxes(boxes) {
            const layoutBoxes = wrapBoxes(boxes);
            const fullSize = sortByWeight(layoutBoxes.filter((wrap => wrap.box.fullSize)), true);
            const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
            const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
            const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
            const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
            const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
            const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
            return {
                fullSize,
                leftAndTop: left.concat(top),
                rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
                chartArea: filterByPosition(layoutBoxes, "chartArea"),
                vertical: left.concat(right).concat(centerVertical),
                horizontal: top.concat(bottom).concat(centerHorizontal)
            };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
            return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateMaxPadding(maxPadding, boxPadding) {
            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
            const {pos, box} = layout;
            const maxPadding = chartArea.maxPadding;
            if (!helpers_segment_isObject(pos)) {
                if (layout.size) chartArea[pos] -= layout.size;
                const stack = stacks[layout.stack] || {
                    size: 0,
                    count: 1
                };
                stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
                layout.size = stack.size / stack.count;
                chartArea[pos] += layout.size;
            }
            if (box.getPadding) updateMaxPadding(maxPadding, box.getPadding());
            const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
            const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
            const widthChanged = newWidth !== chartArea.w;
            const heightChanged = newHeight !== chartArea.h;
            chartArea.w = newWidth;
            chartArea.h = newHeight;
            return layout.horizontal ? {
                same: widthChanged,
                other: heightChanged
            } : {
                same: heightChanged,
                other: widthChanged
            };
        }
        function handleMaxPadding(chartArea) {
            const maxPadding = chartArea.maxPadding;
            function updatePos(pos) {
                const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
                chartArea[pos] += change;
                return change;
            }
            chartArea.y += updatePos("top");
            chartArea.x += updatePos("left");
            updatePos("right");
            updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
            const maxPadding = chartArea.maxPadding;
            function marginForPositions(positions) {
                const margin = {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                };
                positions.forEach((pos => {
                    margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
                }));
                return margin;
            }
            return horizontal ? marginForPositions([ "left", "right" ]) : marginForPositions([ "top", "bottom" ]);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
            const refitBoxes = [];
            let i, ilen, layout, box, refit, changed;
            for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
                layout = boxes[i];
                box = layout.box;
                box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
                const {same, other} = updateDims(chartArea, params, layout, stacks);
                refit |= same && refitBoxes.length;
                changed = changed || other;
                if (!box.fullSize) refitBoxes.push(layout);
            }
            return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
        }
        function setBoxDims(box, left, top, width, height) {
            box.top = top;
            box.left = left;
            box.right = left + width;
            box.bottom = top + height;
            box.width = width;
            box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
            const userPadding = params.padding;
            let {x, y} = chartArea;
            for (const layout of boxes) {
                const box = layout.box;
                const stack = stacks[layout.stack] || {
                    count: 1,
                    placed: 0,
                    weight: 1
                };
                const weight = layout.stackWeight / stack.weight || 1;
                if (layout.horizontal) {
                    const width = chartArea.w * weight;
                    const height = stack.size || box.height;
                    if (defined(stack.start)) y = stack.start;
                    if (box.fullSize) setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height); else setBoxDims(box, chartArea.left + stack.placed, y, width, height);
                    stack.start = y;
                    stack.placed += width;
                    y = box.bottom;
                } else {
                    const height = chartArea.h * weight;
                    const width = stack.size || box.width;
                    if (defined(stack.start)) x = stack.start;
                    if (box.fullSize) setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top); else setBoxDims(box, x, chartArea.top + stack.placed, width, height);
                    stack.start = x;
                    stack.placed += height;
                    x = box.right;
                }
            }
            chartArea.x = x;
            chartArea.y = y;
        }
        var layouts = {
            addBox(chart, item) {
                if (!chart.boxes) chart.boxes = [];
                item.fullSize = item.fullSize || false;
                item.position = item.position || "top";
                item.weight = item.weight || 0;
                item._layers = item._layers || function() {
                    return [ {
                        z: 0,
                        draw(chartArea) {
                            item.draw(chartArea);
                        }
                    } ];
                };
                chart.boxes.push(item);
            },
            removeBox(chart, layoutItem) {
                const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
                if (index !== -1) chart.boxes.splice(index, 1);
            },
            configure(chart, item, options) {
                item.fullSize = options.fullSize;
                item.position = options.position;
                item.weight = options.weight;
            },
            update(chart, width, height, minPadding) {
                if (!chart) return;
                const padding = toPadding(chart.options.layout.padding);
                const availableWidth = Math.max(width - padding.width, 0);
                const availableHeight = Math.max(height - padding.height, 0);
                const boxes = buildLayoutBoxes(chart.boxes);
                const verticalBoxes = boxes.vertical;
                const horizontalBoxes = boxes.horizontal;
                each(chart.boxes, (box => {
                    if (typeof box.beforeLayout === "function") box.beforeLayout();
                }));
                const visibleVerticalBoxCount = verticalBoxes.reduce(((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1), 0) || 1;
                const params = Object.freeze({
                    outerWidth: width,
                    outerHeight: height,
                    padding,
                    availableWidth,
                    availableHeight,
                    vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
                    hBoxMaxHeight: availableHeight / 2
                });
                const maxPadding = Object.assign({}, padding);
                updateMaxPadding(maxPadding, toPadding(minPadding));
                const chartArea = Object.assign({
                    maxPadding,
                    w: availableWidth,
                    h: availableHeight,
                    x: padding.left,
                    y: padding.top
                }, padding);
                const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
                fitBoxes(boxes.fullSize, chartArea, params, stacks);
                fitBoxes(verticalBoxes, chartArea, params, stacks);
                if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) fitBoxes(verticalBoxes, chartArea, params, stacks);
                handleMaxPadding(chartArea);
                placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
                chartArea.x += chartArea.w;
                chartArea.y += chartArea.h;
                placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
                chart.chartArea = {
                    left: chartArea.left,
                    top: chartArea.top,
                    right: chartArea.left + chartArea.w,
                    bottom: chartArea.top + chartArea.h,
                    height: chartArea.h,
                    width: chartArea.w
                };
                each(boxes.chartArea, (layout => {
                    const box = layout.box;
                    Object.assign(box, chart.chartArea);
                    box.update(chartArea.w, chartArea.h, {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    });
                }));
            }
        };
        class BasePlatform {
            acquireContext(canvas, aspectRatio) {}
            releaseContext(context) {
                return false;
            }
            addEventListener(chart, type, listener) {}
            removeEventListener(chart, type, listener) {}
            getDevicePixelRatio() {
                return 1;
            }
            getMaximumSize(element, width, height, aspectRatio) {
                width = Math.max(0, width || element.width);
                height = height || element.height;
                return {
                    width,
                    height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
                };
            }
            isAttached(canvas) {
                return true;
            }
            updateConfig(config) {}
        }
        class BasicPlatform extends BasePlatform {
            acquireContext(item) {
                return item && item.getContext && item.getContext("2d") || null;
            }
            updateConfig(config) {
                config.options.animation = false;
            }
        }
        const EXPANDO_KEY = "$chartjs";
        const EVENT_TYPES = {
            touchstart: "mousedown",
            touchmove: "mousemove",
            touchend: "mouseup",
            pointerenter: "mouseenter",
            pointerdown: "mousedown",
            pointermove: "mousemove",
            pointerup: "mouseup",
            pointerleave: "mouseout",
            pointerout: "mouseout"
        };
        const isNullOrEmpty = value => value === null || value === "";
        function initCanvas(canvas, aspectRatio) {
            const style = canvas.style;
            const renderHeight = canvas.getAttribute("height");
            const renderWidth = canvas.getAttribute("width");
            canvas[EXPANDO_KEY] = {
                initial: {
                    height: renderHeight,
                    width: renderWidth,
                    style: {
                        display: style.display,
                        height: style.height,
                        width: style.width
                    }
                }
            };
            style.display = style.display || "block";
            style.boxSizing = style.boxSizing || "border-box";
            if (isNullOrEmpty(renderWidth)) {
                const displayWidth = readUsedSize(canvas, "width");
                if (displayWidth !== void 0) canvas.width = displayWidth;
            }
            if (isNullOrEmpty(renderHeight)) if (canvas.style.height === "") canvas.height = canvas.width / (aspectRatio || 2); else {
                const displayHeight = readUsedSize(canvas, "height");
                if (displayHeight !== void 0) canvas.height = displayHeight;
            }
            return canvas;
        }
        const eventListenerOptions = supportsEventListenerOptions ? {
            passive: true
        } : false;
        function addListener(node, type, listener) {
            node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(chart, type, listener) {
            chart.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
        function fromNativeEvent(event, chart) {
            const type = EVENT_TYPES[event.type] || event.type;
            const {x, y} = getRelativePosition(event, chart);
            return {
                type,
                chart,
                native: event,
                x: x !== void 0 ? x : null,
                y: y !== void 0 ? y : null
            };
        }
        function nodeListContains(nodeList, canvas) {
            for (const node of nodeList) if (node === canvas || node.contains(canvas)) return true;
        }
        function createAttachObserver(chart, type, listener) {
            const canvas = chart.canvas;
            const observer = new MutationObserver((entries => {
                let trigger = false;
                for (const entry of entries) {
                    trigger = trigger || nodeListContains(entry.addedNodes, canvas);
                    trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
                }
                if (trigger) listener();
            }));
            observer.observe(document, {
                childList: true,
                subtree: true
            });
            return observer;
        }
        function createDetachObserver(chart, type, listener) {
            const canvas = chart.canvas;
            const observer = new MutationObserver((entries => {
                let trigger = false;
                for (const entry of entries) {
                    trigger = trigger || nodeListContains(entry.removedNodes, canvas);
                    trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
                }
                if (trigger) listener();
            }));
            observer.observe(document, {
                childList: true,
                subtree: true
            });
            return observer;
        }
        const drpListeningCharts = new Map;
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
            const dpr = window.devicePixelRatio;
            if (dpr === oldDevicePixelRatio) return;
            oldDevicePixelRatio = dpr;
            drpListeningCharts.forEach(((resize, chart) => {
                if (chart.currentDevicePixelRatio !== dpr) resize();
            }));
        }
        function listenDevicePixelRatioChanges(chart, resize) {
            if (!drpListeningCharts.size) window.addEventListener("resize", onWindowResize);
            drpListeningCharts.set(chart, resize);
        }
        function unlistenDevicePixelRatioChanges(chart) {
            drpListeningCharts.delete(chart);
            if (!drpListeningCharts.size) window.removeEventListener("resize", onWindowResize);
        }
        function createResizeObserver(chart, type, listener) {
            const canvas = chart.canvas;
            const container = canvas && _getParentNode(canvas);
            if (!container) return;
            const resize = throttled(((width, height) => {
                const w = container.clientWidth;
                listener(width, height);
                if (w < container.clientWidth) listener();
            }), window);
            const observer = new ResizeObserver((entries => {
                const entry = entries[0];
                const width = entry.contentRect.width;
                const height = entry.contentRect.height;
                if (width === 0 && height === 0) return;
                resize(width, height);
            }));
            observer.observe(container);
            listenDevicePixelRatioChanges(chart, resize);
            return observer;
        }
        function releaseObserver(chart, type, observer) {
            if (observer) observer.disconnect();
            if (type === "resize") unlistenDevicePixelRatioChanges(chart);
        }
        function createProxyAndListen(chart, type, listener) {
            const canvas = chart.canvas;
            const proxy = throttled((event => {
                if (chart.ctx !== null) listener(fromNativeEvent(event, chart));
            }), chart);
            addListener(canvas, type, proxy);
            return proxy;
        }
        class DomPlatform extends BasePlatform {
            acquireContext(canvas, aspectRatio) {
                const context = canvas && canvas.getContext && canvas.getContext("2d");
                if (context && context.canvas === canvas) {
                    initCanvas(canvas, aspectRatio);
                    return context;
                }
                return null;
            }
            releaseContext(context) {
                const canvas = context.canvas;
                if (!canvas[EXPANDO_KEY]) return false;
                const initial = canvas[EXPANDO_KEY].initial;
                [ "height", "width" ].forEach((prop => {
                    const value = initial[prop];
                    if (isNullOrUndef(value)) canvas.removeAttribute(prop); else canvas.setAttribute(prop, value);
                }));
                const style = initial.style || {};
                Object.keys(style).forEach((key => {
                    canvas.style[key] = style[key];
                }));
                canvas.width = canvas.width;
                delete canvas[EXPANDO_KEY];
                return true;
            }
            addEventListener(chart, type, listener) {
                this.removeEventListener(chart, type);
                const proxies = chart.$proxies || (chart.$proxies = {});
                const handlers = {
                    attach: createAttachObserver,
                    detach: createDetachObserver,
                    resize: createResizeObserver
                };
                const handler = handlers[type] || createProxyAndListen;
                proxies[type] = handler(chart, type, listener);
            }
            removeEventListener(chart, type) {
                const proxies = chart.$proxies || (chart.$proxies = {});
                const proxy = proxies[type];
                if (!proxy) return;
                const handlers = {
                    attach: releaseObserver,
                    detach: releaseObserver,
                    resize: releaseObserver
                };
                const handler = handlers[type] || removeListener;
                handler(chart, type, proxy);
                proxies[type] = void 0;
            }
            getDevicePixelRatio() {
                return window.devicePixelRatio;
            }
            getMaximumSize(canvas, width, height, aspectRatio) {
                return getMaximumSize(canvas, width, height, aspectRatio);
            }
            isAttached(canvas) {
                const container = _getParentNode(canvas);
                return !!(container && container.isConnected);
            }
        }
        function _detectPlatform(canvas) {
            if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) return BasicPlatform;
            return DomPlatform;
        }
        class Element {
            static defaults={};
            static defaultRoutes=void 0;
            x;
            y;
            active=false;
            options;
            $animations;
            tooltipPosition(useFinalPosition) {
                const {x, y} = this.getProps([ "x", "y" ], useFinalPosition);
                return {
                    x,
                    y
                };
            }
            hasValue() {
                return isNumber(this.x) && isNumber(this.y);
            }
            getProps(props, final) {
                const anims = this.$animations;
                if (!final || !anims) return this;
                const ret = {};
                props.forEach((prop => {
                    ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
                }));
                return ret;
            }
        }
        function autoSkip(scale, ticks) {
            const tickOpts = scale.options.ticks;
            const determinedMaxTicks = determineMaxTicks(scale);
            const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
            const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
            const numMajorIndices = majorIndices.length;
            const first = majorIndices[0];
            const last = majorIndices[numMajorIndices - 1];
            const newTicks = [];
            if (numMajorIndices > ticksLimit) {
                skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
                return newTicks;
            }
            const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
            if (numMajorIndices > 0) {
                let i, ilen;
                const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
                skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
                for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
                skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
                return newTicks;
            }
            skip(ticks, newTicks, spacing);
            return newTicks;
        }
        function determineMaxTicks(scale) {
            const offset = scale.options.offset;
            const tickLength = scale._tickSize();
            const maxScale = scale._length / tickLength + (offset ? 0 : 1);
            const maxChart = scale._maxLength / tickLength;
            return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
            const evenMajorSpacing = getEvenSpacing(majorIndices);
            const spacing = ticks.length / ticksLimit;
            if (!evenMajorSpacing) return Math.max(spacing, 1);
            const factors = _factorize(evenMajorSpacing);
            for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
                const factor = factors[i];
                if (factor > spacing) return factor;
            }
            return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
            const result = [];
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) if (ticks[i].major) result.push(i);
            return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
            let count = 0;
            let next = majorIndices[0];
            let i;
            spacing = Math.ceil(spacing);
            for (i = 0; i < ticks.length; i++) if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = majorIndices[count * spacing];
            }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
            const start = valueOrDefault(majorStart, 0);
            const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
            let count = 0;
            let length, i, next;
            spacing = Math.ceil(spacing);
            if (majorEnd) {
                length = majorEnd - majorStart;
                spacing = length / Math.floor(length / spacing);
            }
            next = start;
            while (next < 0) {
                count++;
                next = Math.round(start + count * spacing);
            }
            for (i = Math.max(start, 0); i < end; i++) if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = Math.round(start + count * spacing);
            }
        }
        function getEvenSpacing(arr) {
            const len = arr.length;
            let i, diff;
            if (len < 2) return false;
            for (diff = arr[0], i = 1; i < len; ++i) if (arr[i] - arr[i - 1] !== diff) return false;
            return diff;
        }
        const reverseAlign = align => align === "left" ? "right" : align === "right" ? "left" : align;
        const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
        const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
        function sample(arr, numItems) {
            const result = [];
            const increment = arr.length / numItems;
            const len = arr.length;
            let i = 0;
            for (;i < len; i += increment) result.push(arr[Math.floor(i)]);
            return result;
        }
        function getPixelForGridLine(scale, index, offsetGridLines) {
            const length = scale.ticks.length;
            const validIndex = Math.min(index, length - 1);
            const start = scale._startPixel;
            const end = scale._endPixel;
            const epsilon = 1e-6;
            let lineValue = scale.getPixelForTick(validIndex);
            let offset;
            if (offsetGridLines) {
                if (length === 1) offset = Math.max(lineValue - start, end - lineValue); else if (index === 0) offset = (scale.getPixelForTick(1) - lineValue) / 2; else offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
                lineValue += validIndex < index ? offset : -offset;
                if (lineValue < start - epsilon || lineValue > end + epsilon) return;
            }
            return lineValue;
        }
        function garbageCollect(caches, length) {
            each(caches, (cache => {
                const gc = cache.gc;
                const gcLen = gc.length / 2;
                let i;
                if (gcLen > length) {
                    for (i = 0; i < gcLen; ++i) delete cache.data[gc[i]];
                    gc.splice(0, gcLen);
                }
            }));
        }
        function getTickMarkLength(options) {
            return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
            if (!options.display) return 0;
            const font = toFont(options.font, fallback);
            const padding = toPadding(options.padding);
            const lines = isArray(options.text) ? options.text.length : 1;
            return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
            return createContext(parent, {
                scale,
                type: "scale"
            });
        }
        function createTickContext(parent, index, tick) {
            return createContext(parent, {
                tick,
                index,
                type: "tick"
            });
        }
        function titleAlign(align, position, reverse) {
            let ret = _toLeftRightCenter(align);
            if (reverse && position !== "right" || !reverse && position === "right") ret = reverseAlign(ret);
            return ret;
        }
        function titleArgs(scale, offset, position, align) {
            const {top, left, bottom, right, chart} = scale;
            const {chartArea, scales} = chart;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            const height = bottom - top;
            const width = right - left;
            if (scale.isHorizontal()) {
                titleX = _alignStartEnd(align, left, right);
                if (helpers_segment_isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
                } else if (position === "center") titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset; else titleY = offsetFromEdge(scale, position, offset);
                maxWidth = right - left;
            } else {
                if (helpers_segment_isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
                } else if (position === "center") titleX = (chartArea.left + chartArea.right) / 2 - width + offset; else titleX = offsetFromEdge(scale, position, offset);
                titleY = _alignStartEnd(align, bottom, top);
                rotation = position === "left" ? -HALF_PI : HALF_PI;
            }
            return {
                titleX,
                titleY,
                maxWidth,
                rotation
            };
        }
        class Scale extends Element {
            constructor(cfg) {
                super();
                this.id = cfg.id;
                this.type = cfg.type;
                this.options = void 0;
                this.ctx = cfg.ctx;
                this.chart = cfg.chart;
                this.top = void 0;
                this.bottom = void 0;
                this.left = void 0;
                this.right = void 0;
                this.width = void 0;
                this.height = void 0;
                this._margins = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                this.maxWidth = void 0;
                this.maxHeight = void 0;
                this.paddingTop = void 0;
                this.paddingBottom = void 0;
                this.paddingLeft = void 0;
                this.paddingRight = void 0;
                this.axis = void 0;
                this.labelRotation = void 0;
                this.min = void 0;
                this.max = void 0;
                this._range = void 0;
                this.ticks = [];
                this._gridLineItems = null;
                this._labelItems = null;
                this._labelSizes = null;
                this._length = 0;
                this._maxLength = 0;
                this._longestTextCache = {};
                this._startPixel = void 0;
                this._endPixel = void 0;
                this._reversePixels = false;
                this._userMax = void 0;
                this._userMin = void 0;
                this._suggestedMax = void 0;
                this._suggestedMin = void 0;
                this._ticksLength = 0;
                this._borderValue = 0;
                this._cache = {};
                this._dataLimitsCached = false;
                this.$context = void 0;
            }
            init(options) {
                this.options = options.setContext(this.getContext());
                this.axis = options.axis;
                this._userMin = this.parse(options.min);
                this._userMax = this.parse(options.max);
                this._suggestedMin = this.parse(options.suggestedMin);
                this._suggestedMax = this.parse(options.suggestedMax);
            }
            parse(raw, index) {
                return raw;
            }
            getUserBounds() {
                let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
                _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
                _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
                _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
                _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
                return {
                    min: finiteOrDefault(_userMin, _suggestedMin),
                    max: finiteOrDefault(_userMax, _suggestedMax),
                    minDefined: isNumberFinite(_userMin),
                    maxDefined: isNumberFinite(_userMax)
                };
            }
            getMinMax(canStack) {
                let {min, max, minDefined, maxDefined} = this.getUserBounds();
                let range;
                if (minDefined && maxDefined) return {
                    min,
                    max
                };
                const metas = this.getMatchingVisibleMetas();
                for (let i = 0, ilen = metas.length; i < ilen; ++i) {
                    range = metas[i].controller.getMinMax(this, canStack);
                    if (!minDefined) min = Math.min(min, range.min);
                    if (!maxDefined) max = Math.max(max, range.max);
                }
                min = maxDefined && min > max ? max : min;
                max = minDefined && min > max ? min : max;
                return {
                    min: finiteOrDefault(min, finiteOrDefault(max, min)),
                    max: finiteOrDefault(max, finiteOrDefault(min, max))
                };
            }
            getPadding() {
                return {
                    left: this.paddingLeft || 0,
                    top: this.paddingTop || 0,
                    right: this.paddingRight || 0,
                    bottom: this.paddingBottom || 0
                };
            }
            getTicks() {
                return this.ticks;
            }
            getLabels() {
                const data = this.chart.data;
                return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
            }
            getLabelItems(chartArea = this.chart.chartArea) {
                const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
                return items;
            }
            beforeLayout() {
                this._cache = {};
                this._dataLimitsCached = false;
            }
            beforeUpdate() {
                callback(this.options.beforeUpdate, [ this ]);
            }
            update(maxWidth, maxHeight, margins) {
                const {beginAtZero, grace, ticks: tickOpts} = this.options;
                const sampleSize = tickOpts.sampleSize;
                this.beforeUpdate();
                this.maxWidth = maxWidth;
                this.maxHeight = maxHeight;
                this._margins = margins = Object.assign({
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, margins);
                this.ticks = null;
                this._labelSizes = null;
                this._gridLineItems = null;
                this._labelItems = null;
                this.beforeSetDimensions();
                this.setDimensions();
                this.afterSetDimensions();
                this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
                if (!this._dataLimitsCached) {
                    this.beforeDataLimits();
                    this.determineDataLimits();
                    this.afterDataLimits();
                    this._range = _addGrace(this, grace, beginAtZero);
                    this._dataLimitsCached = true;
                }
                this.beforeBuildTicks();
                this.ticks = this.buildTicks() || [];
                this.afterBuildTicks();
                const samplingEnabled = sampleSize < this.ticks.length;
                this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
                this.configure();
                this.beforeCalculateLabelRotation();
                this.calculateLabelRotation();
                this.afterCalculateLabelRotation();
                if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
                    this.ticks = autoSkip(this, this.ticks);
                    this._labelSizes = null;
                    this.afterAutoSkip();
                }
                if (samplingEnabled) this._convertTicksToLabels(this.ticks);
                this.beforeFit();
                this.fit();
                this.afterFit();
                this.afterUpdate();
            }
            configure() {
                let reversePixels = this.options.reverse;
                let startPixel, endPixel;
                if (this.isHorizontal()) {
                    startPixel = this.left;
                    endPixel = this.right;
                } else {
                    startPixel = this.top;
                    endPixel = this.bottom;
                    reversePixels = !reversePixels;
                }
                this._startPixel = startPixel;
                this._endPixel = endPixel;
                this._reversePixels = reversePixels;
                this._length = endPixel - startPixel;
                this._alignToPixels = this.options.alignToPixels;
            }
            afterUpdate() {
                callback(this.options.afterUpdate, [ this ]);
            }
            beforeSetDimensions() {
                callback(this.options.beforeSetDimensions, [ this ]);
            }
            setDimensions() {
                if (this.isHorizontal()) {
                    this.width = this.maxWidth;
                    this.left = 0;
                    this.right = this.width;
                } else {
                    this.height = this.maxHeight;
                    this.top = 0;
                    this.bottom = this.height;
                }
                this.paddingLeft = 0;
                this.paddingTop = 0;
                this.paddingRight = 0;
                this.paddingBottom = 0;
            }
            afterSetDimensions() {
                callback(this.options.afterSetDimensions, [ this ]);
            }
            _callHooks(name) {
                this.chart.notifyPlugins(name, this.getContext());
                callback(this.options[name], [ this ]);
            }
            beforeDataLimits() {
                this._callHooks("beforeDataLimits");
            }
            determineDataLimits() {}
            afterDataLimits() {
                this._callHooks("afterDataLimits");
            }
            beforeBuildTicks() {
                this._callHooks("beforeBuildTicks");
            }
            buildTicks() {
                return [];
            }
            afterBuildTicks() {
                this._callHooks("afterBuildTicks");
            }
            beforeTickToLabelConversion() {
                callback(this.options.beforeTickToLabelConversion, [ this ]);
            }
            generateTickLabels(ticks) {
                const tickOpts = this.options.ticks;
                let i, ilen, tick;
                for (i = 0, ilen = ticks.length; i < ilen; i++) {
                    tick = ticks[i];
                    tick.label = callback(tickOpts.callback, [ tick.value, i, ticks ], this);
                }
            }
            afterTickToLabelConversion() {
                callback(this.options.afterTickToLabelConversion, [ this ]);
            }
            beforeCalculateLabelRotation() {
                callback(this.options.beforeCalculateLabelRotation, [ this ]);
            }
            calculateLabelRotation() {
                const options = this.options;
                const tickOpts = options.ticks;
                const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
                const minRotation = tickOpts.minRotation || 0;
                const maxRotation = tickOpts.maxRotation;
                let labelRotation = minRotation;
                let tickWidth, maxHeight, maxLabelDiagonal;
                if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
                    this.labelRotation = minRotation;
                    return;
                }
                const labelSizes = this._getLabelSizes();
                const maxLabelWidth = labelSizes.widest.width;
                const maxLabelHeight = labelSizes.highest.height;
                const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
                tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
                if (maxLabelWidth + 6 > tickWidth) {
                    tickWidth = maxWidth / (numTicks - (options.offset ? .5 : 1));
                    maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
                    maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
                    labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
                    labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
                }
                this.labelRotation = labelRotation;
            }
            afterCalculateLabelRotation() {
                callback(this.options.afterCalculateLabelRotation, [ this ]);
            }
            afterAutoSkip() {}
            beforeFit() {
                callback(this.options.beforeFit, [ this ]);
            }
            fit() {
                const minSize = {
                    width: 0,
                    height: 0
                };
                const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;
                const display = this._isVisible();
                const isHorizontal = this.isHorizontal();
                if (display) {
                    const titleHeight = getTitleHeight(titleOpts, chart.options.font);
                    if (isHorizontal) {
                        minSize.width = this.maxWidth;
                        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
                    } else {
                        minSize.height = this.maxHeight;
                        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
                    }
                    if (tickOpts.display && this.ticks.length) {
                        const {first, last, widest, highest} = this._getLabelSizes();
                        const tickPadding = tickOpts.padding * 2;
                        const angleRadians = toRadians(this.labelRotation);
                        const cos = Math.cos(angleRadians);
                        const sin = Math.sin(angleRadians);
                        if (isHorizontal) {
                            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                        } else {
                            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                        }
                        this._calculatePadding(first, last, sin, cos);
                    }
                }
                this._handleMargins();
                if (isHorizontal) {
                    this.width = this._length = chart.width - this._margins.left - this._margins.right;
                    this.height = minSize.height;
                } else {
                    this.width = minSize.width;
                    this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
                }
            }
            _calculatePadding(first, last, sin, cos) {
                const {ticks: {align, padding}, position} = this.options;
                const isRotated = this.labelRotation !== 0;
                const labelsBelowTicks = position !== "top" && this.axis === "x";
                if (this.isHorizontal()) {
                    const offsetLeft = this.getPixelForTick(0) - this.left;
                    const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
                    let paddingLeft = 0;
                    let paddingRight = 0;
                    if (isRotated) if (labelsBelowTicks) {
                        paddingLeft = cos * first.width;
                        paddingRight = sin * last.height;
                    } else {
                        paddingLeft = sin * first.height;
                        paddingRight = cos * last.width;
                    } else if (align === "start") paddingRight = last.width; else if (align === "end") paddingLeft = first.width; else if (align !== "inner") {
                        paddingLeft = first.width / 2;
                        paddingRight = last.width / 2;
                    }
                    this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
                    this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
                } else {
                    let paddingTop = last.height / 2;
                    let paddingBottom = first.height / 2;
                    if (align === "start") {
                        paddingTop = 0;
                        paddingBottom = first.height;
                    } else if (align === "end") {
                        paddingTop = last.height;
                        paddingBottom = 0;
                    }
                    this.paddingTop = paddingTop + padding;
                    this.paddingBottom = paddingBottom + padding;
                }
            }
            _handleMargins() {
                if (this._margins) {
                    this._margins.left = Math.max(this.paddingLeft, this._margins.left);
                    this._margins.top = Math.max(this.paddingTop, this._margins.top);
                    this._margins.right = Math.max(this.paddingRight, this._margins.right);
                    this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
                }
            }
            afterFit() {
                callback(this.options.afterFit, [ this ]);
            }
            isHorizontal() {
                const {axis, position} = this.options;
                return position === "top" || position === "bottom" || axis === "x";
            }
            isFullSize() {
                return this.options.fullSize;
            }
            _convertTicksToLabels(ticks) {
                this.beforeTickToLabelConversion();
                this.generateTickLabels(ticks);
                let i, ilen;
                for (i = 0, ilen = ticks.length; i < ilen; i++) if (isNullOrUndef(ticks[i].label)) {
                    ticks.splice(i, 1);
                    ilen--;
                    i--;
                }
                this.afterTickToLabelConversion();
            }
            _getLabelSizes() {
                let labelSizes = this._labelSizes;
                if (!labelSizes) {
                    const sampleSize = this.options.ticks.sampleSize;
                    let ticks = this.ticks;
                    if (sampleSize < ticks.length) ticks = sample(ticks, sampleSize);
                    this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
                }
                return labelSizes;
            }
            _computeLabelSizes(ticks, length, maxTicksLimit) {
                const {ctx, _longestTextCache: caches} = this;
                const widths = [];
                const heights = [];
                const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
                let widestLabelSize = 0;
                let highestLabelSize = 0;
                let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
                for (i = 0; i < length; i += increment) {
                    label = ticks[i].label;
                    tickFont = this._resolveTickFontOptions(i);
                    ctx.font = fontString = tickFont.string;
                    cache = caches[fontString] = caches[fontString] || {
                        data: {},
                        gc: []
                    };
                    lineHeight = tickFont.lineHeight;
                    width = height = 0;
                    if (!isNullOrUndef(label) && !isArray(label)) {
                        width = _measureText(ctx, cache.data, cache.gc, width, label);
                        height = lineHeight;
                    } else if (isArray(label)) for (j = 0, jlen = label.length; j < jlen; ++j) {
                        nestedLabel = label[j];
                        if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                            height += lineHeight;
                        }
                    }
                    widths.push(width);
                    heights.push(height);
                    widestLabelSize = Math.max(width, widestLabelSize);
                    highestLabelSize = Math.max(height, highestLabelSize);
                }
                garbageCollect(caches, length);
                const widest = widths.indexOf(widestLabelSize);
                const highest = heights.indexOf(highestLabelSize);
                const valueAt = idx => ({
                    width: widths[idx] || 0,
                    height: heights[idx] || 0
                });
                return {
                    first: valueAt(0),
                    last: valueAt(length - 1),
                    widest: valueAt(widest),
                    highest: valueAt(highest),
                    widths,
                    heights
                };
            }
            getLabelForValue(value) {
                return value;
            }
            getPixelForValue(value, index) {
                return NaN;
            }
            getValueForPixel(pixel) {}
            getPixelForTick(index) {
                const ticks = this.ticks;
                if (index < 0 || index > ticks.length - 1) return null;
                return this.getPixelForValue(ticks[index].value);
            }
            getPixelForDecimal(decimal) {
                if (this._reversePixels) decimal = 1 - decimal;
                const pixel = this._startPixel + decimal * this._length;
                return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
            }
            getDecimalForPixel(pixel) {
                const decimal = (pixel - this._startPixel) / this._length;
                return this._reversePixels ? 1 - decimal : decimal;
            }
            getBasePixel() {
                return this.getPixelForValue(this.getBaseValue());
            }
            getBaseValue() {
                const {min, max} = this;
                return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
            }
            getContext(index) {
                const ticks = this.ticks || [];
                if (index >= 0 && index < ticks.length) {
                    const tick = ticks[index];
                    return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
                }
                return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
            }
            _tickSize() {
                const optionTicks = this.options.ticks;
                const rot = toRadians(this.labelRotation);
                const cos = Math.abs(Math.cos(rot));
                const sin = Math.abs(Math.sin(rot));
                const labelSizes = this._getLabelSizes();
                const padding = optionTicks.autoSkipPadding || 0;
                const w = labelSizes ? labelSizes.widest.width + padding : 0;
                const h = labelSizes ? labelSizes.highest.height + padding : 0;
                return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
            }
            _isVisible() {
                const display = this.options.display;
                if (display !== "auto") return !!display;
                return this.getMatchingVisibleMetas().length > 0;
            }
            _computeGridLineItems(chartArea) {
                const axis = this.axis;
                const chart = this.chart;
                const options = this.options;
                const {grid, position, border} = options;
                const offset = grid.offset;
                const isHorizontal = this.isHorizontal();
                const ticks = this.ticks;
                const ticksLength = ticks.length + (offset ? 1 : 0);
                const tl = getTickMarkLength(grid);
                const items = [];
                const borderOpts = border.setContext(this.getContext());
                const axisWidth = borderOpts.display ? borderOpts.width : 0;
                const axisHalfWidth = axisWidth / 2;
                const alignBorderValue = function(pixel) {
                    return _alignPixel(chart, pixel, axisWidth);
                };
                let borderValue, i, lineValue, alignedLineValue;
                let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
                if (position === "top") {
                    borderValue = alignBorderValue(this.bottom);
                    ty1 = this.bottom - tl;
                    ty2 = borderValue - axisHalfWidth;
                    y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                    y2 = chartArea.bottom;
                } else if (position === "bottom") {
                    borderValue = alignBorderValue(this.top);
                    y1 = chartArea.top;
                    y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                    ty1 = borderValue + axisHalfWidth;
                    ty2 = this.top + tl;
                } else if (position === "left") {
                    borderValue = alignBorderValue(this.right);
                    tx1 = this.right - tl;
                    tx2 = borderValue - axisHalfWidth;
                    x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                    x2 = chartArea.right;
                } else if (position === "right") {
                    borderValue = alignBorderValue(this.left);
                    x1 = chartArea.left;
                    x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                    tx1 = borderValue + axisHalfWidth;
                    tx2 = this.left + tl;
                } else if (axis === "x") {
                    if (position === "center") borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + .5); else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
                    }
                    y1 = chartArea.top;
                    y2 = chartArea.bottom;
                    ty1 = borderValue + axisHalfWidth;
                    ty2 = ty1 + tl;
                } else if (axis === "y") {
                    if (position === "center") borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2); else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
                    }
                    tx1 = borderValue - axisHalfWidth;
                    tx2 = tx1 - tl;
                    x1 = chartArea.left;
                    x2 = chartArea.right;
                }
                const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
                const step = Math.max(1, Math.ceil(ticksLength / limit));
                for (i = 0; i < ticksLength; i += step) {
                    const context = this.getContext(i);
                    const optsAtIndex = grid.setContext(context);
                    const optsAtIndexBorder = border.setContext(context);
                    const lineWidth = optsAtIndex.lineWidth;
                    const lineColor = optsAtIndex.color;
                    const borderDash = optsAtIndexBorder.dash || [];
                    const borderDashOffset = optsAtIndexBorder.dashOffset;
                    const tickWidth = optsAtIndex.tickWidth;
                    const tickColor = optsAtIndex.tickColor;
                    const tickBorderDash = optsAtIndex.tickBorderDash || [];
                    const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
                    lineValue = getPixelForGridLine(this, i, offset);
                    if (lineValue === void 0) continue;
                    alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
                    if (isHorizontal) tx1 = tx2 = x1 = x2 = alignedLineValue; else ty1 = ty2 = y1 = y2 = alignedLineValue;
                    items.push({
                        tx1,
                        ty1,
                        tx2,
                        ty2,
                        x1,
                        y1,
                        x2,
                        y2,
                        width: lineWidth,
                        color: lineColor,
                        borderDash,
                        borderDashOffset,
                        tickWidth,
                        tickColor,
                        tickBorderDash,
                        tickBorderDashOffset
                    });
                }
                this._ticksLength = ticksLength;
                this._borderValue = borderValue;
                return items;
            }
            _computeLabelItems(chartArea) {
                const axis = this.axis;
                const options = this.options;
                const {position, ticks: optionTicks} = options;
                const isHorizontal = this.isHorizontal();
                const ticks = this.ticks;
                const {align, crossAlign, padding, mirror} = optionTicks;
                const tl = getTickMarkLength(options.grid);
                const tickAndPadding = tl + padding;
                const hTickAndPadding = mirror ? -padding : tickAndPadding;
                const rotation = -toRadians(this.labelRotation);
                const items = [];
                let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
                let textBaseline = "middle";
                if (position === "top") {
                    y = this.bottom - hTickAndPadding;
                    textAlign = this._getXAxisLabelAlignment();
                } else if (position === "bottom") {
                    y = this.top + hTickAndPadding;
                    textAlign = this._getXAxisLabelAlignment();
                } else if (position === "left") {
                    const ret = this._getYAxisLabelAlignment(tl);
                    textAlign = ret.textAlign;
                    x = ret.x;
                } else if (position === "right") {
                    const ret = this._getYAxisLabelAlignment(tl);
                    textAlign = ret.textAlign;
                    x = ret.x;
                } else if (axis === "x") {
                    if (position === "center") y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding; else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
                    }
                    textAlign = this._getXAxisLabelAlignment();
                } else if (axis === "y") {
                    if (position === "center") x = (chartArea.left + chartArea.right) / 2 - tickAndPadding; else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        x = this.chart.scales[positionAxisID].getPixelForValue(value);
                    }
                    textAlign = this._getYAxisLabelAlignment(tl).textAlign;
                }
                if (axis === "y") if (align === "start") textBaseline = "top"; else if (align === "end") textBaseline = "bottom";
                const labelSizes = this._getLabelSizes();
                for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                    tick = ticks[i];
                    label = tick.label;
                    const optsAtIndex = optionTicks.setContext(this.getContext(i));
                    pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
                    font = this._resolveTickFontOptions(i);
                    lineHeight = font.lineHeight;
                    lineCount = isArray(label) ? label.length : 1;
                    const halfCount = lineCount / 2;
                    const color = optsAtIndex.color;
                    const strokeColor = optsAtIndex.textStrokeColor;
                    const strokeWidth = optsAtIndex.textStrokeWidth;
                    let tickTextAlign = textAlign;
                    if (isHorizontal) {
                        x = pixel;
                        if (textAlign === "inner") if (i === ilen - 1) tickTextAlign = !this.options.reverse ? "right" : "left"; else if (i === 0) tickTextAlign = !this.options.reverse ? "left" : "right"; else tickTextAlign = "center";
                        if (position === "top") if (crossAlign === "near" || rotation !== 0) textOffset = -lineCount * lineHeight + lineHeight / 2; else if (crossAlign === "center") textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight; else textOffset = -labelSizes.highest.height + lineHeight / 2; else if (crossAlign === "near" || rotation !== 0) textOffset = lineHeight / 2; else if (crossAlign === "center") textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight; else textOffset = labelSizes.highest.height - lineCount * lineHeight;
                        if (mirror) textOffset *= -1;
                        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) x += lineHeight / 2 * Math.sin(rotation);
                    } else {
                        y = pixel;
                        textOffset = (1 - lineCount) * lineHeight / 2;
                    }
                    let backdrop;
                    if (optsAtIndex.showLabelBackdrop) {
                        const labelPadding = toPadding(optsAtIndex.backdropPadding);
                        const height = labelSizes.heights[i];
                        const width = labelSizes.widths[i];
                        let top = textOffset - labelPadding.top;
                        let left = 0 - labelPadding.left;
                        switch (textBaseline) {
                          case "middle":
                            top -= height / 2;
                            break;

                          case "bottom":
                            top -= height;
                            break;
                        }
                        switch (textAlign) {
                          case "center":
                            left -= width / 2;
                            break;

                          case "right":
                            left -= width;
                            break;
                        }
                        backdrop = {
                            left,
                            top,
                            width: width + labelPadding.width,
                            height: height + labelPadding.height,
                            color: optsAtIndex.backdropColor
                        };
                    }
                    items.push({
                        label,
                        font,
                        textOffset,
                        options: {
                            rotation,
                            color,
                            strokeColor,
                            strokeWidth,
                            textAlign: tickTextAlign,
                            textBaseline,
                            translation: [ x, y ],
                            backdrop
                        }
                    });
                }
                return items;
            }
            _getXAxisLabelAlignment() {
                const {position, ticks} = this.options;
                const rotation = -toRadians(this.labelRotation);
                if (rotation) return position === "top" ? "left" : "right";
                let align = "center";
                if (ticks.align === "start") align = "left"; else if (ticks.align === "end") align = "right"; else if (ticks.align === "inner") align = "inner";
                return align;
            }
            _getYAxisLabelAlignment(tl) {
                const {position, ticks: {crossAlign, mirror, padding}} = this.options;
                const labelSizes = this._getLabelSizes();
                const tickAndPadding = tl + padding;
                const widest = labelSizes.widest.width;
                let textAlign;
                let x;
                if (position === "left") if (mirror) {
                    x = this.right + padding;
                    if (crossAlign === "near") textAlign = "left"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x += widest / 2;
                    } else {
                        textAlign = "right";
                        x += widest;
                    }
                } else {
                    x = this.right - tickAndPadding;
                    if (crossAlign === "near") textAlign = "right"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x -= widest / 2;
                    } else {
                        textAlign = "left";
                        x = this.left;
                    }
                } else if (position === "right") if (mirror) {
                    x = this.left + padding;
                    if (crossAlign === "near") textAlign = "right"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x -= widest / 2;
                    } else {
                        textAlign = "left";
                        x -= widest;
                    }
                } else {
                    x = this.left + tickAndPadding;
                    if (crossAlign === "near") textAlign = "left"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x += widest / 2;
                    } else {
                        textAlign = "right";
                        x = this.right;
                    }
                } else textAlign = "right";
                return {
                    textAlign,
                    x
                };
            }
            _computeLabelArea() {
                if (this.options.ticks.mirror) return;
                const chart = this.chart;
                const position = this.options.position;
                if (position === "left" || position === "right") return {
                    top: 0,
                    left: this.left,
                    bottom: chart.height,
                    right: this.right
                };
                if (position === "top" || position === "bottom") return {
                    top: this.top,
                    left: 0,
                    bottom: this.bottom,
                    right: chart.width
                };
            }
            drawBackground() {
                const {ctx, options: {backgroundColor}, left, top, width, height} = this;
                if (backgroundColor) {
                    ctx.save();
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(left, top, width, height);
                    ctx.restore();
                }
            }
            getLineWidthForValue(value) {
                const grid = this.options.grid;
                if (!this._isVisible() || !grid.display) return 0;
                const ticks = this.ticks;
                const index = ticks.findIndex((t => t.value === value));
                if (index >= 0) {
                    const opts = grid.setContext(this.getContext(index));
                    return opts.lineWidth;
                }
                return 0;
            }
            drawGrid(chartArea) {
                const grid = this.options.grid;
                const ctx = this.ctx;
                const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
                let i, ilen;
                const drawLine = (p1, p2, style) => {
                    if (!style.width || !style.color) return;
                    ctx.save();
                    ctx.lineWidth = style.width;
                    ctx.strokeStyle = style.color;
                    ctx.setLineDash(style.borderDash || []);
                    ctx.lineDashOffset = style.borderDashOffset;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    ctx.restore();
                };
                if (grid.display) for (i = 0, ilen = items.length; i < ilen; ++i) {
                    const item = items[i];
                    if (grid.drawOnChartArea) drawLine({
                        x: item.x1,
                        y: item.y1
                    }, {
                        x: item.x2,
                        y: item.y2
                    }, item);
                    if (grid.drawTicks) drawLine({
                        x: item.tx1,
                        y: item.ty1
                    }, {
                        x: item.tx2,
                        y: item.ty2
                    }, {
                        color: item.tickColor,
                        width: item.tickWidth,
                        borderDash: item.tickBorderDash,
                        borderDashOffset: item.tickBorderDashOffset
                    });
                }
            }
            drawBorder() {
                const {chart, ctx, options: {border, grid}} = this;
                const borderOpts = border.setContext(this.getContext());
                const axisWidth = border.display ? borderOpts.width : 0;
                if (!axisWidth) return;
                const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
                const borderValue = this._borderValue;
                let x1, x2, y1, y2;
                if (this.isHorizontal()) {
                    x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
                    x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
                    y1 = y2 = borderValue;
                } else {
                    y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
                    y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
                    x1 = x2 = borderValue;
                }
                ctx.save();
                ctx.lineWidth = borderOpts.width;
                ctx.strokeStyle = borderOpts.color;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();
            }
            drawLabels(chartArea) {
                const optionTicks = this.options.ticks;
                if (!optionTicks.display) return;
                const ctx = this.ctx;
                const area = this._computeLabelArea();
                if (area) clipArea(ctx, area);
                const items = this.getLabelItems(chartArea);
                for (const item of items) {
                    const renderTextOptions = item.options;
                    const tickFont = item.font;
                    const label = item.label;
                    const y = item.textOffset;
                    renderText(ctx, label, 0, y, tickFont, renderTextOptions);
                }
                if (area) unclipArea(ctx);
            }
            drawTitle() {
                const {ctx, options: {position, title, reverse}} = this;
                if (!title.display) return;
                const font = toFont(title.font);
                const padding = toPadding(title.padding);
                const align = title.align;
                let offset = font.lineHeight / 2;
                if (position === "bottom" || position === "center" || helpers_segment_isObject(position)) {
                    offset += padding.bottom;
                    if (isArray(title.text)) offset += font.lineHeight * (title.text.length - 1);
                } else offset += padding.top;
                const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
                renderText(ctx, title.text, 0, 0, font, {
                    color: title.color,
                    maxWidth,
                    rotation,
                    textAlign: titleAlign(align, position, reverse),
                    textBaseline: "middle",
                    translation: [ titleX, titleY ]
                });
            }
            draw(chartArea) {
                if (!this._isVisible()) return;
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawBorder();
                this.drawTitle();
                this.drawLabels(chartArea);
            }
            _layers() {
                const opts = this.options;
                const tz = opts.ticks && opts.ticks.z || 0;
                const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
                const bz = valueOrDefault(opts.border && opts.border.z, 0);
                if (!this._isVisible() || this.draw !== Scale.prototype.draw) return [ {
                    z: tz,
                    draw: chartArea => {
                        this.draw(chartArea);
                    }
                } ];
                return [ {
                    z: gz,
                    draw: chartArea => {
                        this.drawBackground();
                        this.drawGrid(chartArea);
                        this.drawTitle();
                    }
                }, {
                    z: bz,
                    draw: () => {
                        this.drawBorder();
                    }
                }, {
                    z: tz,
                    draw: chartArea => {
                        this.drawLabels(chartArea);
                    }
                } ];
            }
            getMatchingVisibleMetas(type) {
                const metas = this.chart.getSortedVisibleDatasetMetas();
                const axisID = this.axis + "AxisID";
                const result = [];
                let i, ilen;
                for (i = 0, ilen = metas.length; i < ilen; ++i) {
                    const meta = metas[i];
                    if (meta[axisID] === this.id && (!type || meta.type === type)) result.push(meta);
                }
                return result;
            }
            _resolveTickFontOptions(index) {
                const opts = this.options.ticks.setContext(this.getContext(index));
                return toFont(opts.font);
            }
            _maxDigits() {
                const fontSize = this._resolveTickFontOptions(0).lineHeight;
                return (this.isHorizontal() ? this.width : this.height) / fontSize;
            }
        }
        class TypedRegistry {
            constructor(type, scope, override) {
                this.type = type;
                this.scope = scope;
                this.override = override;
                this.items = Object.create(null);
            }
            isForType(type) {
                return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
            }
            register(item) {
                const proto = Object.getPrototypeOf(item);
                let parentScope;
                if (isIChartComponent(proto)) parentScope = this.register(proto);
                const items = this.items;
                const id = item.id;
                const scope = this.scope + "." + id;
                if (!id) throw new Error("class does not have id: " + item);
                if (id in items) return scope;
                items[id] = item;
                registerDefaults(item, scope, parentScope);
                if (this.override) helpers_segment_defaults.override(item.id, item.overrides);
                return scope;
            }
            get(id) {
                return this.items[id];
            }
            unregister(item) {
                const items = this.items;
                const id = item.id;
                const scope = this.scope;
                if (id in items) delete items[id];
                if (scope && id in helpers_segment_defaults[scope]) {
                    delete helpers_segment_defaults[scope][id];
                    if (this.override) delete overrides[id];
                }
            }
        }
        function registerDefaults(item, scope, parentScope) {
            const itemDefaults = merge(Object.create(null), [ parentScope ? helpers_segment_defaults.get(parentScope) : {}, helpers_segment_defaults.get(scope), item.defaults ]);
            helpers_segment_defaults.set(scope, itemDefaults);
            if (item.defaultRoutes) routeDefaults(scope, item.defaultRoutes);
            if (item.descriptors) helpers_segment_defaults.describe(scope, item.descriptors);
        }
        function routeDefaults(scope, routes) {
            Object.keys(routes).forEach((property => {
                const propertyParts = property.split(".");
                const sourceName = propertyParts.pop();
                const sourceScope = [ scope ].concat(propertyParts).join(".");
                const parts = routes[property].split(".");
                const targetName = parts.pop();
                const targetScope = parts.join(".");
                helpers_segment_defaults.route(sourceScope, sourceName, targetScope, targetName);
            }));
        }
        function isIChartComponent(proto) {
            return "id" in proto && "defaults" in proto;
        }
        class Registry {
            constructor() {
                this.controllers = new TypedRegistry(DatasetController, "datasets", true);
                this.elements = new TypedRegistry(Element, "elements");
                this.plugins = new TypedRegistry(Object, "plugins");
                this.scales = new TypedRegistry(Scale, "scales");
                this._typedRegistries = [ this.controllers, this.scales, this.elements ];
            }
            add(...args) {
                this._each("register", args);
            }
            remove(...args) {
                this._each("unregister", args);
            }
            addControllers(...args) {
                this._each("register", args, this.controllers);
            }
            addElements(...args) {
                this._each("register", args, this.elements);
            }
            addPlugins(...args) {
                this._each("register", args, this.plugins);
            }
            addScales(...args) {
                this._each("register", args, this.scales);
            }
            getController(id) {
                return this._get(id, this.controllers, "controller");
            }
            getElement(id) {
                return this._get(id, this.elements, "element");
            }
            getPlugin(id) {
                return this._get(id, this.plugins, "plugin");
            }
            getScale(id) {
                return this._get(id, this.scales, "scale");
            }
            removeControllers(...args) {
                this._each("unregister", args, this.controllers);
            }
            removeElements(...args) {
                this._each("unregister", args, this.elements);
            }
            removePlugins(...args) {
                this._each("unregister", args, this.plugins);
            }
            removeScales(...args) {
                this._each("unregister", args, this.scales);
            }
            _each(method, args, typedRegistry) {
                [ ...args ].forEach((arg => {
                    const reg = typedRegistry || this._getRegistryForType(arg);
                    if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) this._exec(method, reg, arg); else each(arg, (item => {
                        const itemReg = typedRegistry || this._getRegistryForType(item);
                        this._exec(method, itemReg, item);
                    }));
                }));
            }
            _exec(method, registry, component) {
                const camelMethod = _capitalize(method);
                callback(component["before" + camelMethod], [], component);
                registry[method](component);
                callback(component["after" + camelMethod], [], component);
            }
            _getRegistryForType(type) {
                for (let i = 0; i < this._typedRegistries.length; i++) {
                    const reg = this._typedRegistries[i];
                    if (reg.isForType(type)) return reg;
                }
                return this.plugins;
            }
            _get(id, typedRegistry, type) {
                const item = typedRegistry.get(id);
                if (item === void 0) throw new Error('"' + id + '" is not a registered ' + type + ".");
                return item;
            }
        }
        var registry = new Registry;
        class PluginService {
            constructor() {
                this._init = [];
            }
            notify(chart, hook, args, filter) {
                if (hook === "beforeInit") {
                    this._init = this._createDescriptors(chart, true);
                    this._notify(this._init, chart, "install");
                }
                const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
                const result = this._notify(descriptors, chart, hook, args);
                if (hook === "afterDestroy") {
                    this._notify(descriptors, chart, "stop");
                    this._notify(this._init, chart, "uninstall");
                }
                return result;
            }
            _notify(descriptors, chart, hook, args) {
                args = args || {};
                for (const descriptor of descriptors) {
                    const plugin = descriptor.plugin;
                    const method = plugin[hook];
                    const params = [ chart, args, descriptor.options ];
                    if (callback(method, params, plugin) === false && args.cancelable) return false;
                }
                return true;
            }
            invalidate() {
                if (!isNullOrUndef(this._cache)) {
                    this._oldCache = this._cache;
                    this._cache = void 0;
                }
            }
            _descriptors(chart) {
                if (this._cache) return this._cache;
                const descriptors = this._cache = this._createDescriptors(chart);
                this._notifyStateChanges(chart);
                return descriptors;
            }
            _createDescriptors(chart, all) {
                const config = chart && chart.config;
                const options = valueOrDefault(config.options && config.options.plugins, {});
                const plugins = allPlugins(config);
                return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
            }
            _notifyStateChanges(chart) {
                const previousDescriptors = this._oldCache || [];
                const descriptors = this._cache;
                const diff = (a, b) => a.filter((x => !b.some((y => x.plugin.id === y.plugin.id))));
                this._notify(diff(previousDescriptors, descriptors), chart, "stop");
                this._notify(diff(descriptors, previousDescriptors), chart, "start");
            }
        }
        function allPlugins(config) {
            const localIds = {};
            const plugins = [];
            const keys = Object.keys(registry.plugins.items);
            for (let i = 0; i < keys.length; i++) plugins.push(registry.getPlugin(keys[i]));
            const local = config.plugins || [];
            for (let i = 0; i < local.length; i++) {
                const plugin = local[i];
                if (plugins.indexOf(plugin) === -1) {
                    plugins.push(plugin);
                    localIds[plugin.id] = true;
                }
            }
            return {
                plugins,
                localIds
            };
        }
        function getOpts(options, all) {
            if (!all && options === false) return null;
            if (options === true) return {};
            return options;
        }
        function createDescriptors(chart, {plugins, localIds}, options, all) {
            const result = [];
            const context = chart.getContext();
            for (const plugin of plugins) {
                const id = plugin.id;
                const opts = getOpts(options[id], all);
                if (opts === null) continue;
                result.push({
                    plugin,
                    options: pluginOpts(chart.config, {
                        plugin,
                        local: localIds[id]
                    }, opts, context)
                });
            }
            return result;
        }
        function pluginOpts(config, {plugin, local}, opts, context) {
            const keys = config.pluginScopeKeys(plugin);
            const scopes = config.getOptionScopes(opts, keys);
            if (local && plugin.defaults) scopes.push(plugin.defaults);
            return config.createResolver(scopes, context, [ "" ], {
                scriptable: false,
                indexable: false,
                allKeys: true
            });
        }
        function getIndexAxis(type, options) {
            const datasetDefaults = helpers_segment_defaults.datasets[type] || {};
            const datasetOptions = (options.datasets || {})[type] || {};
            return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
            let axis = id;
            if (id === "_index_") axis = indexAxis; else if (id === "_value_") axis = indexAxis === "x" ? "y" : "x";
            return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
            return axis === indexAxis ? "_index_" : "_value_";
        }
        function idMatchesAxis(id) {
            if (id === "x" || id === "y" || id === "r") return id;
        }
        function axisFromPosition(position) {
            if (position === "top" || position === "bottom") return "x";
            if (position === "left" || position === "right") return "y";
        }
        function determineAxis(id, ...scaleOptions) {
            if (idMatchesAxis(id)) return id;
            for (const opts of scaleOptions) {
                const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
                if (axis) return axis;
            }
            throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
        }
        function getAxisFromDataset(id, axis, dataset) {
            if (dataset[axis + "AxisID"] === id) return {
                axis
            };
        }
        function retrieveAxisFromDatasets(id, config) {
            if (config.data && config.data.datasets) {
                const boundDs = config.data.datasets.filter((d => d.xAxisID === id || d.yAxisID === id));
                if (boundDs.length) return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
            }
            return {};
        }
        function mergeScaleConfig(config, options) {
            const chartDefaults = overrides[config.type] || {
                scales: {}
            };
            const configScales = options.scales || {};
            const chartIndexAxis = getIndexAxis(config.type, options);
            const scales = Object.create(null);
            Object.keys(configScales).forEach((id => {
                const scaleConf = configScales[id];
                if (!helpers_segment_isObject(scaleConf)) return console.error(`Invalid scale configuration for scale: ${id}`);
                if (scaleConf._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
                const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), helpers_segment_defaults.scales[scaleConf.type]);
                const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
                const defaultScaleOptions = chartDefaults.scales || {};
                scales[id] = mergeIf(Object.create(null), [ {
                    axis
                }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId] ]);
            }));
            config.data.datasets.forEach((dataset => {
                const type = dataset.type || config.type;
                const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
                const datasetDefaults = overrides[type] || {};
                const defaultScaleOptions = datasetDefaults.scales || {};
                Object.keys(defaultScaleOptions).forEach((defaultID => {
                    const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
                    const id = dataset[axis + "AxisID"] || axis;
                    scales[id] = scales[id] || Object.create(null);
                    mergeIf(scales[id], [ {
                        axis
                    }, configScales[id], defaultScaleOptions[defaultID] ]);
                }));
            }));
            Object.keys(scales).forEach((key => {
                const scale = scales[key];
                mergeIf(scale, [ helpers_segment_defaults.scales[scale.type], helpers_segment_defaults.scale ]);
            }));
            return scales;
        }
        function initOptions(config) {
            const options = config.options || (config.options = {});
            options.plugins = valueOrDefault(options.plugins, {});
            options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
            data = data || {};
            data.datasets = data.datasets || [];
            data.labels = data.labels || [];
            return data;
        }
        function initConfig(config) {
            config = config || {};
            config.data = initData(config.data);
            initOptions(config);
            return config;
        }
        const keyCache = new Map;
        const keysCached = new Set;
        function cachedKeys(cacheKey, generate) {
            let keys = keyCache.get(cacheKey);
            if (!keys) {
                keys = generate();
                keyCache.set(cacheKey, keys);
                keysCached.add(keys);
            }
            return keys;
        }
        const addIfFound = (set, obj, key) => {
            const opts = resolveObjectKey(obj, key);
            if (opts !== void 0) set.add(opts);
        };
        class Config {
            constructor(config) {
                this._config = initConfig(config);
                this._scopeCache = new Map;
                this._resolverCache = new Map;
            }
            get platform() {
                return this._config.platform;
            }
            get type() {
                return this._config.type;
            }
            set type(type) {
                this._config.type = type;
            }
            get data() {
                return this._config.data;
            }
            set data(data) {
                this._config.data = initData(data);
            }
            get options() {
                return this._config.options;
            }
            set options(options) {
                this._config.options = options;
            }
            get plugins() {
                return this._config.plugins;
            }
            update() {
                const config = this._config;
                this.clearCache();
                initOptions(config);
            }
            clearCache() {
                this._scopeCache.clear();
                this._resolverCache.clear();
            }
            datasetScopeKeys(datasetType) {
                return cachedKeys(datasetType, (() => [ [ `datasets.${datasetType}`, "" ] ]));
            }
            datasetAnimationScopeKeys(datasetType, transition) {
                return cachedKeys(`${datasetType}.transition.${transition}`, (() => [ [ `datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}` ], [ `datasets.${datasetType}`, "" ] ]));
            }
            datasetElementScopeKeys(datasetType, elementType) {
                return cachedKeys(`${datasetType}-${elementType}`, (() => [ [ `datasets.${datasetType}.elements.${elementType}`, `datasets.${datasetType}`, `elements.${elementType}`, "" ] ]));
            }
            pluginScopeKeys(plugin) {
                const id = plugin.id;
                const type = this.type;
                return cachedKeys(`${type}-plugin-${id}`, (() => [ [ `plugins.${id}`, ...plugin.additionalOptionScopes || [] ] ]));
            }
            _cachedScopes(mainScope, resetCache) {
                const _scopeCache = this._scopeCache;
                let cache = _scopeCache.get(mainScope);
                if (!cache || resetCache) {
                    cache = new Map;
                    _scopeCache.set(mainScope, cache);
                }
                return cache;
            }
            getOptionScopes(mainScope, keyLists, resetCache) {
                const {options, type} = this;
                const cache = this._cachedScopes(mainScope, resetCache);
                const cached = cache.get(keyLists);
                if (cached) return cached;
                const scopes = new Set;
                keyLists.forEach((keys => {
                    if (mainScope) {
                        scopes.add(mainScope);
                        keys.forEach((key => addIfFound(scopes, mainScope, key)));
                    }
                    keys.forEach((key => addIfFound(scopes, options, key)));
                    keys.forEach((key => addIfFound(scopes, overrides[type] || {}, key)));
                    keys.forEach((key => addIfFound(scopes, helpers_segment_defaults, key)));
                    keys.forEach((key => addIfFound(scopes, descriptors, key)));
                }));
                const array = Array.from(scopes);
                if (array.length === 0) array.push(Object.create(null));
                if (keysCached.has(keyLists)) cache.set(keyLists, array);
                return array;
            }
            chartOptionScopes() {
                const {options, type} = this;
                return [ options, overrides[type] || {}, helpers_segment_defaults.datasets[type] || {}, {
                    type
                }, helpers_segment_defaults, descriptors ];
            }
            resolveNamedOptions(scopes, names, context, prefixes = [ "" ]) {
                const result = {
                    $shared: true
                };
                const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
                let options = resolver;
                if (needContext(resolver, names)) {
                    result.$shared = false;
                    context = isFunction(context) ? context() : context;
                    const subResolver = this.createResolver(scopes, context, subPrefixes);
                    options = _attachContext(resolver, context, subResolver);
                }
                for (const prop of names) result[prop] = options[prop];
                return result;
            }
            createResolver(scopes, context, prefixes = [ "" ], descriptorDefaults) {
                const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
                return helpers_segment_isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
            }
        }
        function getResolver(resolverCache, scopes, prefixes) {
            let cache = resolverCache.get(scopes);
            if (!cache) {
                cache = new Map;
                resolverCache.set(scopes, cache);
            }
            const cacheKey = prefixes.join();
            let cached = cache.get(cacheKey);
            if (!cached) {
                const resolver = _createResolver(scopes, prefixes);
                cached = {
                    resolver,
                    subPrefixes: prefixes.filter((p => !p.toLowerCase().includes("hover")))
                };
                cache.set(cacheKey, cached);
            }
            return cached;
        }
        const hasFunction = value => helpers_segment_isObject(value) && Object.getOwnPropertyNames(value).reduce(((acc, key) => acc || isFunction(value[key])), false);
        function needContext(proxy, names) {
            const {isScriptable, isIndexable} = _descriptors(proxy);
            for (const prop of names) {
                const scriptable = isScriptable(prop);
                const indexable = isIndexable(prop);
                const value = (indexable || scriptable) && proxy[prop];
                if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) return true;
            }
            return false;
        }
        var version = "4.4.0";
        const KNOWN_POSITIONS = [ "top", "bottom", "left", "right", "chartArea" ];
        function positionIsHorizontal(position, axis) {
            return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
        }
        function compare2Level(l1, l2) {
            return function(a, b) {
                return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
            };
        }
        function onAnimationsComplete(context) {
            const chart = context.chart;
            const animationOptions = chart.options.animation;
            chart.notifyPlugins("afterRender");
            callback(animationOptions && animationOptions.onComplete, [ context ], chart);
        }
        function onAnimationProgress(context) {
            const chart = context.chart;
            const animationOptions = chart.options.animation;
            callback(animationOptions && animationOptions.onProgress, [ context ], chart);
        }
        function getCanvas(item) {
            if (_isDomSupported() && typeof item === "string") item = document.getElementById(item); else if (item && item.length) item = item[0];
            if (item && item.canvas) item = item.canvas;
            return item;
        }
        const instances = {};
        const getChart = key => {
            const canvas = getCanvas(key);
            return Object.values(instances).filter((c => c.canvas === canvas)).pop();
        };
        function moveNumericKeys(obj, start, move) {
            const keys = Object.keys(obj);
            for (const key of keys) {
                const intKey = +key;
                if (intKey >= start) {
                    const value = obj[key];
                    delete obj[key];
                    if (move > 0 || intKey > start) obj[intKey + move] = value;
                }
            }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
            if (!inChartArea || e.type === "mouseout") return null;
            if (isClick) return lastEvent;
            return e;
        }
        function getSizeForArea(scale, chartArea, field) {
            return scale.options.clip ? scale[field] : chartArea[field];
        }
        function getDatasetArea(meta, chartArea) {
            const {xScale, yScale} = meta;
            if (xScale && yScale) return {
                left: getSizeForArea(xScale, chartArea, "left"),
                right: getSizeForArea(xScale, chartArea, "right"),
                top: getSizeForArea(yScale, chartArea, "top"),
                bottom: getSizeForArea(yScale, chartArea, "bottom")
            };
            return chartArea;
        }
        class chart_Chart {
            static defaults=helpers_segment_defaults;
            static instances=instances;
            static overrides=overrides;
            static registry=registry;
            static version=version;
            static getChart=getChart;
            static register(...items) {
                registry.add(...items);
                invalidatePlugins();
            }
            static unregister(...items) {
                registry.remove(...items);
                invalidatePlugins();
            }
            constructor(item, userConfig) {
                const config = this.config = new Config(userConfig);
                const initialCanvas = getCanvas(item);
                const existingChart = getChart(initialCanvas);
                if (existingChart) throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "'" + " must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
                const options = config.createResolver(config.chartOptionScopes(), this.getContext());
                this.platform = new (config.platform || _detectPlatform(initialCanvas));
                this.platform.updateConfig(config);
                const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
                const canvas = context && context.canvas;
                const height = canvas && canvas.height;
                const width = canvas && canvas.width;
                this.id = uid();
                this.ctx = context;
                this.canvas = canvas;
                this.width = width;
                this.height = height;
                this._options = options;
                this._aspectRatio = this.aspectRatio;
                this._layers = [];
                this._metasets = [];
                this._stacks = void 0;
                this.boxes = [];
                this.currentDevicePixelRatio = void 0;
                this.chartArea = void 0;
                this._active = [];
                this._lastEvent = void 0;
                this._listeners = {};
                this._responsiveListeners = void 0;
                this._sortedMetasets = [];
                this.scales = {};
                this._plugins = new PluginService;
                this.$proxies = {};
                this._hiddenIndices = {};
                this.attached = false;
                this._animationsDisabled = void 0;
                this.$context = void 0;
                this._doResize = debounce((mode => this.update(mode)), options.resizeDelay || 0);
                this._dataChanges = [];
                instances[this.id] = this;
                if (!context || !canvas) {
                    console.error("Failed to create chart: can't acquire context from the given item");
                    return;
                }
                animator.listen(this, "complete", onAnimationsComplete);
                animator.listen(this, "progress", onAnimationProgress);
                this._initialize();
                if (this.attached) this.update();
            }
            get aspectRatio() {
                const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
                if (!isNullOrUndef(aspectRatio)) return aspectRatio;
                if (maintainAspectRatio && _aspectRatio) return _aspectRatio;
                return height ? width / height : null;
            }
            get data() {
                return this.config.data;
            }
            set data(data) {
                this.config.data = data;
            }
            get options() {
                return this._options;
            }
            set options(options) {
                this.config.options = options;
            }
            get registry() {
                return registry;
            }
            _initialize() {
                this.notifyPlugins("beforeInit");
                if (this.options.responsive) this.resize(); else retinaScale(this, this.options.devicePixelRatio);
                this.bindEvents();
                this.notifyPlugins("afterInit");
                return this;
            }
            clear() {
                clearCanvas(this.canvas, this.ctx);
                return this;
            }
            stop() {
                animator.stop(this);
                return this;
            }
            resize(width, height) {
                if (!animator.running(this)) this._resize(width, height); else this._resizeBeforeDraw = {
                    width,
                    height
                };
            }
            _resize(width, height) {
                const options = this.options;
                const canvas = this.canvas;
                const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
                const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
                const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
                const mode = this.width ? "resize" : "attach";
                this.width = newSize.width;
                this.height = newSize.height;
                this._aspectRatio = this.aspectRatio;
                if (!retinaScale(this, newRatio, true)) return;
                this.notifyPlugins("resize", {
                    size: newSize
                });
                callback(options.onResize, [ this, newSize ], this);
                if (this.attached) if (this._doResize(mode)) this.render();
            }
            ensureScalesHaveIDs() {
                const options = this.options;
                const scalesOptions = options.scales || {};
                each(scalesOptions, ((axisOptions, axisID) => {
                    axisOptions.id = axisID;
                }));
            }
            buildOrUpdateScales() {
                const options = this.options;
                const scaleOpts = options.scales;
                const scales = this.scales;
                const updated = Object.keys(scales).reduce(((obj, id) => {
                    obj[id] = false;
                    return obj;
                }), {});
                let items = [];
                if (scaleOpts) items = items.concat(Object.keys(scaleOpts).map((id => {
                    const scaleOptions = scaleOpts[id];
                    const axis = determineAxis(id, scaleOptions);
                    const isRadial = axis === "r";
                    const isHorizontal = axis === "x";
                    return {
                        options: scaleOptions,
                        dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                        dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                    };
                })));
                each(items, (item => {
                    const scaleOptions = item.options;
                    const id = scaleOptions.id;
                    const axis = determineAxis(id, scaleOptions);
                    const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
                    if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) scaleOptions.position = item.dposition;
                    updated[id] = true;
                    let scale = null;
                    if (id in scales && scales[id].type === scaleType) scale = scales[id]; else {
                        const scaleClass = registry.getScale(scaleType);
                        scale = new scaleClass({
                            id,
                            type: scaleType,
                            ctx: this.ctx,
                            chart: this
                        });
                        scales[scale.id] = scale;
                    }
                    scale.init(scaleOptions, options);
                }));
                each(updated, ((hasUpdated, id) => {
                    if (!hasUpdated) delete scales[id];
                }));
                each(scales, (scale => {
                    layouts.configure(this, scale, scale.options);
                    layouts.addBox(this, scale);
                }));
            }
            _updateMetasets() {
                const metasets = this._metasets;
                const numData = this.data.datasets.length;
                const numMeta = metasets.length;
                metasets.sort(((a, b) => a.index - b.index));
                if (numMeta > numData) {
                    for (let i = numData; i < numMeta; ++i) this._destroyDatasetMeta(i);
                    metasets.splice(numData, numMeta - numData);
                }
                this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
            }
            _removeUnreferencedMetasets() {
                const {_metasets: metasets, data: {datasets}} = this;
                if (metasets.length > datasets.length) delete this._stacks;
                metasets.forEach(((meta, index) => {
                    if (datasets.filter((x => x === meta._dataset)).length === 0) this._destroyDatasetMeta(index);
                }));
            }
            buildOrUpdateControllers() {
                const newControllers = [];
                const datasets = this.data.datasets;
                let i, ilen;
                this._removeUnreferencedMetasets();
                for (i = 0, ilen = datasets.length; i < ilen; i++) {
                    const dataset = datasets[i];
                    let meta = this.getDatasetMeta(i);
                    const type = dataset.type || this.config.type;
                    if (meta.type && meta.type !== type) {
                        this._destroyDatasetMeta(i);
                        meta = this.getDatasetMeta(i);
                    }
                    meta.type = type;
                    meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
                    meta.order = dataset.order || 0;
                    meta.index = i;
                    meta.label = "" + dataset.label;
                    meta.visible = this.isDatasetVisible(i);
                    if (meta.controller) {
                        meta.controller.updateIndex(i);
                        meta.controller.linkScales();
                    } else {
                        const ControllerClass = registry.getController(type);
                        const {datasetElementType, dataElementType} = helpers_segment_defaults.datasets[type];
                        Object.assign(ControllerClass, {
                            dataElementType: registry.getElement(dataElementType),
                            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                        });
                        meta.controller = new ControllerClass(this, i);
                        newControllers.push(meta.controller);
                    }
                }
                this._updateMetasets();
                return newControllers;
            }
            _resetElements() {
                each(this.data.datasets, ((dataset, datasetIndex) => {
                    this.getDatasetMeta(datasetIndex).controller.reset();
                }), this);
            }
            reset() {
                this._resetElements();
                this.notifyPlugins("reset");
            }
            update(mode) {
                const config = this.config;
                config.update();
                const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
                const animsDisabled = this._animationsDisabled = !options.animation;
                this._updateScales();
                this._checkEventBindings();
                this._updateHiddenIndices();
                this._plugins.invalidate();
                if (this.notifyPlugins("beforeUpdate", {
                    mode,
                    cancelable: true
                }) === false) return;
                const newControllers = this.buildOrUpdateControllers();
                this.notifyPlugins("beforeElementsUpdate");
                let minPadding = 0;
                for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
                    const {controller} = this.getDatasetMeta(i);
                    const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
                    controller.buildOrUpdateElements(reset);
                    minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
                }
                minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
                this._updateLayout(minPadding);
                if (!animsDisabled) each(newControllers, (controller => {
                    controller.reset();
                }));
                this._updateDatasets(mode);
                this.notifyPlugins("afterUpdate", {
                    mode
                });
                this._layers.sort(compare2Level("z", "_idx"));
                const {_active, _lastEvent} = this;
                if (_lastEvent) this._eventHandler(_lastEvent, true); else if (_active.length) this._updateHoverStyles(_active, _active, true);
                this.render();
            }
            _updateScales() {
                each(this.scales, (scale => {
                    layouts.removeBox(this, scale);
                }));
                this.ensureScalesHaveIDs();
                this.buildOrUpdateScales();
            }
            _checkEventBindings() {
                const options = this.options;
                const existingEvents = new Set(Object.keys(this._listeners));
                const newEvents = new Set(options.events);
                if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
                    this.unbindEvents();
                    this.bindEvents();
                }
            }
            _updateHiddenIndices() {
                const {_hiddenIndices} = this;
                const changes = this._getUniformDataChanges() || [];
                for (const {method, start, count} of changes) {
                    const move = method === "_removeElements" ? -count : count;
                    moveNumericKeys(_hiddenIndices, start, move);
                }
            }
            _getUniformDataChanges() {
                const _dataChanges = this._dataChanges;
                if (!_dataChanges || !_dataChanges.length) return;
                this._dataChanges = [];
                const datasetCount = this.data.datasets.length;
                const makeSet = idx => new Set(_dataChanges.filter((c => c[0] === idx)).map(((c, i) => i + "," + c.splice(1).join(","))));
                const changeSet = makeSet(0);
                for (let i = 1; i < datasetCount; i++) if (!setsEqual(changeSet, makeSet(i))) return;
                return Array.from(changeSet).map((c => c.split(","))).map((a => ({
                    method: a[1],
                    start: +a[2],
                    count: +a[3]
                })));
            }
            _updateLayout(minPadding) {
                if (this.notifyPlugins("beforeLayout", {
                    cancelable: true
                }) === false) return;
                layouts.update(this, this.width, this.height, minPadding);
                const area = this.chartArea;
                const noArea = area.width <= 0 || area.height <= 0;
                this._layers = [];
                each(this.boxes, (box => {
                    if (noArea && box.position === "chartArea") return;
                    if (box.configure) box.configure();
                    this._layers.push(...box._layers());
                }), this);
                this._layers.forEach(((item, index) => {
                    item._idx = index;
                }));
                this.notifyPlugins("afterLayout");
            }
            _updateDatasets(mode) {
                if (this.notifyPlugins("beforeDatasetsUpdate", {
                    mode,
                    cancelable: true
                }) === false) return;
                for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this.getDatasetMeta(i).controller.configure();
                for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this._updateDataset(i, isFunction(mode) ? mode({
                    datasetIndex: i
                }) : mode);
                this.notifyPlugins("afterDatasetsUpdate", {
                    mode
                });
            }
            _updateDataset(index, mode) {
                const meta = this.getDatasetMeta(index);
                const args = {
                    meta,
                    index,
                    mode,
                    cancelable: true
                };
                if (this.notifyPlugins("beforeDatasetUpdate", args) === false) return;
                meta.controller._update(mode);
                args.cancelable = false;
                this.notifyPlugins("afterDatasetUpdate", args);
            }
            render() {
                if (this.notifyPlugins("beforeRender", {
                    cancelable: true
                }) === false) return;
                if (animator.has(this)) {
                    if (this.attached && !animator.running(this)) animator.start(this);
                } else {
                    this.draw();
                    onAnimationsComplete({
                        chart: this
                    });
                }
            }
            draw() {
                let i;
                if (this._resizeBeforeDraw) {
                    const {width, height} = this._resizeBeforeDraw;
                    this._resize(width, height);
                    this._resizeBeforeDraw = null;
                }
                this.clear();
                if (this.width <= 0 || this.height <= 0) return;
                if (this.notifyPlugins("beforeDraw", {
                    cancelable: true
                }) === false) return;
                const layers = this._layers;
                for (i = 0; i < layers.length && layers[i].z <= 0; ++i) layers[i].draw(this.chartArea);
                this._drawDatasets();
                for (;i < layers.length; ++i) layers[i].draw(this.chartArea);
                this.notifyPlugins("afterDraw");
            }
            _getSortedDatasetMetas(filterVisible) {
                const metasets = this._sortedMetasets;
                const result = [];
                let i, ilen;
                for (i = 0, ilen = metasets.length; i < ilen; ++i) {
                    const meta = metasets[i];
                    if (!filterVisible || meta.visible) result.push(meta);
                }
                return result;
            }
            getSortedVisibleDatasetMetas() {
                return this._getSortedDatasetMetas(true);
            }
            _drawDatasets() {
                if (this.notifyPlugins("beforeDatasetsDraw", {
                    cancelable: true
                }) === false) return;
                const metasets = this.getSortedVisibleDatasetMetas();
                for (let i = metasets.length - 1; i >= 0; --i) this._drawDataset(metasets[i]);
                this.notifyPlugins("afterDatasetsDraw");
            }
            _drawDataset(meta) {
                const ctx = this.ctx;
                const clip = meta._clip;
                const useClip = !clip.disabled;
                const area = getDatasetArea(meta, this.chartArea);
                const args = {
                    meta,
                    index: meta.index,
                    cancelable: true
                };
                if (this.notifyPlugins("beforeDatasetDraw", args) === false) return;
                if (useClip) clipArea(ctx, {
                    left: clip.left === false ? 0 : area.left - clip.left,
                    right: clip.right === false ? this.width : area.right + clip.right,
                    top: clip.top === false ? 0 : area.top - clip.top,
                    bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
                });
                meta.controller.draw();
                if (useClip) unclipArea(ctx);
                args.cancelable = false;
                this.notifyPlugins("afterDatasetDraw", args);
            }
            isPointInArea(point) {
                return _isPointInArea(point, this.chartArea, this._minPadding);
            }
            getElementsAtEventForMode(e, mode, options, useFinalPosition) {
                const method = Interaction.modes[mode];
                if (typeof method === "function") return method(this, e, options, useFinalPosition);
                return [];
            }
            getDatasetMeta(datasetIndex) {
                const dataset = this.data.datasets[datasetIndex];
                const metasets = this._metasets;
                let meta = metasets.filter((x => x && x._dataset === dataset)).pop();
                if (!meta) {
                    meta = {
                        type: null,
                        data: [],
                        dataset: null,
                        controller: null,
                        hidden: null,
                        xAxisID: null,
                        yAxisID: null,
                        order: dataset && dataset.order || 0,
                        index: datasetIndex,
                        _dataset: dataset,
                        _parsed: [],
                        _sorted: false
                    };
                    metasets.push(meta);
                }
                return meta;
            }
            getContext() {
                return this.$context || (this.$context = createContext(null, {
                    chart: this,
                    type: "chart"
                }));
            }
            getVisibleDatasetCount() {
                return this.getSortedVisibleDatasetMetas().length;
            }
            isDatasetVisible(datasetIndex) {
                const dataset = this.data.datasets[datasetIndex];
                if (!dataset) return false;
                const meta = this.getDatasetMeta(datasetIndex);
                return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
            }
            setDatasetVisibility(datasetIndex, visible) {
                const meta = this.getDatasetMeta(datasetIndex);
                meta.hidden = !visible;
            }
            toggleDataVisibility(index) {
                this._hiddenIndices[index] = !this._hiddenIndices[index];
            }
            getDataVisibility(index) {
                return !this._hiddenIndices[index];
            }
            _updateVisibility(datasetIndex, dataIndex, visible) {
                const mode = visible ? "show" : "hide";
                const meta = this.getDatasetMeta(datasetIndex);
                const anims = meta.controller._resolveAnimations(void 0, mode);
                if (defined(dataIndex)) {
                    meta.data[dataIndex].hidden = !visible;
                    this.update();
                } else {
                    this.setDatasetVisibility(datasetIndex, visible);
                    anims.update(meta, {
                        visible
                    });
                    this.update((ctx => ctx.datasetIndex === datasetIndex ? mode : void 0));
                }
            }
            hide(datasetIndex, dataIndex) {
                this._updateVisibility(datasetIndex, dataIndex, false);
            }
            show(datasetIndex, dataIndex) {
                this._updateVisibility(datasetIndex, dataIndex, true);
            }
            _destroyDatasetMeta(datasetIndex) {
                const meta = this._metasets[datasetIndex];
                if (meta && meta.controller) meta.controller._destroy();
                delete this._metasets[datasetIndex];
            }
            _stop() {
                let i, ilen;
                this.stop();
                animator.remove(this);
                for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this._destroyDatasetMeta(i);
            }
            destroy() {
                this.notifyPlugins("beforeDestroy");
                const {canvas, ctx} = this;
                this._stop();
                this.config.clearCache();
                if (canvas) {
                    this.unbindEvents();
                    clearCanvas(canvas, ctx);
                    this.platform.releaseContext(ctx);
                    this.canvas = null;
                    this.ctx = null;
                }
                delete instances[this.id];
                this.notifyPlugins("afterDestroy");
            }
            toBase64Image(...args) {
                return this.canvas.toDataURL(...args);
            }
            bindEvents() {
                this.bindUserEvents();
                if (this.options.responsive) this.bindResponsiveEvents(); else this.attached = true;
            }
            bindUserEvents() {
                const listeners = this._listeners;
                const platform = this.platform;
                const _add = (type, listener) => {
                    platform.addEventListener(this, type, listener);
                    listeners[type] = listener;
                };
                const listener = (e, x, y) => {
                    e.offsetX = x;
                    e.offsetY = y;
                    this._eventHandler(e);
                };
                each(this.options.events, (type => _add(type, listener)));
            }
            bindResponsiveEvents() {
                if (!this._responsiveListeners) this._responsiveListeners = {};
                const listeners = this._responsiveListeners;
                const platform = this.platform;
                const _add = (type, listener) => {
                    platform.addEventListener(this, type, listener);
                    listeners[type] = listener;
                };
                const _remove = (type, listener) => {
                    if (listeners[type]) {
                        platform.removeEventListener(this, type, listener);
                        delete listeners[type];
                    }
                };
                const listener = (width, height) => {
                    if (this.canvas) this.resize(width, height);
                };
                let detached;
                const attached = () => {
                    _remove("attach", attached);
                    this.attached = true;
                    this.resize();
                    _add("resize", listener);
                    _add("detach", detached);
                };
                detached = () => {
                    this.attached = false;
                    _remove("resize", listener);
                    this._stop();
                    this._resize(0, 0);
                    _add("attach", attached);
                };
                if (platform.isAttached(this.canvas)) attached(); else detached();
            }
            unbindEvents() {
                each(this._listeners, ((listener, type) => {
                    this.platform.removeEventListener(this, type, listener);
                }));
                this._listeners = {};
                each(this._responsiveListeners, ((listener, type) => {
                    this.platform.removeEventListener(this, type, listener);
                }));
                this._responsiveListeners = void 0;
            }
            updateHoverStyle(items, mode, enabled) {
                const prefix = enabled ? "set" : "remove";
                let meta, item, i, ilen;
                if (mode === "dataset") {
                    meta = this.getDatasetMeta(items[0].datasetIndex);
                    meta.controller["_" + prefix + "DatasetHoverStyle"]();
                }
                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    item = items[i];
                    const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
                    if (controller) controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
                }
            }
            getActiveElements() {
                return this._active || [];
            }
            setActiveElements(activeElements) {
                const lastActive = this._active || [];
                const active = activeElements.map((({datasetIndex, index}) => {
                    const meta = this.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("No dataset found at index " + datasetIndex);
                    return {
                        datasetIndex,
                        element: meta.data[index],
                        index
                    };
                }));
                const changed = !_elementsEqual(active, lastActive);
                if (changed) {
                    this._active = active;
                    this._lastEvent = null;
                    this._updateHoverStyles(active, lastActive);
                }
            }
            notifyPlugins(hook, args, filter) {
                return this._plugins.notify(this, hook, args, filter);
            }
            isPluginEnabled(pluginId) {
                return this._plugins._cache.filter((p => p.plugin.id === pluginId)).length === 1;
            }
            _updateHoverStyles(active, lastActive, replay) {
                const hoverOptions = this.options.hover;
                const diff = (a, b) => a.filter((x => !b.some((y => x.datasetIndex === y.datasetIndex && x.index === y.index))));
                const deactivated = diff(lastActive, active);
                const activated = replay ? active : diff(active, lastActive);
                if (deactivated.length) this.updateHoverStyle(deactivated, hoverOptions.mode, false);
                if (activated.length && hoverOptions.mode) this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
            _eventHandler(e, replay) {
                const args = {
                    event: e,
                    replay,
                    cancelable: true,
                    inChartArea: this.isPointInArea(e)
                };
                const eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.native.type);
                if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) return;
                const changed = this._handleEvent(e, replay, args.inChartArea);
                args.cancelable = false;
                this.notifyPlugins("afterEvent", args, eventFilter);
                if (changed || args.changed) this.render();
                return this;
            }
            _handleEvent(e, replay, inChartArea) {
                const {_active: lastActive = [], options} = this;
                const useFinalPosition = replay;
                const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
                const isClick = _isClickEvent(e);
                const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
                if (inChartArea) {
                    this._lastEvent = null;
                    callback(options.onHover, [ e, active, this ], this);
                    if (isClick) callback(options.onClick, [ e, active, this ], this);
                }
                const changed = !_elementsEqual(active, lastActive);
                if (changed || replay) {
                    this._active = active;
                    this._updateHoverStyles(active, lastActive, replay);
                }
                this._lastEvent = lastEvent;
                return changed;
            }
            _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
                if (e.type === "mouseout") return [];
                if (!inChartArea) return lastActive;
                const hoverOptions = this.options.hover;
                return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
            }
        }
        function invalidatePlugins() {
            return each(chart_Chart.instances, (chart => chart._plugins.invalidate()));
        }
        function clipArc(ctx, element, endAngle) {
            const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
            let angleMargin = pixelMargin / outerRadius;
            ctx.beginPath();
            ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
            if (innerRadius > pixelMargin) {
                angleMargin = pixelMargin / innerRadius;
                ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
            } else ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
            ctx.closePath();
            ctx.clip();
        }
        function toRadiusCorners(value) {
            return _readValueToProps(value, [ "outerStart", "outerEnd", "innerStart", "innerEnd" ]);
        }
        function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
            const o = toRadiusCorners(arc.options.borderRadius);
            const halfThickness = (outerRadius - innerRadius) / 2;
            const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
            const computeOuterLimit = val => {
                const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
                return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
            };
            return {
                outerStart: computeOuterLimit(o.outerStart),
                outerEnd: computeOuterLimit(o.outerEnd),
                innerStart: _limitValue(o.innerStart, 0, innerLimit),
                innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
            };
        }
        function rThetaToXY(r, theta, x, y) {
            return {
                x: x + r * Math.cos(theta),
                y: y + r * Math.sin(theta)
            };
        }
        function pathArc(ctx, element, offset, spacing, end, circular) {
            const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;
            const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
            const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
            let spacingOffset = 0;
            const alpha = end - start;
            if (spacing) {
                const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
                const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
                const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
                const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
                spacingOffset = (alpha - adjustedAngle) / 2;
            }
            const beta = Math.max(.001, alpha * outerRadius - offset / PI) / outerRadius;
            const angleOffset = (alpha - beta) / 2;
            const startAngle = start + angleOffset + spacingOffset;
            const endAngle = end - angleOffset - spacingOffset;
            const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
            const outerStartAdjustedRadius = outerRadius - outerStart;
            const outerEndAdjustedRadius = outerRadius - outerEnd;
            const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
            const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
            const innerStartAdjustedRadius = innerRadius + innerStart;
            const innerEndAdjustedRadius = innerRadius + innerEnd;
            const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
            const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
            ctx.beginPath();
            if (circular) {
                const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
                ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
                ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
                if (outerEnd > 0) {
                    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
                }
                const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
                ctx.lineTo(p4.x, p4.y);
                if (innerEnd > 0) {
                    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
                }
                const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
                ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
                ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
                if (innerStart > 0) {
                    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
                }
                const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
                ctx.lineTo(p8.x, p8.y);
                if (outerStart > 0) {
                    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
                }
            } else {
                ctx.moveTo(x, y);
                const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
                const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
                ctx.lineTo(outerStartX, outerStartY);
                const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
                const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
                ctx.lineTo(outerEndX, outerEndY);
            }
            ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing, circular) {
            const {fullCircles, startAngle, circumference} = element;
            let endAngle = element.endAngle;
            if (fullCircles) {
                pathArc(ctx, element, offset, spacing, endAngle, circular);
                for (let i = 0; i < fullCircles; ++i) ctx.fill();
                if (!isNaN(circumference)) endAngle = startAngle + (circumference % TAU || TAU);
            }
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            ctx.fill();
            return endAngle;
        }
        function drawBorder(ctx, element, offset, spacing, circular) {
            const {fullCircles, startAngle, circumference, options} = element;
            const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;
            const inner = options.borderAlign === "inner";
            if (!borderWidth) return;
            ctx.setLineDash(borderDash || []);
            ctx.lineDashOffset = borderDashOffset;
            if (inner) {
                ctx.lineWidth = borderWidth * 2;
                ctx.lineJoin = borderJoinStyle || "round";
            } else {
                ctx.lineWidth = borderWidth;
                ctx.lineJoin = borderJoinStyle || "bevel";
            }
            let endAngle = element.endAngle;
            if (fullCircles) {
                pathArc(ctx, element, offset, spacing, endAngle, circular);
                for (let i = 0; i < fullCircles; ++i) ctx.stroke();
                if (!isNaN(circumference)) endAngle = startAngle + (circumference % TAU || TAU);
            }
            if (inner) clipArc(ctx, element, endAngle);
            if (!fullCircles) {
                pathArc(ctx, element, offset, spacing, endAngle, circular);
                ctx.stroke();
            }
        }
        class ArcElement extends Element {
            static id="arc";
            static defaults={
                borderAlign: "center",
                borderColor: "#fff",
                borderDash: [],
                borderDashOffset: 0,
                borderJoinStyle: void 0,
                borderRadius: 0,
                borderWidth: 2,
                offset: 0,
                spacing: 0,
                angle: void 0,
                circular: true
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor"
            };
            static descriptors={
                _scriptable: true,
                _indexable: name => name !== "borderDash"
            };
            circumference;
            endAngle;
            fullCircles;
            innerRadius;
            outerRadius;
            pixelMargin;
            startAngle;
            constructor(cfg) {
                super();
                this.options = void 0;
                this.circumference = void 0;
                this.startAngle = void 0;
                this.endAngle = void 0;
                this.innerRadius = void 0;
                this.outerRadius = void 0;
                this.pixelMargin = 0;
                this.fullCircles = 0;
                if (cfg) Object.assign(this, cfg);
            }
            inRange(chartX, chartY, useFinalPosition) {
                const point = this.getProps([ "x", "y" ], useFinalPosition);
                const {angle, distance} = getAngleFromPoint(point, {
                    x: chartX,
                    y: chartY
                });
                const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([ "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference" ], useFinalPosition);
                const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
                const _circumference = valueOrDefault(circumference, endAngle - startAngle);
                const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
                const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
                return betweenAngles && withinRadius;
            }
            getCenterPoint(useFinalPosition) {
                const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([ "x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius" ], useFinalPosition);
                const {offset, spacing} = this.options;
                const halfAngle = (startAngle + endAngle) / 2;
                const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
                return {
                    x: x + Math.cos(halfAngle) * halfRadius,
                    y: y + Math.sin(halfAngle) * halfRadius
                };
            }
            tooltipPosition(useFinalPosition) {
                return this.getCenterPoint(useFinalPosition);
            }
            draw(ctx) {
                const {options, circumference} = this;
                const offset = (options.offset || 0) / 4;
                const spacing = (options.spacing || 0) / 2;
                const circular = options.circular;
                this.pixelMargin = options.borderAlign === "inner" ? .33 : 0;
                this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
                if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;
                ctx.save();
                const halfAngle = (this.startAngle + this.endAngle) / 2;
                ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
                const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
                const radiusOffset = offset * fix;
                ctx.fillStyle = options.backgroundColor;
                ctx.strokeStyle = options.borderColor;
                drawArc(ctx, this, radiusOffset, spacing, circular);
                drawBorder(ctx, this, radiusOffset, spacing, circular);
                ctx.restore();
            }
        }
        function setStyle(ctx, options, style = options) {
            ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
            ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
            ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
            ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
            ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
            ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
        }
        function lineTo(ctx, previous, target) {
            ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
            if (options.stepped) return _steppedLineTo;
            if (options.tension || options.cubicInterpolationMode === "monotone") return _bezierCurveTo;
            return lineTo;
        }
        function pathVars(points, segment, params = {}) {
            const count = points.length;
            const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
            const {start: segmentStart, end: segmentEnd} = segment;
            const start = Math.max(paramsStart, segmentStart);
            const end = Math.min(paramsEnd, segmentEnd);
            const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
            return {
                count,
                start,
                loop: segment.loop,
                ilen: end < start && !outside ? count + end - start : end - start
            };
        }
        function pathSegment(ctx, line, segment, params) {
            const {points, options} = line;
            const {count, start, loop, ilen} = pathVars(points, segment, params);
            const lineMethod = getLineMethod(options);
            let {move = true, reverse} = params || {};
            let i, point, prev;
            for (i = 0; i <= ilen; ++i) {
                point = points[(start + (reverse ? ilen - i : i)) % count];
                if (point.skip) continue; else if (move) {
                    ctx.moveTo(point.x, point.y);
                    move = false;
                } else lineMethod(ctx, prev, point, reverse, options.stepped);
                prev = point;
            }
            if (loop) {
                point = points[(start + (reverse ? ilen : 0)) % count];
                lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
            const points = line.points;
            const {count, start, ilen} = pathVars(points, segment, params);
            const {move = true, reverse} = params || {};
            let avgX = 0;
            let countX = 0;
            let i, point, prevX, minY, maxY, lastY;
            const pointIndex = index => (start + (reverse ? ilen - index : index)) % count;
            const drawX = () => {
                if (minY !== maxY) {
                    ctx.lineTo(avgX, maxY);
                    ctx.lineTo(avgX, minY);
                    ctx.lineTo(avgX, lastY);
                }
            };
            if (move) {
                point = points[pointIndex(0)];
                ctx.moveTo(point.x, point.y);
            }
            for (i = 0; i <= ilen; ++i) {
                point = points[pointIndex(i)];
                if (point.skip) continue;
                const x = point.x;
                const y = point.y;
                const truncX = x | 0;
                if (truncX === prevX) {
                    if (y < minY) minY = y; else if (y > maxY) maxY = y;
                    avgX = (countX * avgX + x) / ++countX;
                } else {
                    drawX();
                    ctx.lineTo(x, y);
                    prevX = truncX;
                    countX = 0;
                    minY = maxY = y;
                }
                lastY = y;
            }
            drawX();
        }
        function _getSegmentMethod(line) {
            const opts = line.options;
            const borderDash = opts.borderDash && opts.borderDash.length;
            const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
            return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
            if (options.stepped) return _steppedInterpolation;
            if (options.tension || options.cubicInterpolationMode === "monotone") return _bezierInterpolation;
            return _pointInLine;
        }
        function strokePathWithCache(ctx, line, start, count) {
            let path = line._path;
            if (!path) {
                path = line._path = new Path2D;
                if (line.path(path, start, count)) path.closePath();
            }
            setStyle(ctx, line.options);
            ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
            const {segments, options} = line;
            const segmentMethod = _getSegmentMethod(line);
            for (const segment of segments) {
                setStyle(ctx, options, segment.style);
                ctx.beginPath();
                if (segmentMethod(ctx, line, segment, {
                    start,
                    end: start + count - 1
                })) ctx.closePath();
                ctx.stroke();
            }
        }
        const usePath2D = typeof Path2D === "function";
        function draw(ctx, line, start, count) {
            if (usePath2D && !line.options.segment) strokePathWithCache(ctx, line, start, count); else strokePathDirect(ctx, line, start, count);
        }
        class LineElement extends Element {
            static id="line";
            static defaults={
                borderCapStyle: "butt",
                borderDash: [],
                borderDashOffset: 0,
                borderJoinStyle: "miter",
                borderWidth: 3,
                capBezierPoints: true,
                cubicInterpolationMode: "default",
                fill: false,
                spanGaps: false,
                stepped: false,
                tension: 0
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor",
                borderColor: "borderColor"
            };
            static descriptors={
                _scriptable: true,
                _indexable: name => name !== "borderDash" && name !== "fill"
            };
            constructor(cfg) {
                super();
                this.animated = true;
                this.options = void 0;
                this._chart = void 0;
                this._loop = void 0;
                this._fullLoop = void 0;
                this._path = void 0;
                this._points = void 0;
                this._segments = void 0;
                this._decimated = false;
                this._pointsUpdated = false;
                this._datasetIndex = void 0;
                if (cfg) Object.assign(this, cfg);
            }
            updateControlPoints(chartArea, indexAxis) {
                const options = this.options;
                if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
                    const loop = options.spanGaps ? this._loop : this._fullLoop;
                    _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
                    this._pointsUpdated = true;
                }
            }
            set points(points) {
                this._points = points;
                delete this._segments;
                delete this._path;
                this._pointsUpdated = false;
            }
            get points() {
                return this._points;
            }
            get segments() {
                return this._segments || (this._segments = _computeSegments(this, this.options.segment));
            }
            first() {
                const segments = this.segments;
                const points = this.points;
                return segments.length && points[segments[0].start];
            }
            last() {
                const segments = this.segments;
                const points = this.points;
                const count = segments.length;
                return count && points[segments[count - 1].end];
            }
            interpolate(point, property) {
                const options = this.options;
                const value = point[property];
                const points = this.points;
                const segments = _boundSegments(this, {
                    property,
                    start: value,
                    end: value
                });
                if (!segments.length) return;
                const result = [];
                const _interpolate = _getInterpolationMethod(options);
                let i, ilen;
                for (i = 0, ilen = segments.length; i < ilen; ++i) {
                    const {start, end} = segments[i];
                    const p1 = points[start];
                    const p2 = points[end];
                    if (p1 === p2) {
                        result.push(p1);
                        continue;
                    }
                    const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
                    const interpolated = _interpolate(p1, p2, t, options.stepped);
                    interpolated[property] = point[property];
                    result.push(interpolated);
                }
                return result.length === 1 ? result[0] : result;
            }
            pathSegment(ctx, segment, params) {
                const segmentMethod = _getSegmentMethod(this);
                return segmentMethod(ctx, this, segment, params);
            }
            path(ctx, start, count) {
                const segments = this.segments;
                const segmentMethod = _getSegmentMethod(this);
                let loop = this._loop;
                start = start || 0;
                count = count || this.points.length - start;
                for (const segment of segments) loop &= segmentMethod(ctx, this, segment, {
                    start,
                    end: start + count - 1
                });
                return !!loop;
            }
            draw(ctx, chartArea, start, count) {
                const options = this.options || {};
                const points = this.points || [];
                if (points.length && options.borderWidth) {
                    ctx.save();
                    draw(ctx, this, start, count);
                    ctx.restore();
                }
                if (this.animated) {
                    this._pointsUpdated = false;
                    this._path = void 0;
                }
            }
        }
        function inRange$1(el, pos, axis, useFinalPosition) {
            const options = el.options;
            const {[axis]: value} = el.getProps([ axis ], useFinalPosition);
            return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends Element {
            static id="point";
            parsed;
            skip;
            stop;
            static defaults={
                borderWidth: 1,
                hitRadius: 1,
                hoverBorderWidth: 1,
                hoverRadius: 4,
                pointStyle: "circle",
                radius: 3,
                rotation: 0
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor",
                borderColor: "borderColor"
            };
            constructor(cfg) {
                super();
                this.options = void 0;
                this.parsed = void 0;
                this.skip = void 0;
                this.stop = void 0;
                if (cfg) Object.assign(this, cfg);
            }
            inRange(mouseX, mouseY, useFinalPosition) {
                const options = this.options;
                const {x, y} = this.getProps([ "x", "y" ], useFinalPosition);
                return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
            }
            inXRange(mouseX, useFinalPosition) {
                return inRange$1(this, mouseX, "x", useFinalPosition);
            }
            inYRange(mouseY, useFinalPosition) {
                return inRange$1(this, mouseY, "y", useFinalPosition);
            }
            getCenterPoint(useFinalPosition) {
                const {x, y} = this.getProps([ "x", "y" ], useFinalPosition);
                return {
                    x,
                    y
                };
            }
            size(options) {
                options = options || this.options || {};
                let radius = options.radius || 0;
                radius = Math.max(radius, radius && options.hoverRadius || 0);
                const borderWidth = radius && options.borderWidth || 0;
                return (radius + borderWidth) * 2;
            }
            draw(ctx, area) {
                const options = this.options;
                if (this.skip || options.radius < .1 || !_isPointInArea(this, area, this.size(options) / 2)) return;
                ctx.strokeStyle = options.borderColor;
                ctx.lineWidth = options.borderWidth;
                ctx.fillStyle = options.backgroundColor;
                drawPoint(ctx, options, this.x, this.y);
            }
            getRange() {
                const options = this.options || {};
                return options.radius + options.hitRadius;
            }
        }
        function getBarBounds(bar, useFinalPosition) {
            const {x, y, base, width, height} = bar.getProps([ "x", "y", "base", "width", "height" ], useFinalPosition);
            let left, right, top, bottom, half;
            if (bar.horizontal) {
                half = height / 2;
                left = Math.min(x, base);
                right = Math.max(x, base);
                top = y - half;
                bottom = y + half;
            } else {
                half = width / 2;
                left = x - half;
                right = x + half;
                top = Math.min(y, base);
                bottom = Math.max(y, base);
            }
            return {
                left,
                top,
                right,
                bottom
            };
        }
        function skipOrLimit(skip, value, min, max) {
            return skip ? 0 : _limitValue(value, min, max);
        }
        function parseBorderWidth(bar, maxW, maxH) {
            const value = bar.options.borderWidth;
            const skip = bar.borderSkipped;
            const o = toTRBL(value);
            return {
                t: skipOrLimit(skip.top, o.top, 0, maxH),
                r: skipOrLimit(skip.right, o.right, 0, maxW),
                b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
                l: skipOrLimit(skip.left, o.left, 0, maxW)
            };
        }
        function parseBorderRadius(bar, maxW, maxH) {
            const {enableBorderRadius} = bar.getProps([ "enableBorderRadius" ]);
            const value = bar.options.borderRadius;
            const o = toTRBLCorners(value);
            const maxR = Math.min(maxW, maxH);
            const skip = bar.borderSkipped;
            const enableBorder = enableBorderRadius || helpers_segment_isObject(value);
            return {
                topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
                topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
                bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
                bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
            };
        }
        function boundingRects(bar) {
            const bounds = getBarBounds(bar);
            const width = bounds.right - bounds.left;
            const height = bounds.bottom - bounds.top;
            const border = parseBorderWidth(bar, width / 2, height / 2);
            const radius = parseBorderRadius(bar, width / 2, height / 2);
            return {
                outer: {
                    x: bounds.left,
                    y: bounds.top,
                    w: width,
                    h: height,
                    radius
                },
                inner: {
                    x: bounds.left + border.l,
                    y: bounds.top + border.t,
                    w: width - border.l - border.r,
                    h: height - border.t - border.b,
                    radius: {
                        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
                    }
                }
            };
        }
        function inRange(bar, x, y, useFinalPosition) {
            const skipX = x === null;
            const skipY = y === null;
            const skipBoth = skipX && skipY;
            const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
            return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
        }
        function hasRadius(radius) {
            return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
        }
        function addNormalRectPath(ctx, rect) {
            ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
            const x = rect.x !== refRect.x ? -amount : 0;
            const y = rect.y !== refRect.y ? -amount : 0;
            const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
            const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
            return {
                x: rect.x + x,
                y: rect.y + y,
                w: rect.w + w,
                h: rect.h + h,
                radius: rect.radius
            };
        }
        class BarElement extends Element {
            static id="bar";
            static defaults={
                borderSkipped: "start",
                borderWidth: 0,
                borderRadius: 0,
                inflateAmount: "auto",
                pointStyle: void 0
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor",
                borderColor: "borderColor"
            };
            constructor(cfg) {
                super();
                this.options = void 0;
                this.horizontal = void 0;
                this.base = void 0;
                this.width = void 0;
                this.height = void 0;
                this.inflateAmount = void 0;
                if (cfg) Object.assign(this, cfg);
            }
            draw(ctx) {
                const {inflateAmount, options: {borderColor, backgroundColor}} = this;
                const {inner, outer} = boundingRects(this);
                const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
                ctx.save();
                if (outer.w !== inner.w || outer.h !== inner.h) {
                    ctx.beginPath();
                    addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
                    ctx.clip();
                    addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
                    ctx.fillStyle = borderColor;
                    ctx.fill("evenodd");
                }
                ctx.beginPath();
                addRectPath(ctx, inflateRect(inner, inflateAmount));
                ctx.fillStyle = backgroundColor;
                ctx.fill();
                ctx.restore();
            }
            inRange(mouseX, mouseY, useFinalPosition) {
                return inRange(this, mouseX, mouseY, useFinalPosition);
            }
            inXRange(mouseX, useFinalPosition) {
                return inRange(this, mouseX, null, useFinalPosition);
            }
            inYRange(mouseY, useFinalPosition) {
                return inRange(this, null, mouseY, useFinalPosition);
            }
            getCenterPoint(useFinalPosition) {
                const {x, y, base, horizontal} = this.getProps([ "x", "y", "base", "horizontal" ], useFinalPosition);
                return {
                    x: horizontal ? (x + base) / 2 : x,
                    y: horizontal ? y : (y + base) / 2
                };
            }
            getRange(axis) {
                return axis === "x" ? this.width / 2 : this.height / 2;
            }
        }
        var chart_elements = Object.freeze({
            __proto__: null,
            ArcElement,
            BarElement,
            LineElement,
            PointElement
        });
        const BORDER_COLORS = [ "rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)" ];
        const BACKGROUND_COLORS = BORDER_COLORS.map((color => color.replace("rgb(", "rgba(").replace(")", ", 0.5)")));
        function getBorderColor(i) {
            return BORDER_COLORS[i % BORDER_COLORS.length];
        }
        function getBackgroundColor(i) {
            return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
        }
        function colorizeDefaultDataset(dataset, i) {
            dataset.borderColor = getBorderColor(i);
            dataset.backgroundColor = getBackgroundColor(i);
            return ++i;
        }
        function colorizeDoughnutDataset(dataset, i) {
            dataset.backgroundColor = dataset.data.map((() => getBorderColor(i++)));
            return i;
        }
        function colorizePolarAreaDataset(dataset, i) {
            dataset.backgroundColor = dataset.data.map((() => getBackgroundColor(i++)));
            return i;
        }
        function getColorizer(chart) {
            let i = 0;
            return (dataset, datasetIndex) => {
                const controller = chart.getDatasetMeta(datasetIndex).controller;
                if (controller instanceof DoughnutController) i = colorizeDoughnutDataset(dataset, i); else if (controller instanceof PolarAreaController) i = colorizePolarAreaDataset(dataset, i); else if (controller) i = colorizeDefaultDataset(dataset, i);
            };
        }
        function containsColorsDefinitions(descriptors) {
            let k;
            for (k in descriptors) if (descriptors[k].borderColor || descriptors[k].backgroundColor) return true;
            return false;
        }
        function containsColorsDefinition(descriptor) {
            return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
        }
        var plugin_colors = {
            id: "colors",
            defaults: {
                enabled: true,
                forceOverride: false
            },
            beforeLayout(chart, _args, options) {
                if (!options.enabled) return;
                const {data: {datasets}, options: chartOptions} = chart.config;
                const {elements} = chartOptions;
                if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements))) return;
                const colorizer = getColorizer(chart);
                datasets.forEach(colorizer);
            }
        };
        function lttbDecimation(data, start, count, availableWidth, options) {
            const samples = options.samples || availableWidth;
            if (samples >= count) return data.slice(start, start + count);
            const decimated = [];
            const bucketWidth = (count - 2) / (samples - 2);
            let sampledIndex = 0;
            const endIndex = start + count - 1;
            let a = start;
            let i, maxAreaPoint, maxArea, area, nextA;
            decimated[sampledIndex++] = data[a];
            for (i = 0; i < samples - 2; i++) {
                let avgX = 0;
                let avgY = 0;
                let j;
                const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
                const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
                const avgRangeLength = avgRangeEnd - avgRangeStart;
                for (j = avgRangeStart; j < avgRangeEnd; j++) {
                    avgX += data[j].x;
                    avgY += data[j].y;
                }
                avgX /= avgRangeLength;
                avgY /= avgRangeLength;
                const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
                const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
                const {x: pointAx, y: pointAy} = data[a];
                maxArea = area = -1;
                for (j = rangeOffs; j < rangeTo; j++) {
                    area = .5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
                    if (area > maxArea) {
                        maxArea = area;
                        maxAreaPoint = data[j];
                        nextA = j;
                    }
                }
                decimated[sampledIndex++] = maxAreaPoint;
                a = nextA;
            }
            decimated[sampledIndex++] = data[endIndex];
            return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
            let avgX = 0;
            let countX = 0;
            let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
            const decimated = [];
            const endIndex = start + count - 1;
            const xMin = data[start].x;
            const xMax = data[endIndex].x;
            const dx = xMax - xMin;
            for (i = start; i < start + count; ++i) {
                point = data[i];
                x = (point.x - xMin) / dx * availableWidth;
                y = point.y;
                const truncX = x | 0;
                if (truncX === prevX) {
                    if (y < minY) {
                        minY = y;
                        minIndex = i;
                    } else if (y > maxY) {
                        maxY = y;
                        maxIndex = i;
                    }
                    avgX = (countX * avgX + point.x) / ++countX;
                } else {
                    const lastIndex = i - 1;
                    if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                        const intermediateIndex1 = Math.min(minIndex, maxIndex);
                        const intermediateIndex2 = Math.max(minIndex, maxIndex);
                        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) decimated.push({
                            ...data[intermediateIndex1],
                            x: avgX
                        });
                        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) decimated.push({
                            ...data[intermediateIndex2],
                            x: avgX
                        });
                    }
                    if (i > 0 && lastIndex !== startIndex) decimated.push(data[lastIndex]);
                    decimated.push(point);
                    prevX = truncX;
                    countX = 0;
                    minY = maxY = y;
                    minIndex = maxIndex = startIndex = i;
                }
            }
            return decimated;
        }
        function cleanDecimatedDataset(dataset) {
            if (dataset._decimated) {
                const data = dataset._data;
                delete dataset._decimated;
                delete dataset._data;
                Object.defineProperty(dataset, "data", {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: data
                });
            }
        }
        function cleanDecimatedData(chart) {
            chart.data.datasets.forEach((dataset => {
                cleanDecimatedDataset(dataset);
            }));
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
            const pointCount = points.length;
            let start = 0;
            let count;
            const {iScale} = meta;
            const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
            if (minDefined) start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
            if (maxDefined) count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start; else count = pointCount - start;
            return {
                start,
                count
            };
        }
        var plugin_decimation = {
            id: "decimation",
            defaults: {
                algorithm: "min-max",
                enabled: false
            },
            beforeElementsUpdate: (chart, args, options) => {
                if (!options.enabled) {
                    cleanDecimatedData(chart);
                    return;
                }
                const availableWidth = chart.width;
                chart.data.datasets.forEach(((dataset, datasetIndex) => {
                    const {_data, indexAxis} = dataset;
                    const meta = chart.getDatasetMeta(datasetIndex);
                    const data = _data || dataset.data;
                    if (resolve([ indexAxis, chart.options.indexAxis ]) === "y") return;
                    if (!meta.controller.supportsDecimation) return;
                    const xAxis = chart.scales[meta.xAxisID];
                    if (xAxis.type !== "linear" && xAxis.type !== "time") return;
                    if (chart.options.parsing) return;
                    let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
                    const threshold = options.threshold || 4 * availableWidth;
                    if (count <= threshold) {
                        cleanDecimatedDataset(dataset);
                        return;
                    }
                    if (isNullOrUndef(_data)) {
                        dataset._data = data;
                        delete dataset.data;
                        Object.defineProperty(dataset, "data", {
                            configurable: true,
                            enumerable: true,
                            get: function() {
                                return this._decimated;
                            },
                            set: function(d) {
                                this._data = d;
                            }
                        });
                    }
                    let decimated;
                    switch (options.algorithm) {
                      case "lttb":
                        decimated = lttbDecimation(data, start, count, availableWidth, options);
                        break;

                      case "min-max":
                        decimated = minMaxDecimation(data, start, count, availableWidth);
                        break;

                      default:
                        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
                    }
                    dataset._decimated = decimated;
                }));
            },
            destroy(chart) {
                cleanDecimatedData(chart);
            }
        };
        function _segments(line, target, property) {
            const segments = line.segments;
            const points = line.points;
            const tpoints = target.points;
            const parts = [];
            for (const segment of segments) {
                let {start, end} = segment;
                end = _findSegmentEnd(start, end, points);
                const bounds = _getBounds(property, points[start], points[end], segment.loop);
                if (!target.segments) {
                    parts.push({
                        source: segment,
                        target: bounds,
                        start: points[start],
                        end: points[end]
                    });
                    continue;
                }
                const targetSegments = _boundSegments(target, bounds);
                for (const tgt of targetSegments) {
                    const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
                    const fillSources = _boundSegment(segment, points, subBounds);
                    for (const fillSource of fillSources) parts.push({
                        source: fillSource,
                        target: tgt,
                        start: {
                            [property]: _getEdge(bounds, subBounds, "start", Math.max)
                        },
                        end: {
                            [property]: _getEdge(bounds, subBounds, "end", Math.min)
                        }
                    });
                }
            }
            return parts;
        }
        function _getBounds(property, first, last, loop) {
            if (loop) return;
            let start = first[property];
            let end = last[property];
            if (property === "angle") {
                start = _normalizeAngle(start);
                end = _normalizeAngle(end);
            }
            return {
                property,
                start,
                end
            };
        }
        function _pointsFromSegments(boundary, line) {
            const {x = null, y = null} = boundary || {};
            const linePoints = line.points;
            const points = [];
            line.segments.forEach((({start, end}) => {
                end = _findSegmentEnd(start, end, linePoints);
                const first = linePoints[start];
                const last = linePoints[end];
                if (y !== null) {
                    points.push({
                        x: first.x,
                        y
                    });
                    points.push({
                        x: last.x,
                        y
                    });
                } else if (x !== null) {
                    points.push({
                        x,
                        y: first.y
                    });
                    points.push({
                        x,
                        y: last.y
                    });
                }
            }));
            return points;
        }
        function _findSegmentEnd(start, end, points) {
            for (;end > start; end--) {
                const point = points[end];
                if (!isNaN(point.x) && !isNaN(point.y)) break;
            }
            return end;
        }
        function _getEdge(a, b, prop, fn) {
            if (a && b) return fn(a[prop], b[prop]);
            return a ? a[prop] : b ? b[prop] : 0;
        }
        function _createBoundaryLine(boundary, line) {
            let points = [];
            let _loop = false;
            if (isArray(boundary)) {
                _loop = true;
                points = boundary;
            } else points = _pointsFromSegments(boundary, line);
            return points.length ? new LineElement({
                points,
                options: {
                    tension: 0
                },
                _loop,
                _fullLoop: _loop
            }) : null;
        }
        function _shouldApplyFill(source) {
            return source && source.fill !== false;
        }
        function _resolveTarget(sources, index, propagate) {
            const source = sources[index];
            let fill = source.fill;
            const visited = [ index ];
            let target;
            if (!propagate) return fill;
            while (fill !== false && visited.indexOf(fill) === -1) {
                if (!isNumberFinite(fill)) return fill;
                target = sources[fill];
                if (!target) return false;
                if (target.visible) return fill;
                visited.push(fill);
                fill = target.fill;
            }
            return false;
        }
        function _decodeFill(line, index, count) {
            const fill = parseFillOption(line);
            if (helpers_segment_isObject(fill)) return isNaN(fill.value) ? false : fill;
            let target = parseFloat(fill);
            if (isNumberFinite(target) && Math.floor(target) === target) return decodeTargetIndex(fill[0], index, target, count);
            return [ "origin", "start", "end", "stack", "shape" ].indexOf(fill) >= 0 && fill;
        }
        function decodeTargetIndex(firstCh, index, target, count) {
            if (firstCh === "-" || firstCh === "+") target = index + target;
            if (target === index || target < 0 || target >= count) return false;
            return target;
        }
        function _getTargetPixel(fill, scale) {
            let pixel = null;
            if (fill === "start") pixel = scale.bottom; else if (fill === "end") pixel = scale.top; else if (helpers_segment_isObject(fill)) pixel = scale.getPixelForValue(fill.value); else if (scale.getBasePixel) pixel = scale.getBasePixel();
            return pixel;
        }
        function _getTargetValue(fill, scale, startValue) {
            let value;
            if (fill === "start") value = startValue; else if (fill === "end") value = scale.options.reverse ? scale.min : scale.max; else if (helpers_segment_isObject(fill)) value = fill.value; else value = scale.getBaseValue();
            return value;
        }
        function parseFillOption(line) {
            const options = line.options;
            const fillOption = options.fill;
            let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
            if (fill === void 0) fill = !!options.backgroundColor;
            if (fill === false || fill === null) return false;
            if (fill === true) return "origin";
            return fill;
        }
        function _buildStackLine(source) {
            const {scale, index, line} = source;
            const points = [];
            const segments = line.segments;
            const sourcePoints = line.points;
            const linesBelow = getLinesBelow(scale, index);
            linesBelow.push(_createBoundaryLine({
                x: null,
                y: scale.bottom
            }, line));
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                for (let j = segment.start; j <= segment.end; j++) addPointsBelow(points, sourcePoints[j], linesBelow);
            }
            return new LineElement({
                points,
                options: {}
            });
        }
        function getLinesBelow(scale, index) {
            const below = [];
            const metas = scale.getMatchingVisibleMetas("line");
            for (let i = 0; i < metas.length; i++) {
                const meta = metas[i];
                if (meta.index === index) break;
                if (!meta.hidden) below.unshift(meta.dataset);
            }
            return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
            const postponed = [];
            for (let j = 0; j < linesBelow.length; j++) {
                const line = linesBelow[j];
                const {first, last, point} = findPoint(line, sourcePoint, "x");
                if (!point || first && last) continue;
                if (first) postponed.unshift(point); else {
                    points.push(point);
                    if (!last) break;
                }
            }
            points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
            const point = line.interpolate(sourcePoint, property);
            if (!point) return {};
            const pointValue = point[property];
            const segments = line.segments;
            const linePoints = line.points;
            let first = false;
            let last = false;
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                const firstValue = linePoints[segment.start][property];
                const lastValue = linePoints[segment.end][property];
                if (_isBetween(pointValue, firstValue, lastValue)) {
                    first = pointValue === firstValue;
                    last = pointValue === lastValue;
                    break;
                }
            }
            return {
                first,
                last,
                point
            };
        }
        class simpleArc {
            constructor(opts) {
                this.x = opts.x;
                this.y = opts.y;
                this.radius = opts.radius;
            }
            pathSegment(ctx, bounds, opts) {
                const {x, y, radius} = this;
                bounds = bounds || {
                    start: 0,
                    end: TAU
                };
                ctx.arc(x, y, radius, bounds.end, bounds.start, true);
                return !opts.bounds;
            }
            interpolate(point) {
                const {x, y, radius} = this;
                const angle = point.angle;
                return {
                    x: x + Math.cos(angle) * radius,
                    y: y + Math.sin(angle) * radius,
                    angle
                };
            }
        }
        function _getTarget(source) {
            const {chart, fill, line} = source;
            if (isNumberFinite(fill)) return getLineByIndex(chart, fill);
            if (fill === "stack") return _buildStackLine(source);
            if (fill === "shape") return true;
            const boundary = computeBoundary(source);
            if (boundary instanceof simpleArc) return boundary;
            return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart, index) {
            const meta = chart.getDatasetMeta(index);
            const visible = meta && chart.isDatasetVisible(index);
            return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
            const scale = source.scale || {};
            if (scale.getPointPositionForValue) return computeCircularBoundary(source);
            return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
            const {scale = {}, fill} = source;
            const pixel = _getTargetPixel(fill, scale);
            if (isNumberFinite(pixel)) {
                const horizontal = scale.isHorizontal();
                return {
                    x: horizontal ? pixel : null,
                    y: horizontal ? null : pixel
                };
            }
            return null;
        }
        function computeCircularBoundary(source) {
            const {scale, fill} = source;
            const options = scale.options;
            const length = scale.getLabels().length;
            const start = options.reverse ? scale.max : scale.min;
            const value = _getTargetValue(fill, scale, start);
            const target = [];
            if (options.grid.circular) {
                const center = scale.getPointPositionForValue(0, start);
                return new simpleArc({
                    x: center.x,
                    y: center.y,
                    radius: scale.getDistanceFromCenterForValue(value)
                });
            }
            for (let i = 0; i < length; ++i) target.push(scale.getPointPositionForValue(i, value));
            return target;
        }
        function _drawfill(ctx, source, area) {
            const target = _getTarget(source);
            const {line, scale, axis} = source;
            const lineOpts = line.options;
            const fillOption = lineOpts.fill;
            const color = lineOpts.backgroundColor;
            const {above = color, below = color} = fillOption || {};
            if (target && line.points.length) {
                clipArea(ctx, area);
                doFill(ctx, {
                    line,
                    target,
                    above,
                    below,
                    area,
                    scale,
                    axis
                });
                unclipArea(ctx);
            }
        }
        function doFill(ctx, cfg) {
            const {line, target, above, below, area, scale} = cfg;
            const property = line._loop ? "angle" : cfg.axis;
            ctx.save();
            if (property === "x" && below !== above) {
                clipVertical(ctx, target, area.top);
                fill(ctx, {
                    line,
                    target,
                    color: above,
                    scale,
                    property
                });
                ctx.restore();
                ctx.save();
                clipVertical(ctx, target, area.bottom);
            }
            fill(ctx, {
                line,
                target,
                color: below,
                scale,
                property
            });
            ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
            const {segments, points} = target;
            let first = true;
            let lineLoop = false;
            ctx.beginPath();
            for (const segment of segments) {
                const {start, end} = segment;
                const firstPoint = points[start];
                const lastPoint = points[_findSegmentEnd(start, end, points)];
                if (first) {
                    ctx.moveTo(firstPoint.x, firstPoint.y);
                    first = false;
                } else {
                    ctx.lineTo(firstPoint.x, clipY);
                    ctx.lineTo(firstPoint.x, firstPoint.y);
                }
                lineLoop = !!target.pathSegment(ctx, segment, {
                    move: lineLoop
                });
                if (lineLoop) ctx.closePath(); else ctx.lineTo(lastPoint.x, clipY);
            }
            ctx.lineTo(target.first().x, clipY);
            ctx.closePath();
            ctx.clip();
        }
        function fill(ctx, cfg) {
            const {line, target, property, color, scale} = cfg;
            const segments = _segments(line, target, property);
            for (const {source: src, target: tgt, start, end} of segments) {
                const {style: {backgroundColor = color} = {}} = src;
                const notShape = target !== true;
                ctx.save();
                ctx.fillStyle = backgroundColor;
                clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
                ctx.beginPath();
                const lineLoop = !!line.pathSegment(ctx, src);
                let loop;
                if (notShape) {
                    if (lineLoop) ctx.closePath(); else interpolatedLineTo(ctx, target, end, property);
                    const targetLoop = !!target.pathSegment(ctx, tgt, {
                        move: lineLoop,
                        reverse: true
                    });
                    loop = lineLoop && targetLoop;
                    if (!loop) interpolatedLineTo(ctx, target, start, property);
                }
                ctx.closePath();
                ctx.fill(loop ? "evenodd" : "nonzero");
                ctx.restore();
            }
        }
        function clipBounds(ctx, scale, bounds) {
            const {top, bottom} = scale.chart.chartArea;
            const {property, start, end} = bounds || {};
            if (property === "x") {
                ctx.beginPath();
                ctx.rect(start, top, end - start, bottom - top);
                ctx.clip();
            }
        }
        function interpolatedLineTo(ctx, target, point, property) {
            const interpolatedPoint = target.interpolate(point, property);
            if (interpolatedPoint) ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
        var index = {
            id: "filler",
            afterDatasetsUpdate(chart, _args, options) {
                const count = (chart.data.datasets || []).length;
                const sources = [];
                let meta, i, line, source;
                for (i = 0; i < count; ++i) {
                    meta = chart.getDatasetMeta(i);
                    line = meta.dataset;
                    source = null;
                    if (line && line.options && line instanceof LineElement) source = {
                        visible: chart.isDatasetVisible(i),
                        index: i,
                        fill: _decodeFill(line, i, count),
                        chart,
                        axis: meta.controller.options.indexAxis,
                        scale: meta.vScale,
                        line
                    };
                    meta.$filler = source;
                    sources.push(source);
                }
                for (i = 0; i < count; ++i) {
                    source = sources[i];
                    if (!source || source.fill === false) continue;
                    source.fill = _resolveTarget(sources, i, options.propagate);
                }
            },
            beforeDraw(chart, _args, options) {
                const draw = options.drawTime === "beforeDraw";
                const metasets = chart.getSortedVisibleDatasetMetas();
                const area = chart.chartArea;
                for (let i = metasets.length - 1; i >= 0; --i) {
                    const source = metasets[i].$filler;
                    if (!source) continue;
                    source.line.updateControlPoints(area, source.axis);
                    if (draw && source.fill) _drawfill(chart.ctx, source, area);
                }
            },
            beforeDatasetsDraw(chart, _args, options) {
                if (options.drawTime !== "beforeDatasetsDraw") return;
                const metasets = chart.getSortedVisibleDatasetMetas();
                for (let i = metasets.length - 1; i >= 0; --i) {
                    const source = metasets[i].$filler;
                    if (_shouldApplyFill(source)) _drawfill(chart.ctx, source, chart.chartArea);
                }
            },
            beforeDatasetDraw(chart, args, options) {
                const source = args.meta.$filler;
                if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") return;
                _drawfill(chart.ctx, source, chart.chartArea);
            },
            defaults: {
                propagate: true,
                drawTime: "beforeDatasetDraw"
            }
        };
        const getBoxSize = (labelOpts, fontSize) => {
            let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
            if (labelOpts.usePointStyle) {
                boxHeight = Math.min(boxHeight, fontSize);
                boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
            }
            return {
                boxWidth,
                boxHeight,
                itemHeight: Math.max(fontSize, boxHeight)
            };
        };
        const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
        class Legend extends Element {
            constructor(config) {
                super();
                this._added = false;
                this.legendHitBoxes = [];
                this._hoveredItem = null;
                this.doughnutMode = false;
                this.chart = config.chart;
                this.options = config.options;
                this.ctx = config.ctx;
                this.legendItems = void 0;
                this.columnSizes = void 0;
                this.lineWidths = void 0;
                this.maxHeight = void 0;
                this.maxWidth = void 0;
                this.top = void 0;
                this.bottom = void 0;
                this.left = void 0;
                this.right = void 0;
                this.height = void 0;
                this.width = void 0;
                this._margins = void 0;
                this.position = void 0;
                this.weight = void 0;
                this.fullSize = void 0;
            }
            update(maxWidth, maxHeight, margins) {
                this.maxWidth = maxWidth;
                this.maxHeight = maxHeight;
                this._margins = margins;
                this.setDimensions();
                this.buildLabels();
                this.fit();
            }
            setDimensions() {
                if (this.isHorizontal()) {
                    this.width = this.maxWidth;
                    this.left = this._margins.left;
                    this.right = this.width;
                } else {
                    this.height = this.maxHeight;
                    this.top = this._margins.top;
                    this.bottom = this.height;
                }
            }
            buildLabels() {
                const labelOpts = this.options.labels || {};
                let legendItems = callback(labelOpts.generateLabels, [ this.chart ], this) || [];
                if (labelOpts.filter) legendItems = legendItems.filter((item => labelOpts.filter(item, this.chart.data)));
                if (labelOpts.sort) legendItems = legendItems.sort(((a, b) => labelOpts.sort(a, b, this.chart.data)));
                if (this.options.reverse) legendItems.reverse();
                this.legendItems = legendItems;
            }
            fit() {
                const {options, ctx} = this;
                if (!options.display) {
                    this.width = this.height = 0;
                    return;
                }
                const labelOpts = options.labels;
                const labelFont = toFont(labelOpts.font);
                const fontSize = labelFont.size;
                const titleHeight = this._computeTitleHeight();
                const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
                let width, height;
                ctx.font = labelFont.string;
                if (this.isHorizontal()) {
                    width = this.maxWidth;
                    height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
                } else {
                    height = this.maxHeight;
                    width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
                }
                this.width = Math.min(width, options.maxWidth || this.maxWidth);
                this.height = Math.min(height, options.maxHeight || this.maxHeight);
            }
            _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
                const {ctx, maxWidth, options: {labels: {padding}}} = this;
                const hitboxes = this.legendHitBoxes = [];
                const lineWidths = this.lineWidths = [ 0 ];
                const lineHeight = itemHeight + padding;
                let totalHeight = titleHeight;
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                let row = -1;
                let top = -lineHeight;
                this.legendItems.forEach(((legendItem, i) => {
                    const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                    if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                        totalHeight += lineHeight;
                        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                        top += lineHeight;
                        row++;
                    }
                    hitboxes[i] = {
                        left: 0,
                        top,
                        row,
                        width: itemWidth,
                        height: itemHeight
                    };
                    lineWidths[lineWidths.length - 1] += itemWidth + padding;
                }));
                return totalHeight;
            }
            _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
                const {ctx, maxHeight, options: {labels: {padding}}} = this;
                const hitboxes = this.legendHitBoxes = [];
                const columnSizes = this.columnSizes = [];
                const heightLimit = maxHeight - titleHeight;
                let totalWidth = padding;
                let currentColWidth = 0;
                let currentColHeight = 0;
                let left = 0;
                let col = 0;
                this.legendItems.forEach(((legendItem, i) => {
                    const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
                    if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                        totalWidth += currentColWidth + padding;
                        columnSizes.push({
                            width: currentColWidth,
                            height: currentColHeight
                        });
                        left += currentColWidth + padding;
                        col++;
                        currentColWidth = currentColHeight = 0;
                    }
                    hitboxes[i] = {
                        left,
                        top: currentColHeight,
                        col,
                        width: itemWidth,
                        height: itemHeight
                    };
                    currentColWidth = Math.max(currentColWidth, itemWidth);
                    currentColHeight += itemHeight + padding;
                }));
                totalWidth += currentColWidth;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                return totalWidth;
            }
            adjustHitBoxes() {
                if (!this.options.display) return;
                const titleHeight = this._computeTitleHeight();
                const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;
                const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
                if (this.isHorizontal()) {
                    let row = 0;
                    let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                    for (const hitbox of hitboxes) {
                        if (row !== hitbox.row) {
                            row = hitbox.row;
                            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                        }
                        hitbox.top += this.top + titleHeight + padding;
                        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                        left += hitbox.width + padding;
                    }
                } else {
                    let col = 0;
                    let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                    for (const hitbox of hitboxes) {
                        if (hitbox.col !== col) {
                            col = hitbox.col;
                            top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                        }
                        hitbox.top = top;
                        hitbox.left += this.left + padding;
                        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                        top += hitbox.height + padding;
                    }
                }
            }
            isHorizontal() {
                return this.options.position === "top" || this.options.position === "bottom";
            }
            draw() {
                if (this.options.display) {
                    const ctx = this.ctx;
                    clipArea(ctx, this);
                    this._draw();
                    unclipArea(ctx);
                }
            }
            _draw() {
                const {options: opts, columnSizes, lineWidths, ctx} = this;
                const {align, labels: labelOpts} = opts;
                const defaultColor = helpers_segment_defaults.color;
                const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
                const labelFont = toFont(labelOpts.font);
                const {padding} = labelOpts;
                const fontSize = labelFont.size;
                const halfFontSize = fontSize / 2;
                let cursor;
                this.drawTitle();
                ctx.textAlign = rtlHelper.textAlign("left");
                ctx.textBaseline = "middle";
                ctx.lineWidth = .5;
                ctx.font = labelFont.string;
                const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
                const drawLegendBox = function(x, y, legendItem) {
                    if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) return;
                    ctx.save();
                    const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
                    ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
                    ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
                    ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
                    ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
                    ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
                    if (labelOpts.usePointStyle) {
                        const drawOptions = {
                            radius: boxHeight * Math.SQRT2 / 2,
                            pointStyle: legendItem.pointStyle,
                            rotation: legendItem.rotation,
                            borderWidth: lineWidth
                        };
                        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                        const centerY = y + halfFontSize;
                        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
                    } else {
                        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                        const borderRadius = toTRBLCorners(legendItem.borderRadius);
                        ctx.beginPath();
                        if (Object.values(borderRadius).some((v => v !== 0))) addRoundedRectPath(ctx, {
                            x: xBoxLeft,
                            y: yBoxTop,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius
                        }); else ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                        ctx.fill();
                        if (lineWidth !== 0) ctx.stroke();
                    }
                    ctx.restore();
                };
                const fillText = function(x, y, legendItem) {
                    renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                        strikethrough: legendItem.hidden,
                        textAlign: rtlHelper.textAlign(legendItem.textAlign)
                    });
                };
                const isHorizontal = this.isHorizontal();
                const titleHeight = this._computeTitleHeight();
                if (isHorizontal) cursor = {
                    x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                    y: this.top + padding + titleHeight,
                    line: 0
                }; else cursor = {
                    x: this.left + padding,
                    y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                    line: 0
                };
                overrideTextDirection(this.ctx, opts.textDirection);
                const lineHeight = itemHeight + padding;
                this.legendItems.forEach(((legendItem, i) => {
                    ctx.strokeStyle = legendItem.fontColor;
                    ctx.fillStyle = legendItem.fontColor;
                    const textWidth = ctx.measureText(legendItem.text).width;
                    const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
                    const width = boxWidth + halfFontSize + textWidth;
                    let x = cursor.x;
                    let y = cursor.y;
                    rtlHelper.setWidth(this.width);
                    if (isHorizontal) {
                        if (i > 0 && x + width + padding > this.right) {
                            y = cursor.y += lineHeight;
                            cursor.line++;
                            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                        }
                    } else if (i > 0 && y + lineHeight > this.bottom) {
                        x = cursor.x = x + columnSizes[cursor.line].width + padding;
                        cursor.line++;
                        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
                    }
                    const realX = rtlHelper.x(x);
                    drawLegendBox(realX, y, legendItem);
                    x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
                    fillText(rtlHelper.x(x), y, legendItem);
                    if (isHorizontal) cursor.x += width + padding; else if (typeof legendItem.text !== "string") {
                        const fontLineHeight = labelFont.lineHeight;
                        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
                    } else cursor.y += lineHeight;
                }));
                restoreTextDirection(this.ctx, opts.textDirection);
            }
            drawTitle() {
                const opts = this.options;
                const titleOpts = opts.title;
                const titleFont = toFont(titleOpts.font);
                const titlePadding = toPadding(titleOpts.padding);
                if (!titleOpts.display) return;
                const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
                const ctx = this.ctx;
                const position = titleOpts.position;
                const halfFontSize = titleFont.size / 2;
                const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
                let y;
                let left = this.left;
                let maxWidth = this.width;
                if (this.isHorizontal()) {
                    maxWidth = Math.max(...this.lineWidths);
                    y = this.top + topPaddingPlusHalfFontSize;
                    left = _alignStartEnd(opts.align, left, this.right - maxWidth);
                } else {
                    const maxHeight = this.columnSizes.reduce(((acc, size) => Math.max(acc, size.height)), 0);
                    y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
                }
                const x = _alignStartEnd(position, left, left + maxWidth);
                ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
                ctx.textBaseline = "middle";
                ctx.strokeStyle = titleOpts.color;
                ctx.fillStyle = titleOpts.color;
                ctx.font = titleFont.string;
                renderText(ctx, titleOpts.text, x, y, titleFont);
            }
            _computeTitleHeight() {
                const titleOpts = this.options.title;
                const titleFont = toFont(titleOpts.font);
                const titlePadding = toPadding(titleOpts.padding);
                return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
            }
            _getLegendItemAt(x, y) {
                let i, hitBox, lh;
                if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
                    lh = this.legendHitBoxes;
                    for (i = 0; i < lh.length; ++i) {
                        hitBox = lh[i];
                        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) return this.legendItems[i];
                    }
                }
                return null;
            }
            handleEvent(e) {
                const opts = this.options;
                if (!isListened(e.type, opts)) return;
                const hoveredItem = this._getLegendItemAt(e.x, e.y);
                if (e.type === "mousemove" || e.type === "mouseout") {
                    const previous = this._hoveredItem;
                    const sameItem = itemsEqual(previous, hoveredItem);
                    if (previous && !sameItem) callback(opts.onLeave, [ e, previous, this ], this);
                    this._hoveredItem = hoveredItem;
                    if (hoveredItem && !sameItem) callback(opts.onHover, [ e, hoveredItem, this ], this);
                } else if (hoveredItem) callback(opts.onClick, [ e, hoveredItem, this ], this);
            }
        }
        function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
            const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
            const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
            return {
                itemWidth,
                itemHeight
            };
        }
        function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
            let legendItemText = legendItem.text;
            if (legendItemText && typeof legendItemText !== "string") legendItemText = legendItemText.reduce(((a, b) => a.length > b.length ? a : b));
            return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
        }
        function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
            let itemHeight = _itemHeight;
            if (typeof legendItem.text !== "string") itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
            return itemHeight;
        }
        function calculateLegendItemHeight(legendItem, fontLineHeight) {
            const labelHeight = legendItem.text ? legendItem.text.length : 0;
            return fontLineHeight * labelHeight;
        }
        function isListened(type, opts) {
            if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) return true;
            if (opts.onClick && (type === "click" || type === "mouseup")) return true;
            return false;
        }
        var plugin_legend = {
            id: "legend",
            _element: Legend,
            start(chart, _args, options) {
                const legend = chart.legend = new Legend({
                    ctx: chart.ctx,
                    options,
                    chart
                });
                layouts.configure(chart, legend, options);
                layouts.addBox(chart, legend);
            },
            stop(chart) {
                layouts.removeBox(chart, chart.legend);
                delete chart.legend;
            },
            beforeUpdate(chart, _args, options) {
                const legend = chart.legend;
                layouts.configure(chart, legend, options);
                legend.options = options;
            },
            afterUpdate(chart) {
                const legend = chart.legend;
                legend.buildLabels();
                legend.adjustHitBoxes();
            },
            afterEvent(chart, args) {
                if (!args.replay) chart.legend.handleEvent(args.event);
            },
            defaults: {
                display: true,
                position: "top",
                align: "center",
                fullSize: true,
                reverse: false,
                weight: 1e3,
                onClick(e, legendItem, legend) {
                    const index = legendItem.datasetIndex;
                    const ci = legend.chart;
                    if (ci.isDatasetVisible(index)) {
                        ci.hide(index);
                        legendItem.hidden = true;
                    } else {
                        ci.show(index);
                        legendItem.hidden = false;
                    }
                },
                onHover: null,
                onLeave: null,
                labels: {
                    color: ctx => ctx.chart.options.color,
                    boxWidth: 40,
                    padding: 10,
                    generateLabels(chart) {
                        const datasets = chart.data.datasets;
                        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;
                        return chart._getSortedDatasetMetas().map((meta => {
                            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                            const borderWidth = toPadding(style.borderWidth);
                            return {
                                text: datasets[meta.index].label,
                                fillStyle: style.backgroundColor,
                                fontColor: color,
                                hidden: !meta.visible,
                                lineCap: style.borderCapStyle,
                                lineDash: style.borderDash,
                                lineDashOffset: style.borderDashOffset,
                                lineJoin: style.borderJoinStyle,
                                lineWidth: (borderWidth.width + borderWidth.height) / 4,
                                strokeStyle: style.borderColor,
                                pointStyle: pointStyle || style.pointStyle,
                                rotation: style.rotation,
                                textAlign: textAlign || style.textAlign,
                                borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                                datasetIndex: meta.index
                            };
                        }), this);
                    }
                },
                title: {
                    color: ctx => ctx.chart.options.color,
                    display: false,
                    position: "center",
                    text: ""
                }
            },
            descriptors: {
                _scriptable: name => !name.startsWith("on"),
                labels: {
                    _scriptable: name => ![ "generateLabels", "filter", "sort" ].includes(name)
                }
            }
        };
        class Title extends Element {
            constructor(config) {
                super();
                this.chart = config.chart;
                this.options = config.options;
                this.ctx = config.ctx;
                this._padding = void 0;
                this.top = void 0;
                this.bottom = void 0;
                this.left = void 0;
                this.right = void 0;
                this.width = void 0;
                this.height = void 0;
                this.position = void 0;
                this.weight = void 0;
                this.fullSize = void 0;
            }
            update(maxWidth, maxHeight) {
                const opts = this.options;
                this.left = 0;
                this.top = 0;
                if (!opts.display) {
                    this.width = this.height = this.right = this.bottom = 0;
                    return;
                }
                this.width = this.right = maxWidth;
                this.height = this.bottom = maxHeight;
                const lineCount = isArray(opts.text) ? opts.text.length : 1;
                this._padding = toPadding(opts.padding);
                const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
                if (this.isHorizontal()) this.height = textSize; else this.width = textSize;
            }
            isHorizontal() {
                const pos = this.options.position;
                return pos === "top" || pos === "bottom";
            }
            _drawArgs(offset) {
                const {top, left, bottom, right, options} = this;
                const align = options.align;
                let rotation = 0;
                let maxWidth, titleX, titleY;
                if (this.isHorizontal()) {
                    titleX = _alignStartEnd(align, left, right);
                    titleY = top + offset;
                    maxWidth = right - left;
                } else {
                    if (options.position === "left") {
                        titleX = left + offset;
                        titleY = _alignStartEnd(align, bottom, top);
                        rotation = PI * -.5;
                    } else {
                        titleX = right - offset;
                        titleY = _alignStartEnd(align, top, bottom);
                        rotation = PI * .5;
                    }
                    maxWidth = bottom - top;
                }
                return {
                    titleX,
                    titleY,
                    maxWidth,
                    rotation
                };
            }
            draw() {
                const ctx = this.ctx;
                const opts = this.options;
                if (!opts.display) return;
                const fontOpts = toFont(opts.font);
                const lineHeight = fontOpts.lineHeight;
                const offset = lineHeight / 2 + this._padding.top;
                const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);
                renderText(ctx, opts.text, 0, 0, fontOpts, {
                    color: opts.color,
                    maxWidth,
                    rotation,
                    textAlign: _toLeftRightCenter(opts.align),
                    textBaseline: "middle",
                    translation: [ titleX, titleY ]
                });
            }
        }
        function createTitle(chart, titleOpts) {
            const title = new Title({
                ctx: chart.ctx,
                options: titleOpts,
                chart
            });
            layouts.configure(chart, title, titleOpts);
            layouts.addBox(chart, title);
            chart.titleBlock = title;
        }
        var plugin_title = {
            id: "title",
            _element: Title,
            start(chart, _args, options) {
                createTitle(chart, options);
            },
            stop(chart) {
                const titleBlock = chart.titleBlock;
                layouts.removeBox(chart, titleBlock);
                delete chart.titleBlock;
            },
            beforeUpdate(chart, _args, options) {
                const title = chart.titleBlock;
                layouts.configure(chart, title, options);
                title.options = options;
            },
            defaults: {
                align: "center",
                display: false,
                font: {
                    weight: "bold"
                },
                fullSize: true,
                padding: 10,
                position: "top",
                text: "",
                weight: 2e3
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: true,
                _indexable: false
            }
        };
        const chart_map = new WeakMap;
        var plugin_subtitle = {
            id: "subtitle",
            start(chart, _args, options) {
                const title = new Title({
                    ctx: chart.ctx,
                    options,
                    chart
                });
                layouts.configure(chart, title, options);
                layouts.addBox(chart, title);
                chart_map.set(chart, title);
            },
            stop(chart) {
                layouts.removeBox(chart, chart_map.get(chart));
                chart_map.delete(chart);
            },
            beforeUpdate(chart, _args, options) {
                const title = chart_map.get(chart);
                layouts.configure(chart, title, options);
                title.options = options;
            },
            defaults: {
                align: "center",
                display: false,
                font: {
                    weight: "normal"
                },
                fullSize: true,
                padding: 0,
                position: "top",
                text: "",
                weight: 1500
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: true,
                _indexable: false
            }
        };
        const positioners = {
            average(items) {
                if (!items.length) return false;
                let i, len;
                let x = 0;
                let y = 0;
                let count = 0;
                for (i = 0, len = items.length; i < len; ++i) {
                    const el = items[i].element;
                    if (el && el.hasValue()) {
                        const pos = el.tooltipPosition();
                        x += pos.x;
                        y += pos.y;
                        ++count;
                    }
                }
                return {
                    x: x / count,
                    y: y / count
                };
            },
            nearest(items, eventPosition) {
                if (!items.length) return false;
                let x = eventPosition.x;
                let y = eventPosition.y;
                let minDistance = Number.POSITIVE_INFINITY;
                let i, len, nearestElement;
                for (i = 0, len = items.length; i < len; ++i) {
                    const el = items[i].element;
                    if (el && el.hasValue()) {
                        const center = el.getCenterPoint();
                        const d = distanceBetweenPoints(eventPosition, center);
                        if (d < minDistance) {
                            minDistance = d;
                            nearestElement = el;
                        }
                    }
                }
                if (nearestElement) {
                    const tp = nearestElement.tooltipPosition();
                    x = tp.x;
                    y = tp.y;
                }
                return {
                    x,
                    y
                };
            }
        };
        function pushOrConcat(base, toPush) {
            if (toPush) if (isArray(toPush)) Array.prototype.push.apply(base, toPush); else base.push(toPush);
            return base;
        }
        function splitNewlines(str) {
            if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) return str.split("\n");
            return str;
        }
        function createTooltipItem(chart, item) {
            const {element, datasetIndex, index} = item;
            const controller = chart.getDatasetMeta(datasetIndex).controller;
            const {label, value} = controller.getLabelAndValue(index);
            return {
                chart,
                label,
                parsed: controller.getParsed(index),
                raw: chart.data.datasets[datasetIndex].data[index],
                formattedValue: value,
                dataset: controller.getDataset(),
                dataIndex: index,
                datasetIndex,
                element
            };
        }
        function getTooltipSize(tooltip, options) {
            const ctx = tooltip.chart.ctx;
            const {body, footer, title} = tooltip;
            const {boxWidth, boxHeight} = options;
            const bodyFont = toFont(options.bodyFont);
            const titleFont = toFont(options.titleFont);
            const footerFont = toFont(options.footerFont);
            const titleLineCount = title.length;
            const footerLineCount = footer.length;
            const bodyLineItemCount = body.length;
            const padding = toPadding(options.padding);
            let height = padding.height;
            let width = 0;
            let combinedBodyLength = body.reduce(((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length), 0);
            combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
            if (titleLineCount) height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
            if (combinedBodyLength) {
                const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
                height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
            }
            if (footerLineCount) height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
            let widthPadding = 0;
            const maxLineWidth = function(line) {
                width = Math.max(width, ctx.measureText(line).width + widthPadding);
            };
            ctx.save();
            ctx.font = titleFont.string;
            each(tooltip.title, maxLineWidth);
            ctx.font = bodyFont.string;
            each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
            widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
            each(body, (bodyItem => {
                each(bodyItem.before, maxLineWidth);
                each(bodyItem.lines, maxLineWidth);
                each(bodyItem.after, maxLineWidth);
            }));
            widthPadding = 0;
            ctx.font = footerFont.string;
            each(tooltip.footer, maxLineWidth);
            ctx.restore();
            width += padding.width;
            return {
                width,
                height
            };
        }
        function determineYAlign(chart, size) {
            const {y, height} = size;
            if (y < height / 2) return "top"; else if (y > chart.height - height / 2) return "bottom";
            return "center";
        }
        function doesNotFitWithAlign(xAlign, chart, options, size) {
            const {x, width} = size;
            const caret = options.caretSize + options.caretPadding;
            if (xAlign === "left" && x + width + caret > chart.width) return true;
            if (xAlign === "right" && x - width - caret < 0) return true;
        }
        function determineXAlign(chart, options, size, yAlign) {
            const {x, width} = size;
            const {width: chartWidth, chartArea: {left, right}} = chart;
            let xAlign = "center";
            if (yAlign === "center") xAlign = x <= (left + right) / 2 ? "left" : "right"; else if (x <= width / 2) xAlign = "left"; else if (x >= chartWidth - width / 2) xAlign = "right";
            if (doesNotFitWithAlign(xAlign, chart, options, size)) xAlign = "center";
            return xAlign;
        }
        function determineAlignment(chart, options, size) {
            const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
            return {
                xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
                yAlign
            };
        }
        function alignX(size, xAlign) {
            let {x, width} = size;
            if (xAlign === "right") x -= width; else if (xAlign === "center") x -= width / 2;
            return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
            let {y, height} = size;
            if (yAlign === "top") y += paddingAndSize; else if (yAlign === "bottom") y -= height + paddingAndSize; else y -= height / 2;
            return y;
        }
        function getBackgroundPoint(options, size, alignment, chart) {
            const {caretSize, caretPadding, cornerRadius} = options;
            const {xAlign, yAlign} = alignment;
            const paddingAndSize = caretSize + caretPadding;
            const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
            let x = alignX(size, xAlign);
            const y = alignY(size, yAlign, paddingAndSize);
            if (yAlign === "center") {
                if (xAlign === "left") x += paddingAndSize; else if (xAlign === "right") x -= paddingAndSize;
            } else if (xAlign === "left") x -= Math.max(topLeft, bottomLeft) + caretSize; else if (xAlign === "right") x += Math.max(topRight, bottomRight) + caretSize;
            return {
                x: _limitValue(x, 0, chart.width - size.width),
                y: _limitValue(y, 0, chart.height - size.height)
            };
        }
        function getAlignedX(tooltip, align, options) {
            const padding = toPadding(options.padding);
            return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback) {
            return pushOrConcat([], splitNewlines(callback));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
            return createContext(parent, {
                tooltip,
                tooltipItems,
                type: "tooltip"
            });
        }
        function overrideCallbacks(callbacks, context) {
            const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
            return override ? callbacks.override(override) : callbacks;
        }
        const defaultCallbacks = {
            beforeTitle: noop,
            title(tooltipItems) {
                if (tooltipItems.length > 0) {
                    const item = tooltipItems[0];
                    const labels = item.chart.data.labels;
                    const labelCount = labels ? labels.length : 0;
                    if (this && this.options && this.options.mode === "dataset") return item.dataset.label || ""; else if (item.label) return item.label; else if (labelCount > 0 && item.dataIndex < labelCount) return labels[item.dataIndex];
                }
                return "";
            },
            afterTitle: noop,
            beforeBody: noop,
            beforeLabel: noop,
            label(tooltipItem) {
                if (this && this.options && this.options.mode === "dataset") return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                let label = tooltipItem.dataset.label || "";
                if (label) label += ": ";
                const value = tooltipItem.formattedValue;
                if (!isNullOrUndef(value)) label += value;
                return label;
            },
            labelColor(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                    borderColor: options.borderColor,
                    backgroundColor: options.backgroundColor,
                    borderWidth: options.borderWidth,
                    borderDash: options.borderDash,
                    borderDashOffset: options.borderDashOffset,
                    borderRadius: 0
                };
            },
            labelTextColor() {
                return this.options.bodyColor;
            },
            labelPointStyle(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                    pointStyle: options.pointStyle,
                    rotation: options.rotation
                };
            },
            afterLabel: noop,
            afterBody: noop,
            beforeFooter: noop,
            footer: noop,
            afterFooter: noop
        };
        function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
            const result = callbacks[name].call(ctx, arg);
            if (typeof result === "undefined") return defaultCallbacks[name].call(ctx, arg);
            return result;
        }
        class Tooltip extends Element {
            static positioners=positioners;
            constructor(config) {
                super();
                this.opacity = 0;
                this._active = [];
                this._eventPosition = void 0;
                this._size = void 0;
                this._cachedAnimations = void 0;
                this._tooltipItems = [];
                this.$animations = void 0;
                this.$context = void 0;
                this.chart = config.chart;
                this.options = config.options;
                this.dataPoints = void 0;
                this.title = void 0;
                this.beforeBody = void 0;
                this.body = void 0;
                this.afterBody = void 0;
                this.footer = void 0;
                this.xAlign = void 0;
                this.yAlign = void 0;
                this.x = void 0;
                this.y = void 0;
                this.height = void 0;
                this.width = void 0;
                this.caretX = void 0;
                this.caretY = void 0;
                this.labelColors = void 0;
                this.labelPointStyles = void 0;
                this.labelTextColors = void 0;
            }
            initialize(options) {
                this.options = options;
                this._cachedAnimations = void 0;
                this.$context = void 0;
            }
            _resolveAnimations() {
                const cached = this._cachedAnimations;
                if (cached) return cached;
                const chart = this.chart;
                const options = this.options.setContext(this.getContext());
                const opts = options.enabled && chart.options.animation && options.animations;
                const animations = new Animations(this.chart, opts);
                if (opts._cacheable) this._cachedAnimations = Object.freeze(animations);
                return animations;
            }
            getContext() {
                return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
            }
            getTitle(context, options) {
                const {callbacks} = options;
                const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
                const title = invokeCallbackWithFallback(callbacks, "title", this, context);
                const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
                let lines = [];
                lines = pushOrConcat(lines, splitNewlines(beforeTitle));
                lines = pushOrConcat(lines, splitNewlines(title));
                lines = pushOrConcat(lines, splitNewlines(afterTitle));
                return lines;
            }
            getBeforeBody(tooltipItems, options) {
                return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
            }
            getBody(tooltipItems, options) {
                const {callbacks} = options;
                const bodyItems = [];
                each(tooltipItems, (context => {
                    const bodyItem = {
                        before: [],
                        lines: [],
                        after: []
                    };
                    const scoped = overrideCallbacks(callbacks, context);
                    pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
                    pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
                    pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
                    bodyItems.push(bodyItem);
                }));
                return bodyItems;
            }
            getAfterBody(tooltipItems, options) {
                return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
            }
            getFooter(tooltipItems, options) {
                const {callbacks} = options;
                const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
                const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
                const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
                let lines = [];
                lines = pushOrConcat(lines, splitNewlines(beforeFooter));
                lines = pushOrConcat(lines, splitNewlines(footer));
                lines = pushOrConcat(lines, splitNewlines(afterFooter));
                return lines;
            }
            _createItems(options) {
                const active = this._active;
                const data = this.chart.data;
                const labelColors = [];
                const labelPointStyles = [];
                const labelTextColors = [];
                let tooltipItems = [];
                let i, len;
                for (i = 0, len = active.length; i < len; ++i) tooltipItems.push(createTooltipItem(this.chart, active[i]));
                if (options.filter) tooltipItems = tooltipItems.filter(((element, index, array) => options.filter(element, index, array, data)));
                if (options.itemSort) tooltipItems = tooltipItems.sort(((a, b) => options.itemSort(a, b, data)));
                each(tooltipItems, (context => {
                    const scoped = overrideCallbacks(options.callbacks, context);
                    labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
                    labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
                    labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
                }));
                this.labelColors = labelColors;
                this.labelPointStyles = labelPointStyles;
                this.labelTextColors = labelTextColors;
                this.dataPoints = tooltipItems;
                return tooltipItems;
            }
            update(changed, replay) {
                const options = this.options.setContext(this.getContext());
                const active = this._active;
                let properties;
                let tooltipItems = [];
                if (!active.length) {
                    if (this.opacity !== 0) properties = {
                        opacity: 0
                    };
                } else {
                    const position = positioners[options.position].call(this, active, this._eventPosition);
                    tooltipItems = this._createItems(options);
                    this.title = this.getTitle(tooltipItems, options);
                    this.beforeBody = this.getBeforeBody(tooltipItems, options);
                    this.body = this.getBody(tooltipItems, options);
                    this.afterBody = this.getAfterBody(tooltipItems, options);
                    this.footer = this.getFooter(tooltipItems, options);
                    const size = this._size = getTooltipSize(this, options);
                    const positionAndSize = Object.assign({}, position, size);
                    const alignment = determineAlignment(this.chart, options, positionAndSize);
                    const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
                    this.xAlign = alignment.xAlign;
                    this.yAlign = alignment.yAlign;
                    properties = {
                        opacity: 1,
                        x: backgroundPoint.x,
                        y: backgroundPoint.y,
                        width: size.width,
                        height: size.height,
                        caretX: position.x,
                        caretY: position.y
                    };
                }
                this._tooltipItems = tooltipItems;
                this.$context = void 0;
                if (properties) this._resolveAnimations().update(this, properties);
                if (changed && options.external) options.external.call(this, {
                    chart: this.chart,
                    tooltip: this,
                    replay
                });
            }
            drawCaret(tooltipPoint, ctx, size, options) {
                const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
                ctx.lineTo(caretPosition.x1, caretPosition.y1);
                ctx.lineTo(caretPosition.x2, caretPosition.y2);
                ctx.lineTo(caretPosition.x3, caretPosition.y3);
            }
            getCaretPosition(tooltipPoint, size, options) {
                const {xAlign, yAlign} = this;
                const {caretSize, cornerRadius} = options;
                const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
                const {x: ptX, y: ptY} = tooltipPoint;
                const {width, height} = size;
                let x1, x2, x3, y1, y2, y3;
                if (yAlign === "center") {
                    y2 = ptY + height / 2;
                    if (xAlign === "left") {
                        x1 = ptX;
                        x2 = x1 - caretSize;
                        y1 = y2 + caretSize;
                        y3 = y2 - caretSize;
                    } else {
                        x1 = ptX + width;
                        x2 = x1 + caretSize;
                        y1 = y2 - caretSize;
                        y3 = y2 + caretSize;
                    }
                    x3 = x1;
                } else {
                    if (xAlign === "left") x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize; else if (xAlign === "right") x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize; else x2 = this.caretX;
                    if (yAlign === "top") {
                        y1 = ptY;
                        y2 = y1 - caretSize;
                        x1 = x2 - caretSize;
                        x3 = x2 + caretSize;
                    } else {
                        y1 = ptY + height;
                        y2 = y1 + caretSize;
                        x1 = x2 + caretSize;
                        x3 = x2 - caretSize;
                    }
                    y3 = y1;
                }
                return {
                    x1,
                    x2,
                    x3,
                    y1,
                    y2,
                    y3
                };
            }
            drawTitle(pt, ctx, options) {
                const title = this.title;
                const length = title.length;
                let titleFont, titleSpacing, i;
                if (length) {
                    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                    pt.x = getAlignedX(this, options.titleAlign, options);
                    ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
                    ctx.textBaseline = "middle";
                    titleFont = toFont(options.titleFont);
                    titleSpacing = options.titleSpacing;
                    ctx.fillStyle = options.titleColor;
                    ctx.font = titleFont.string;
                    for (i = 0; i < length; ++i) {
                        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                        pt.y += titleFont.lineHeight + titleSpacing;
                        if (i + 1 === length) pt.y += options.titleMarginBottom - titleSpacing;
                    }
                }
            }
            _drawColorBox(ctx, pt, i, rtlHelper, options) {
                const labelColor = this.labelColors[i];
                const labelPointStyle = this.labelPointStyles[i];
                const {boxHeight, boxWidth} = options;
                const bodyFont = toFont(options.bodyFont);
                const colorX = getAlignedX(this, "left", options);
                const rtlColorX = rtlHelper.x(colorX);
                const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
                const colorY = pt.y + yOffSet;
                if (options.usePointStyle) {
                    const drawOptions = {
                        radius: Math.min(boxWidth, boxHeight) / 2,
                        pointStyle: labelPointStyle.pointStyle,
                        rotation: labelPointStyle.rotation,
                        borderWidth: 1
                    };
                    const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
                    const centerY = colorY + boxHeight / 2;
                    ctx.strokeStyle = options.multiKeyBackground;
                    ctx.fillStyle = options.multiKeyBackground;
                    drawPoint(ctx, drawOptions, centerX, centerY);
                    ctx.strokeStyle = labelColor.borderColor;
                    ctx.fillStyle = labelColor.backgroundColor;
                    drawPoint(ctx, drawOptions, centerX, centerY);
                } else {
                    ctx.lineWidth = helpers_segment_isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
                    ctx.strokeStyle = labelColor.borderColor;
                    ctx.setLineDash(labelColor.borderDash || []);
                    ctx.lineDashOffset = labelColor.borderDashOffset || 0;
                    const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
                    const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
                    const borderRadius = toTRBLCorners(labelColor.borderRadius);
                    if (Object.values(borderRadius).some((v => v !== 0))) {
                        ctx.beginPath();
                        ctx.fillStyle = options.multiKeyBackground;
                        addRoundedRectPath(ctx, {
                            x: outerX,
                            y: colorY,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius
                        });
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = labelColor.backgroundColor;
                        ctx.beginPath();
                        addRoundedRectPath(ctx, {
                            x: innerX,
                            y: colorY + 1,
                            w: boxWidth - 2,
                            h: boxHeight - 2,
                            radius: borderRadius
                        });
                        ctx.fill();
                    } else {
                        ctx.fillStyle = options.multiKeyBackground;
                        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                        ctx.fillStyle = labelColor.backgroundColor;
                        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
                    }
                }
                ctx.fillStyle = this.labelTextColors[i];
            }
            drawBody(pt, ctx, options) {
                const {body} = this;
                const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
                const bodyFont = toFont(options.bodyFont);
                let bodyLineHeight = bodyFont.lineHeight;
                let xLinePadding = 0;
                const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                const fillLineOfText = function(line) {
                    ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
                    pt.y += bodyLineHeight + bodySpacing;
                };
                const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
                let bodyItem, textColor, lines, i, j, ilen, jlen;
                ctx.textAlign = bodyAlign;
                ctx.textBaseline = "middle";
                ctx.font = bodyFont.string;
                pt.x = getAlignedX(this, bodyAlignForCalculation, options);
                ctx.fillStyle = options.bodyColor;
                each(this.beforeBody, fillLineOfText);
                xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
                for (i = 0, ilen = body.length; i < ilen; ++i) {
                    bodyItem = body[i];
                    textColor = this.labelTextColors[i];
                    ctx.fillStyle = textColor;
                    each(bodyItem.before, fillLineOfText);
                    lines = bodyItem.lines;
                    if (displayColors && lines.length) {
                        this._drawColorBox(ctx, pt, i, rtlHelper, options);
                        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
                    }
                    for (j = 0, jlen = lines.length; j < jlen; ++j) {
                        fillLineOfText(lines[j]);
                        bodyLineHeight = bodyFont.lineHeight;
                    }
                    each(bodyItem.after, fillLineOfText);
                }
                xLinePadding = 0;
                bodyLineHeight = bodyFont.lineHeight;
                each(this.afterBody, fillLineOfText);
                pt.y -= bodySpacing;
            }
            drawFooter(pt, ctx, options) {
                const footer = this.footer;
                const length = footer.length;
                let footerFont, i;
                if (length) {
                    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                    pt.x = getAlignedX(this, options.footerAlign, options);
                    pt.y += options.footerMarginTop;
                    ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
                    ctx.textBaseline = "middle";
                    footerFont = toFont(options.footerFont);
                    ctx.fillStyle = options.footerColor;
                    ctx.font = footerFont.string;
                    for (i = 0; i < length; ++i) {
                        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                        pt.y += footerFont.lineHeight + options.footerSpacing;
                    }
                }
            }
            drawBackground(pt, ctx, tooltipSize, options) {
                const {xAlign, yAlign} = this;
                const {x, y} = pt;
                const {width, height} = tooltipSize;
                const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
                ctx.fillStyle = options.backgroundColor;
                ctx.strokeStyle = options.borderColor;
                ctx.lineWidth = options.borderWidth;
                ctx.beginPath();
                ctx.moveTo(x + topLeft, y);
                if (yAlign === "top") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + width - topRight, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
                if (yAlign === "center" && xAlign === "right") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + width, y + height - bottomRight);
                ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
                if (yAlign === "bottom") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + bottomLeft, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
                if (yAlign === "center" && xAlign === "left") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x, y + topLeft);
                ctx.quadraticCurveTo(x, y, x + topLeft, y);
                ctx.closePath();
                ctx.fill();
                if (options.borderWidth > 0) ctx.stroke();
            }
            _updateAnimationTarget(options) {
                const chart = this.chart;
                const anims = this.$animations;
                const animX = anims && anims.x;
                const animY = anims && anims.y;
                if (animX || animY) {
                    const position = positioners[options.position].call(this, this._active, this._eventPosition);
                    if (!position) return;
                    const size = this._size = getTooltipSize(this, options);
                    const positionAndSize = Object.assign({}, position, this._size);
                    const alignment = determineAlignment(chart, options, positionAndSize);
                    const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
                    if (animX._to !== point.x || animY._to !== point.y) {
                        this.xAlign = alignment.xAlign;
                        this.yAlign = alignment.yAlign;
                        this.width = size.width;
                        this.height = size.height;
                        this.caretX = position.x;
                        this.caretY = position.y;
                        this._resolveAnimations().update(this, point);
                    }
                }
            }
            _willRender() {
                return !!this.opacity;
            }
            draw(ctx) {
                const options = this.options.setContext(this.getContext());
                let opacity = this.opacity;
                if (!opacity) return;
                this._updateAnimationTarget(options);
                const tooltipSize = {
                    width: this.width,
                    height: this.height
                };
                const pt = {
                    x: this.x,
                    y: this.y
                };
                opacity = Math.abs(opacity) < .001 ? 0 : opacity;
                const padding = toPadding(options.padding);
                const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
                if (options.enabled && hasTooltipContent) {
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    this.drawBackground(pt, ctx, tooltipSize, options);
                    overrideTextDirection(ctx, options.textDirection);
                    pt.y += padding.top;
                    this.drawTitle(pt, ctx, options);
                    this.drawBody(pt, ctx, options);
                    this.drawFooter(pt, ctx, options);
                    restoreTextDirection(ctx, options.textDirection);
                    ctx.restore();
                }
            }
            getActiveElements() {
                return this._active || [];
            }
            setActiveElements(activeElements, eventPosition) {
                const lastActive = this._active;
                const active = activeElements.map((({datasetIndex, index}) => {
                    const meta = this.chart.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("Cannot find a dataset at index " + datasetIndex);
                    return {
                        datasetIndex,
                        element: meta.data[index],
                        index
                    };
                }));
                const changed = !_elementsEqual(lastActive, active);
                const positionChanged = this._positionChanged(active, eventPosition);
                if (changed || positionChanged) {
                    this._active = active;
                    this._eventPosition = eventPosition;
                    this._ignoreReplayEvents = true;
                    this.update(true);
                }
            }
            handleEvent(e, replay, inChartArea = true) {
                if (replay && this._ignoreReplayEvents) return false;
                this._ignoreReplayEvents = false;
                const options = this.options;
                const lastActive = this._active || [];
                const active = this._getActiveElements(e, lastActive, replay, inChartArea);
                const positionChanged = this._positionChanged(active, e);
                const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
                if (changed) {
                    this._active = active;
                    if (options.enabled || options.external) {
                        this._eventPosition = {
                            x: e.x,
                            y: e.y
                        };
                        this.update(true, replay);
                    }
                }
                return changed;
            }
            _getActiveElements(e, lastActive, replay, inChartArea) {
                const options = this.options;
                if (e.type === "mouseout") return [];
                if (!inChartArea) return lastActive;
                const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
                if (options.reverse) active.reverse();
                return active;
            }
            _positionChanged(active, e) {
                const {caretX, caretY, options} = this;
                const position = positioners[options.position].call(this, active, e);
                return position !== false && (caretX !== position.x || caretY !== position.y);
            }
        }
        var plugin_tooltip = {
            id: "tooltip",
            _element: Tooltip,
            positioners,
            afterInit(chart, _args, options) {
                if (options) chart.tooltip = new Tooltip({
                    chart,
                    options
                });
            },
            beforeUpdate(chart, _args, options) {
                if (chart.tooltip) chart.tooltip.initialize(options);
            },
            reset(chart, _args, options) {
                if (chart.tooltip) chart.tooltip.initialize(options);
            },
            afterDraw(chart) {
                const tooltip = chart.tooltip;
                if (tooltip && tooltip._willRender()) {
                    const args = {
                        tooltip
                    };
                    if (chart.notifyPlugins("beforeTooltipDraw", {
                        ...args,
                        cancelable: true
                    }) === false) return;
                    tooltip.draw(chart.ctx);
                    chart.notifyPlugins("afterTooltipDraw", args);
                }
            },
            afterEvent(chart, args) {
                if (chart.tooltip) {
                    const useFinalPosition = args.replay;
                    if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) args.changed = true;
                }
            },
            defaults: {
                enabled: true,
                external: null,
                position: "average",
                backgroundColor: "rgba(0,0,0,0.8)",
                titleColor: "#fff",
                titleFont: {
                    weight: "bold"
                },
                titleSpacing: 2,
                titleMarginBottom: 6,
                titleAlign: "left",
                bodyColor: "#fff",
                bodySpacing: 2,
                bodyFont: {},
                bodyAlign: "left",
                footerColor: "#fff",
                footerSpacing: 2,
                footerMarginTop: 6,
                footerFont: {
                    weight: "bold"
                },
                footerAlign: "left",
                padding: 6,
                caretPadding: 2,
                caretSize: 5,
                cornerRadius: 6,
                boxHeight: (ctx, opts) => opts.bodyFont.size,
                boxWidth: (ctx, opts) => opts.bodyFont.size,
                multiKeyBackground: "#fff",
                displayColors: true,
                boxPadding: 0,
                borderColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                animation: {
                    duration: 400,
                    easing: "easeOutQuart"
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "width", "height", "caretX", "caretY" ]
                    },
                    opacity: {
                        easing: "linear",
                        duration: 200
                    }
                },
                callbacks: defaultCallbacks
            },
            defaultRoutes: {
                bodyFont: "font",
                footerFont: "font",
                titleFont: "font"
            },
            descriptors: {
                _scriptable: name => name !== "filter" && name !== "itemSort" && name !== "external",
                _indexable: false,
                callbacks: {
                    _scriptable: false,
                    _indexable: false
                },
                animation: {
                    _fallback: false
                },
                animations: {
                    _fallback: "animation"
                }
            },
            additionalOptionScopes: [ "interaction" ]
        };
        var plugins = Object.freeze({
            __proto__: null,
            Colors: plugin_colors,
            Decimation: plugin_decimation,
            Filler: index,
            Legend: plugin_legend,
            SubTitle: plugin_subtitle,
            Title: plugin_title,
            Tooltip: plugin_tooltip
        });
        const addIfString = (labels, raw, index, addedLabels) => {
            if (typeof raw === "string") {
                index = labels.push(raw) - 1;
                addedLabels.unshift({
                    index,
                    label: raw
                });
            } else if (isNaN(raw)) index = null;
            return index;
        };
        function findOrAddLabel(labels, raw, index, addedLabels) {
            const first = labels.indexOf(raw);
            if (first === -1) return addIfString(labels, raw, index, addedLabels);
            const last = labels.lastIndexOf(raw);
            return first !== last ? index : first;
        }
        const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
        function _getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) return labels[value];
            return value;
        }
        class CategoryScale extends Scale {
            static id="category";
            static defaults={
                ticks: {
                    callback: _getLabelForValue
                }
            };
            constructor(cfg) {
                super(cfg);
                this._startValue = void 0;
                this._valueRange = 0;
                this._addedLabels = [];
            }
            init(scaleOptions) {
                const added = this._addedLabels;
                if (added.length) {
                    const labels = this.getLabels();
                    for (const {index, label} of added) if (labels[index] === label) labels.splice(index, 1);
                    this._addedLabels = [];
                }
                super.init(scaleOptions);
            }
            parse(raw, index) {
                if (isNullOrUndef(raw)) return null;
                const labels = this.getLabels();
                index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
                return validIndex(index, labels.length - 1);
            }
            determineDataLimits() {
                const {minDefined, maxDefined} = this.getUserBounds();
                let {min, max} = this.getMinMax(true);
                if (this.options.bounds === "ticks") {
                    if (!minDefined) min = 0;
                    if (!maxDefined) max = this.getLabels().length - 1;
                }
                this.min = min;
                this.max = max;
            }
            buildTicks() {
                const min = this.min;
                const max = this.max;
                const offset = this.options.offset;
                const ticks = [];
                let labels = this.getLabels();
                labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
                this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
                this._startValue = this.min - (offset ? .5 : 0);
                for (let value = min; value <= max; value++) ticks.push({
                    value
                });
                return ticks;
            }
            getLabelForValue(value) {
                return _getLabelForValue.call(this, value);
            }
            configure() {
                super.configure();
                if (!this.isHorizontal()) this._reversePixels = !this._reversePixels;
            }
            getPixelForValue(value) {
                if (typeof value !== "number") value = this.parse(value);
                return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
            }
            getPixelForTick(index) {
                const ticks = this.ticks;
                if (index < 0 || index > ticks.length - 1) return null;
                return this.getPixelForValue(ticks[index].value);
            }
            getValueForPixel(pixel) {
                return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
            }
            getBasePixel() {
                return this.bottom;
            }
        }
        function generateTicks$1(generationOptions, dataRange) {
            const ticks = [];
            const MIN_SPACING = 1e-14;
            const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
            const unit = step || 1;
            const maxSpaces = maxTicks - 1;
            const {min: rmin, max: rmax} = dataRange;
            const minDefined = !isNullOrUndef(min);
            const maxDefined = !isNullOrUndef(max);
            const countDefined = !isNullOrUndef(count);
            const minSpacing = (rmax - rmin) / (maxDigits + 1);
            let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
            let factor, niceMin, niceMax, numSpaces;
            if (spacing < MIN_SPACING && !minDefined && !maxDefined) return [ {
                value: rmin
            }, {
                value: rmax
            } ];
            numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
            if (numSpaces > maxSpaces) spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
            if (!isNullOrUndef(precision)) {
                factor = Math.pow(10, precision);
                spacing = Math.ceil(spacing * factor) / factor;
            }
            if (bounds === "ticks") {
                niceMin = Math.floor(rmin / spacing) * spacing;
                niceMax = Math.ceil(rmax / spacing) * spacing;
            } else {
                niceMin = rmin;
                niceMax = rmax;
            }
            if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
                numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
                spacing = (max - min) / numSpaces;
                niceMin = min;
                niceMax = max;
            } else if (countDefined) {
                niceMin = minDefined ? min : niceMin;
                niceMax = maxDefined ? max : niceMax;
                numSpaces = count - 1;
                spacing = (niceMax - niceMin) / numSpaces;
            } else {
                numSpaces = (niceMax - niceMin) / spacing;
                if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) numSpaces = Math.round(numSpaces); else numSpaces = Math.ceil(numSpaces);
            }
            const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
            factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
            niceMin = Math.round(niceMin * factor) / factor;
            niceMax = Math.round(niceMax * factor) / factor;
            let j = 0;
            if (minDefined) if (includeBounds && niceMin !== min) {
                ticks.push({
                    value: min
                });
                if (niceMin < min) j++;
                if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) j++;
            } else if (niceMin < min) j++;
            for (;j < numSpaces; ++j) {
                const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
                if (maxDefined && tickValue > max) break;
                ticks.push({
                    value: tickValue
                });
            }
            if (maxDefined && includeBounds && niceMax !== max) if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) ticks[ticks.length - 1].value = max; else ticks.push({
                value: max
            }); else if (!maxDefined || niceMax === max) ticks.push({
                value: niceMax
            });
            return ticks;
        }
        function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
            const rad = toRadians(minRotation);
            const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || .001;
            const length = .75 * minSpacing * ("" + value).length;
            return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
            constructor(cfg) {
                super(cfg);
                this.start = void 0;
                this.end = void 0;
                this._startValue = void 0;
                this._endValue = void 0;
                this._valueRange = 0;
            }
            parse(raw, index) {
                if (isNullOrUndef(raw)) return null;
                if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) return null;
                return +raw;
            }
            handleTickRangeOptions() {
                const {beginAtZero} = this.options;
                const {minDefined, maxDefined} = this.getUserBounds();
                let {min, max} = this;
                const setMin = v => min = minDefined ? min : v;
                const setMax = v => max = maxDefined ? max : v;
                if (beginAtZero) {
                    const minSign = sign(min);
                    const maxSign = sign(max);
                    if (minSign < 0 && maxSign < 0) setMax(0); else if (minSign > 0 && maxSign > 0) setMin(0);
                }
                if (min === max) {
                    let offset = max === 0 ? 1 : Math.abs(max * .05);
                    setMax(max + offset);
                    if (!beginAtZero) setMin(min - offset);
                }
                this.min = min;
                this.max = max;
            }
            getTickLimit() {
                const tickOpts = this.options.ticks;
                let {maxTicksLimit, stepSize} = tickOpts;
                let maxTicks;
                if (stepSize) {
                    maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
                    if (maxTicks > 1e3) {
                        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                        maxTicks = 1e3;
                    }
                } else {
                    maxTicks = this.computeTickLimit();
                    maxTicksLimit = maxTicksLimit || 11;
                }
                if (maxTicksLimit) maxTicks = Math.min(maxTicksLimit, maxTicks);
                return maxTicks;
            }
            computeTickLimit() {
                return Number.POSITIVE_INFINITY;
            }
            buildTicks() {
                const opts = this.options;
                const tickOpts = opts.ticks;
                let maxTicks = this.getTickLimit();
                maxTicks = Math.max(2, maxTicks);
                const numericGeneratorOptions = {
                    maxTicks,
                    bounds: opts.bounds,
                    min: opts.min,
                    max: opts.max,
                    precision: tickOpts.precision,
                    step: tickOpts.stepSize,
                    count: tickOpts.count,
                    maxDigits: this._maxDigits(),
                    horizontal: this.isHorizontal(),
                    minRotation: tickOpts.minRotation || 0,
                    includeBounds: tickOpts.includeBounds !== false
                };
                const dataRange = this._range || this;
                const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
                if (opts.bounds === "ticks") _setMinAndMaxByKey(ticks, this, "value");
                if (opts.reverse) {
                    ticks.reverse();
                    this.start = this.max;
                    this.end = this.min;
                } else {
                    this.start = this.min;
                    this.end = this.max;
                }
                return ticks;
            }
            configure() {
                const ticks = this.ticks;
                let start = this.min;
                let end = this.max;
                super.configure();
                if (this.options.offset && ticks.length) {
                    const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                    start -= offset;
                    end += offset;
                }
                this._startValue = start;
                this._endValue = end;
                this._valueRange = end - start;
            }
            getLabelForValue(value) {
                return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
            }
        }
        class LinearScale extends LinearScaleBase {
            static id="linear";
            static defaults={
                ticks: {
                    callback: Ticks.formatters.numeric
                }
            };
            determineDataLimits() {
                const {min, max} = this.getMinMax(true);
                this.min = isNumberFinite(min) ? min : 0;
                this.max = isNumberFinite(max) ? max : 1;
                this.handleTickRangeOptions();
            }
            computeTickLimit() {
                const horizontal = this.isHorizontal();
                const length = horizontal ? this.width : this.height;
                const minRotation = toRadians(this.options.ticks.minRotation);
                const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || .001;
                const tickFont = this._resolveTickFontOptions(0);
                return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
            }
            getPixelForValue(value) {
                return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
            }
            getValueForPixel(pixel) {
                return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
            }
        }
        const log10Floor = v => Math.floor(log10(v));
        const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
        function isMajor(tickVal) {
            const remain = tickVal / Math.pow(10, log10Floor(tickVal));
            return remain === 1;
        }
        function steps(min, max, rangeExp) {
            const rangeStep = Math.pow(10, rangeExp);
            const start = Math.floor(min / rangeStep);
            const end = Math.ceil(max / rangeStep);
            return end - start;
        }
        function startExp(min, max) {
            const range = max - min;
            let rangeExp = log10Floor(range);
            while (steps(min, max, rangeExp) > 10) rangeExp++;
            while (steps(min, max, rangeExp) < 10) rangeExp--;
            return Math.min(rangeExp, log10Floor(min));
        }
        function generateTicks(generationOptions, {min, max}) {
            min = finiteOrDefault(generationOptions.min, min);
            const ticks = [];
            const minExp = log10Floor(min);
            let exp = startExp(min, max);
            let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
            const stepSize = Math.pow(10, exp);
            const base = minExp > exp ? Math.pow(10, minExp) : 0;
            const start = Math.round((min - base) * precision) / precision;
            const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
            let significand = Math.floor((start - offset) / Math.pow(10, exp));
            let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
            while (value < max) {
                ticks.push({
                    value,
                    major: isMajor(value),
                    significand
                });
                if (significand >= 10) significand = significand < 15 ? 15 : 20; else significand++;
                if (significand >= 20) {
                    exp++;
                    significand = 2;
                    precision = exp >= 0 ? 1 : precision;
                }
                value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
            }
            const lastTick = finiteOrDefault(generationOptions.max, value);
            ticks.push({
                value: lastTick,
                major: isMajor(lastTick),
                significand
            });
            return ticks;
        }
        class LogarithmicScale extends Scale {
            static id="logarithmic";
            static defaults={
                ticks: {
                    callback: Ticks.formatters.logarithmic,
                    major: {
                        enabled: true
                    }
                }
            };
            constructor(cfg) {
                super(cfg);
                this.start = void 0;
                this.end = void 0;
                this._startValue = void 0;
                this._valueRange = 0;
            }
            parse(raw, index) {
                const value = LinearScaleBase.prototype.parse.apply(this, [ raw, index ]);
                if (value === 0) {
                    this._zero = true;
                    return;
                }
                return isNumberFinite(value) && value > 0 ? value : null;
            }
            determineDataLimits() {
                const {min, max} = this.getMinMax(true);
                this.min = isNumberFinite(min) ? Math.max(0, min) : null;
                this.max = isNumberFinite(max) ? Math.max(0, max) : null;
                if (this.options.beginAtZero) this._zero = true;
                if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
                this.handleTickRangeOptions();
            }
            handleTickRangeOptions() {
                const {minDefined, maxDefined} = this.getUserBounds();
                let min = this.min;
                let max = this.max;
                const setMin = v => min = minDefined ? min : v;
                const setMax = v => max = maxDefined ? max : v;
                if (min === max) if (min <= 0) {
                    setMin(1);
                    setMax(10);
                } else {
                    setMin(changeExponent(min, -1));
                    setMax(changeExponent(max, +1));
                }
                if (min <= 0) setMin(changeExponent(max, -1));
                if (max <= 0) setMax(changeExponent(min, +1));
                this.min = min;
                this.max = max;
            }
            buildTicks() {
                const opts = this.options;
                const generationOptions = {
                    min: this._userMin,
                    max: this._userMax
                };
                const ticks = generateTicks(generationOptions, this);
                if (opts.bounds === "ticks") _setMinAndMaxByKey(ticks, this, "value");
                if (opts.reverse) {
                    ticks.reverse();
                    this.start = this.max;
                    this.end = this.min;
                } else {
                    this.start = this.min;
                    this.end = this.max;
                }
                return ticks;
            }
            getLabelForValue(value) {
                return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
            }
            configure() {
                const start = this.min;
                super.configure();
                this._startValue = log10(start);
                this._valueRange = log10(this.max) - log10(start);
            }
            getPixelForValue(value) {
                if (value === void 0 || value === 0) value = this.min;
                if (value === null || isNaN(value)) return NaN;
                return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
            }
            getValueForPixel(pixel) {
                const decimal = this.getDecimalForPixel(pixel);
                return Math.pow(10, this._startValue + decimal * this._valueRange);
            }
        }
        function getTickBackdropHeight(opts) {
            const tickOpts = opts.ticks;
            if (tickOpts.display && opts.display) {
                const padding = toPadding(tickOpts.backdropPadding);
                return valueOrDefault(tickOpts.font && tickOpts.font.size, helpers_segment_defaults.font.size) + padding.height;
            }
            return 0;
        }
        function measureLabelSize(ctx, font, label) {
            label = isArray(label) ? label : [ label ];
            return {
                w: _longestText(ctx, font.string, label),
                h: label.length * font.lineHeight
            };
        }
        function determineLimits(angle, pos, size, min, max) {
            if (angle === min || angle === max) return {
                start: pos - size / 2,
                end: pos + size / 2
            }; else if (angle < min || angle > max) return {
                start: pos - size,
                end: pos
            };
            return {
                start: pos,
                end: pos + size
            };
        }
        function fitWithPointLabels(scale) {
            const orig = {
                l: scale.left + scale._padding.left,
                r: scale.right - scale._padding.right,
                t: scale.top + scale._padding.top,
                b: scale.bottom - scale._padding.bottom
            };
            const limits = Object.assign({}, orig);
            const labelSizes = [];
            const padding = [];
            const valueCount = scale._pointLabels.length;
            const pointLabelOpts = scale.options.pointLabels;
            const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
            for (let i = 0; i < valueCount; i++) {
                const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
                padding[i] = opts.padding;
                const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
                const plFont = toFont(opts.font);
                const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
                labelSizes[i] = textSize;
                const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
                const angle = Math.round(toDegrees(angleRadians));
                const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
                const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
                updateLimits(limits, orig, angleRadians, hLimits, vLimits);
            }
            scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
            scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
            const sin = Math.abs(Math.sin(angle));
            const cos = Math.abs(Math.cos(angle));
            let x = 0;
            let y = 0;
            if (hLimits.start < orig.l) {
                x = (orig.l - hLimits.start) / sin;
                limits.l = Math.min(limits.l, orig.l - x);
            } else if (hLimits.end > orig.r) {
                x = (hLimits.end - orig.r) / sin;
                limits.r = Math.max(limits.r, orig.r + x);
            }
            if (vLimits.start < orig.t) {
                y = (orig.t - vLimits.start) / cos;
                limits.t = Math.min(limits.t, orig.t - y);
            } else if (vLimits.end > orig.b) {
                y = (vLimits.end - orig.b) / cos;
                limits.b = Math.max(limits.b, orig.b + y);
            }
        }
        function createPointLabelItem(scale, index, itemOpts) {
            const outerDistance = scale.drawingArea;
            const {extra, additionalAngle, padding, size} = itemOpts;
            const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
            const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
            const y = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
            return {
                visible: true,
                x: pointLabelPosition.x,
                y,
                textAlign,
                left,
                top: y,
                right: left + size.w,
                bottom: y + size.h
            };
        }
        function isNotOverlapped(item, area) {
            if (!area) return true;
            const {left, top, right, bottom} = item;
            const apexesInArea = _isPointInArea({
                x: left,
                y: top
            }, area) || _isPointInArea({
                x: left,
                y: bottom
            }, area) || _isPointInArea({
                x: right,
                y: top
            }, area) || _isPointInArea({
                x: right,
                y: bottom
            }, area);
            return !apexesInArea;
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
            const items = [];
            const valueCount = scale._pointLabels.length;
            const opts = scale.options;
            const {centerPointLabels, display} = opts.pointLabels;
            const itemOpts = {
                extra: getTickBackdropHeight(opts) / 2,
                additionalAngle: centerPointLabels ? PI / valueCount : 0
            };
            let area;
            for (let i = 0; i < valueCount; i++) {
                itemOpts.padding = padding[i];
                itemOpts.size = labelSizes[i];
                const item = createPointLabelItem(scale, i, itemOpts);
                items.push(item);
                if (display === "auto") {
                    item.visible = isNotOverlapped(item, area);
                    if (item.visible) area = item;
                }
            }
            return items;
        }
        function getTextAlignForAngle(angle) {
            if (angle === 0 || angle === 180) return "center"; else if (angle < 180) return "left";
            return "right";
        }
        function leftForTextAlign(x, w, align) {
            if (align === "right") x -= w; else if (align === "center") x -= w / 2;
            return x;
        }
        function yForAngle(y, h, angle) {
            if (angle === 90 || angle === 270) y -= h / 2; else if (angle > 270 || angle < 90) y -= h;
            return y;
        }
        function drawPointLabelBox(ctx, opts, item) {
            const {left, top, right, bottom} = item;
            const {backdropColor} = opts;
            if (!isNullOrUndef(backdropColor)) {
                const borderRadius = toTRBLCorners(opts.borderRadius);
                const padding = toPadding(opts.backdropPadding);
                ctx.fillStyle = backdropColor;
                const backdropLeft = left - padding.left;
                const backdropTop = top - padding.top;
                const backdropWidth = right - left + padding.width;
                const backdropHeight = bottom - top + padding.height;
                if (Object.values(borderRadius).some((v => v !== 0))) {
                    ctx.beginPath();
                    addRoundedRectPath(ctx, {
                        x: backdropLeft,
                        y: backdropTop,
                        w: backdropWidth,
                        h: backdropHeight,
                        radius: borderRadius
                    });
                    ctx.fill();
                } else ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
            }
        }
        function drawPointLabels(scale, labelCount) {
            const {ctx, options: {pointLabels}} = scale;
            for (let i = labelCount - 1; i >= 0; i--) {
                const item = scale._pointLabelItems[i];
                if (!item.visible) continue;
                const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
                drawPointLabelBox(ctx, optsAtIndex, item);
                const plFont = toFont(optsAtIndex.font);
                const {x, y, textAlign} = item;
                renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
                    color: optsAtIndex.color,
                    textAlign,
                    textBaseline: "middle"
                });
            }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
            const {ctx} = scale;
            if (circular) ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU); else {
                let pointPosition = scale.getPointPosition(0, radius);
                ctx.moveTo(pointPosition.x, pointPosition.y);
                for (let i = 1; i < labelCount; i++) {
                    pointPosition = scale.getPointPosition(i, radius);
                    ctx.lineTo(pointPosition.x, pointPosition.y);
                }
            }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
            const ctx = scale.ctx;
            const circular = gridLineOpts.circular;
            const {color, lineWidth} = gridLineOpts;
            if (!circular && !labelCount || !color || !lineWidth || radius < 0) return;
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash(borderOpts.dash);
            ctx.lineDashOffset = borderOpts.dashOffset;
            ctx.beginPath();
            pathRadiusLine(scale, radius, circular, labelCount);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }
        function createPointLabelContext(parent, index, label) {
            return createContext(parent, {
                label,
                index,
                type: "pointLabel"
            });
        }
        class RadialLinearScale extends LinearScaleBase {
            static id="radialLinear";
            static defaults={
                display: true,
                animate: true,
                position: "chartArea",
                angleLines: {
                    display: true,
                    lineWidth: 1,
                    borderDash: [],
                    borderDashOffset: 0
                },
                grid: {
                    circular: false
                },
                startAngle: 0,
                ticks: {
                    showLabelBackdrop: true,
                    callback: Ticks.formatters.numeric
                },
                pointLabels: {
                    backdropColor: void 0,
                    backdropPadding: 2,
                    display: true,
                    font: {
                        size: 10
                    },
                    callback(label) {
                        return label;
                    },
                    padding: 5,
                    centerPointLabels: false
                }
            };
            static defaultRoutes={
                "angleLines.color": "borderColor",
                "pointLabels.color": "color",
                "ticks.color": "color"
            };
            static descriptors={
                angleLines: {
                    _fallback: "grid"
                }
            };
            constructor(cfg) {
                super(cfg);
                this.xCenter = void 0;
                this.yCenter = void 0;
                this.drawingArea = void 0;
                this._pointLabels = [];
                this._pointLabelItems = [];
            }
            setDimensions() {
                const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
                const w = this.width = this.maxWidth - padding.width;
                const h = this.height = this.maxHeight - padding.height;
                this.xCenter = Math.floor(this.left + w / 2 + padding.left);
                this.yCenter = Math.floor(this.top + h / 2 + padding.top);
                this.drawingArea = Math.floor(Math.min(w, h) / 2);
            }
            determineDataLimits() {
                const {min, max} = this.getMinMax(false);
                this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
                this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
                this.handleTickRangeOptions();
            }
            computeTickLimit() {
                return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
            }
            generateTickLabels(ticks) {
                LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
                this._pointLabels = this.getLabels().map(((value, index) => {
                    const label = callback(this.options.pointLabels.callback, [ value, index ], this);
                    return label || label === 0 ? label : "";
                })).filter(((v, i) => this.chart.getDataVisibility(i)));
            }
            fit() {
                const opts = this.options;
                if (opts.display && opts.pointLabels.display) fitWithPointLabels(this); else this.setCenterPoint(0, 0, 0, 0);
            }
            setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
                this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
                this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
                this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
            }
            getIndexAngle(index) {
                const angleMultiplier = TAU / (this._pointLabels.length || 1);
                const startAngle = this.options.startAngle || 0;
                return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
            }
            getDistanceFromCenterForValue(value) {
                if (isNullOrUndef(value)) return NaN;
                const scalingFactor = this.drawingArea / (this.max - this.min);
                if (this.options.reverse) return (this.max - value) * scalingFactor;
                return (value - this.min) * scalingFactor;
            }
            getValueForDistanceFromCenter(distance) {
                if (isNullOrUndef(distance)) return NaN;
                const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
                return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
            }
            getPointLabelContext(index) {
                const pointLabels = this._pointLabels || [];
                if (index >= 0 && index < pointLabels.length) {
                    const pointLabel = pointLabels[index];
                    return createPointLabelContext(this.getContext(), index, pointLabel);
                }
            }
            getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
                const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
                return {
                    x: Math.cos(angle) * distanceFromCenter + this.xCenter,
                    y: Math.sin(angle) * distanceFromCenter + this.yCenter,
                    angle
                };
            }
            getPointPositionForValue(index, value) {
                return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
            }
            getBasePosition(index) {
                return this.getPointPositionForValue(index || 0, this.getBaseValue());
            }
            getPointLabelPosition(index) {
                const {left, top, right, bottom} = this._pointLabelItems[index];
                return {
                    left,
                    top,
                    right,
                    bottom
                };
            }
            drawBackground() {
                const {backgroundColor, grid: {circular}} = this.options;
                if (backgroundColor) {
                    const ctx = this.ctx;
                    ctx.save();
                    ctx.beginPath();
                    pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
                    ctx.closePath();
                    ctx.fillStyle = backgroundColor;
                    ctx.fill();
                    ctx.restore();
                }
            }
            drawGrid() {
                const ctx = this.ctx;
                const opts = this.options;
                const {angleLines, grid, border} = opts;
                const labelCount = this._pointLabels.length;
                let i, offset, position;
                if (opts.pointLabels.display) drawPointLabels(this, labelCount);
                if (grid.display) this.ticks.forEach(((tick, index) => {
                    if (index !== 0) {
                        offset = this.getDistanceFromCenterForValue(tick.value);
                        const context = this.getContext(index);
                        const optsAtIndex = grid.setContext(context);
                        const optsAtIndexBorder = border.setContext(context);
                        drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                    }
                }));
                if (angleLines.display) {
                    ctx.save();
                    for (i = labelCount - 1; i >= 0; i--) {
                        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                        const {color, lineWidth} = optsAtIndex;
                        if (!lineWidth || !color) continue;
                        ctx.lineWidth = lineWidth;
                        ctx.strokeStyle = color;
                        ctx.setLineDash(optsAtIndex.borderDash);
                        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                        position = this.getPointPosition(i, offset);
                        ctx.beginPath();
                        ctx.moveTo(this.xCenter, this.yCenter);
                        ctx.lineTo(position.x, position.y);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            drawBorder() {}
            drawLabels() {
                const ctx = this.ctx;
                const opts = this.options;
                const tickOpts = opts.ticks;
                if (!tickOpts.display) return;
                const startAngle = this.getIndexAngle(0);
                let offset, width;
                ctx.save();
                ctx.translate(this.xCenter, this.yCenter);
                ctx.rotate(startAngle);
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                this.ticks.forEach(((tick, index) => {
                    if (index === 0 && !opts.reverse) return;
                    const optsAtIndex = tickOpts.setContext(this.getContext(index));
                    const tickFont = toFont(optsAtIndex.font);
                    offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
                    if (optsAtIndex.showLabelBackdrop) {
                        ctx.font = tickFont.string;
                        width = ctx.measureText(tick.label).width;
                        ctx.fillStyle = optsAtIndex.backdropColor;
                        const padding = toPadding(optsAtIndex.backdropPadding);
                        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
                    }
                    renderText(ctx, tick.label, 0, -offset, tickFont, {
                        color: optsAtIndex.color,
                        strokeColor: optsAtIndex.textStrokeColor,
                        strokeWidth: optsAtIndex.textStrokeWidth
                    });
                }));
                ctx.restore();
            }
            drawTitle() {}
        }
        const INTERVALS = {
            millisecond: {
                common: true,
                size: 1,
                steps: 1e3
            },
            second: {
                common: true,
                size: 1e3,
                steps: 60
            },
            minute: {
                common: true,
                size: 6e4,
                steps: 60
            },
            hour: {
                common: true,
                size: 36e5,
                steps: 24
            },
            day: {
                common: true,
                size: 864e5,
                steps: 30
            },
            week: {
                common: false,
                size: 6048e5,
                steps: 4
            },
            month: {
                common: true,
                size: 2628e6,
                steps: 12
            },
            quarter: {
                common: false,
                size: 7884e6,
                steps: 4
            },
            year: {
                common: true,
                size: 3154e7
            }
        };
        const UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
            return a - b;
        }
        function parse(scale, input) {
            if (isNullOrUndef(input)) return null;
            const adapter = scale._adapter;
            const {parser, round, isoWeekday} = scale._parseOpts;
            let value = input;
            if (typeof parser === "function") value = parser(value);
            if (!isNumberFinite(value)) value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
            if (value === null) return null;
            if (round) value = round === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round);
            return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
            const ilen = UNITS.length;
            for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
                const interval = INTERVALS[UNITS[i]];
                const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
                if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) return UNITS[i];
            }
            return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
            for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
                const unit = UNITS[i];
                if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) return unit;
            }
            return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
            for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) if (INTERVALS[UNITS[i]].common) return UNITS[i];
        }
        function addTick(ticks, time, timestamps) {
            if (!timestamps) ticks[time] = true; else if (timestamps.length) {
                const {lo, hi} = _lookup(timestamps, time);
                const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
                ticks[timestamp] = true;
            }
        }
        function setMajorTicks(scale, ticks, map, majorUnit) {
            const adapter = scale._adapter;
            const first = +adapter.startOf(ticks[0].value, majorUnit);
            const last = ticks[ticks.length - 1].value;
            let major, index;
            for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
                index = map[major];
                if (index >= 0) ticks[index].major = true;
            }
            return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
            const ticks = [];
            const map = {};
            const ilen = values.length;
            let i, value;
            for (i = 0; i < ilen; ++i) {
                value = values[i];
                map[value] = i;
                ticks.push({
                    value,
                    major: false
                });
            }
            return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
        }
        class TimeScale extends Scale {
            static id="time";
            static defaults={
                bounds: "data",
                adapters: {},
                time: {
                    parser: false,
                    unit: false,
                    round: false,
                    isoWeekday: false,
                    minUnit: "millisecond",
                    displayFormats: {}
                },
                ticks: {
                    source: "auto",
                    callback: false,
                    major: {
                        enabled: false
                    }
                }
            };
            constructor(props) {
                super(props);
                this._cache = {
                    data: [],
                    labels: [],
                    all: []
                };
                this._unit = "day";
                this._majorUnit = void 0;
                this._offsets = {};
                this._normalized = false;
                this._parseOpts = void 0;
            }
            init(scaleOpts, opts = {}) {
                const time = scaleOpts.time || (scaleOpts.time = {});
                const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
                adapter.init(opts);
                mergeIf(time.displayFormats, adapter.formats());
                this._parseOpts = {
                    parser: time.parser,
                    round: time.round,
                    isoWeekday: time.isoWeekday
                };
                super.init(scaleOpts);
                this._normalized = opts.normalized;
            }
            parse(raw, index) {
                if (raw === void 0) return null;
                return parse(this, raw);
            }
            beforeLayout() {
                super.beforeLayout();
                this._cache = {
                    data: [],
                    labels: [],
                    all: []
                };
            }
            determineDataLimits() {
                const options = this.options;
                const adapter = this._adapter;
                const unit = options.time.unit || "day";
                let {min, max, minDefined, maxDefined} = this.getUserBounds();
                function _applyBounds(bounds) {
                    if (!minDefined && !isNaN(bounds.min)) min = Math.min(min, bounds.min);
                    if (!maxDefined && !isNaN(bounds.max)) max = Math.max(max, bounds.max);
                }
                if (!minDefined || !maxDefined) {
                    _applyBounds(this._getLabelBounds());
                    if (options.bounds !== "ticks" || options.ticks.source !== "labels") _applyBounds(this.getMinMax(false));
                }
                min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
                max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
                this.min = Math.min(min, max - 1);
                this.max = Math.max(min + 1, max);
            }
            _getLabelBounds() {
                const arr = this.getLabelTimestamps();
                let min = Number.POSITIVE_INFINITY;
                let max = Number.NEGATIVE_INFINITY;
                if (arr.length) {
                    min = arr[0];
                    max = arr[arr.length - 1];
                }
                return {
                    min,
                    max
                };
            }
            buildTicks() {
                const options = this.options;
                const timeOpts = options.time;
                const tickOpts = options.ticks;
                const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
                if (options.bounds === "ticks" && timestamps.length) {
                    this.min = this._userMin || timestamps[0];
                    this.max = this._userMax || timestamps[timestamps.length - 1];
                }
                const min = this.min;
                const max = this.max;
                const ticks = _filterBetween(timestamps, min, max);
                this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
                this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
                this.initOffsets(timestamps);
                if (options.reverse) ticks.reverse();
                return ticksFromTimestamps(this, ticks, this._majorUnit);
            }
            afterAutoSkip() {
                if (this.options.offsetAfterAutoskip) this.initOffsets(this.ticks.map((tick => +tick.value)));
            }
            initOffsets(timestamps = []) {
                let start = 0;
                let end = 0;
                let first, last;
                if (this.options.offset && timestamps.length) {
                    first = this.getDecimalForValue(timestamps[0]);
                    if (timestamps.length === 1) start = 1 - first; else start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
                    last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
                    if (timestamps.length === 1) end = last; else end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
                }
                const limit = timestamps.length < 3 ? .5 : .25;
                start = _limitValue(start, 0, limit);
                end = _limitValue(end, 0, limit);
                this._offsets = {
                    start,
                    end,
                    factor: 1 / (start + 1 + end)
                };
            }
            _generate() {
                const adapter = this._adapter;
                const min = this.min;
                const max = this.max;
                const options = this.options;
                const timeOpts = options.time;
                const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
                const stepSize = valueOrDefault(options.ticks.stepSize, 1);
                const weekday = minor === "week" ? timeOpts.isoWeekday : false;
                const hasWeekday = isNumber(weekday) || weekday === true;
                const ticks = {};
                let first = min;
                let time, count;
                if (hasWeekday) first = +adapter.startOf(first, "isoWeek", weekday);
                first = +adapter.startOf(first, hasWeekday ? "day" : minor);
                if (adapter.diff(max, min, minor) > 1e5 * stepSize) throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
                const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
                for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), 
                count++) addTick(ticks, time, timestamps);
                if (time === max || options.bounds === "ticks" || count === 1) addTick(ticks, time, timestamps);
                return Object.keys(ticks).sort(sorter).map((x => +x));
            }
            getLabelForValue(value) {
                const adapter = this._adapter;
                const timeOpts = this.options.time;
                if (timeOpts.tooltipFormat) return adapter.format(value, timeOpts.tooltipFormat);
                return adapter.format(value, timeOpts.displayFormats.datetime);
            }
            format(value, format) {
                const options = this.options;
                const formats = options.time.displayFormats;
                const unit = this._unit;
                const fmt = format || formats[unit];
                return this._adapter.format(value, fmt);
            }
            _tickFormatFunction(time, index, ticks, format) {
                const options = this.options;
                const formatter = options.ticks.callback;
                if (formatter) return callback(formatter, [ time, index, ticks ], this);
                const formats = options.time.displayFormats;
                const unit = this._unit;
                const majorUnit = this._majorUnit;
                const minorFormat = unit && formats[unit];
                const majorFormat = majorUnit && formats[majorUnit];
                const tick = ticks[index];
                const major = majorUnit && majorFormat && tick && tick.major;
                return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            }
            generateTickLabels(ticks) {
                let i, ilen, tick;
                for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                    tick = ticks[i];
                    tick.label = this._tickFormatFunction(tick.value, i, ticks);
                }
            }
            getDecimalForValue(value) {
                return value === null ? NaN : (value - this.min) / (this.max - this.min);
            }
            getPixelForValue(value) {
                const offsets = this._offsets;
                const pos = this.getDecimalForValue(value);
                return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
            }
            getValueForPixel(pixel) {
                const offsets = this._offsets;
                const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                return this.min + pos * (this.max - this.min);
            }
            _getLabelSize(label) {
                const ticksOpts = this.options.ticks;
                const tickLabelWidth = this.ctx.measureText(label).width;
                const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
                const cosRotation = Math.cos(angle);
                const sinRotation = Math.sin(angle);
                const tickFontSize = this._resolveTickFontOptions(0).size;
                return {
                    w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
                    h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
                };
            }
            _getLabelCapacity(exampleTime) {
                const timeOpts = this.options.time;
                const displayFormats = timeOpts.displayFormats;
                const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
                const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [ exampleTime ], this._majorUnit), format);
                const size = this._getLabelSize(exampleLabel);
                const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
                return capacity > 0 ? capacity : 1;
            }
            getDataTimestamps() {
                let timestamps = this._cache.data || [];
                let i, ilen;
                if (timestamps.length) return timestamps;
                const metas = this.getMatchingVisibleMetas();
                if (this._normalized && metas.length) return this._cache.data = metas[0].controller.getAllParsedValues(this);
                for (i = 0, ilen = metas.length; i < ilen; ++i) timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
                return this._cache.data = this.normalize(timestamps);
            }
            getLabelTimestamps() {
                const timestamps = this._cache.labels || [];
                let i, ilen;
                if (timestamps.length) return timestamps;
                const labels = this.getLabels();
                for (i = 0, ilen = labels.length; i < ilen; ++i) timestamps.push(parse(this, labels[i]));
                return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
            }
            normalize(values) {
                return _arrayUnique(values.sort(sorter));
            }
        }
        function chart_interpolate(table, val, reverse) {
            let lo = 0;
            let hi = table.length - 1;
            let prevSource, nextSource, prevTarget, nextTarget;
            if (reverse) {
                if (val >= table[lo].pos && val <= table[hi].pos) ({lo, hi} = _lookupByKey(table, "pos", val));
                ({pos: prevSource, time: prevTarget} = table[lo]);
                ({pos: nextSource, time: nextTarget} = table[hi]);
            } else {
                if (val >= table[lo].time && val <= table[hi].time) ({lo, hi} = _lookupByKey(table, "time", val));
                ({time: prevSource, pos: prevTarget} = table[lo]);
                ({time: nextSource, pos: nextTarget} = table[hi]);
            }
            const span = nextSource - prevSource;
            return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
            static id="timeseries";
            static defaults=TimeScale.defaults;
            constructor(props) {
                super(props);
                this._table = [];
                this._minPos = void 0;
                this._tableRange = void 0;
            }
            initOffsets() {
                const timestamps = this._getTimestampsForTable();
                const table = this._table = this.buildLookupTable(timestamps);
                this._minPos = chart_interpolate(table, this.min);
                this._tableRange = chart_interpolate(table, this.max) - this._minPos;
                super.initOffsets(timestamps);
            }
            buildLookupTable(timestamps) {
                const {min, max} = this;
                const items = [];
                const table = [];
                let i, ilen, prev, curr, next;
                for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                    curr = timestamps[i];
                    if (curr >= min && curr <= max) items.push(curr);
                }
                if (items.length < 2) return [ {
                    time: min,
                    pos: 0
                }, {
                    time: max,
                    pos: 1
                } ];
                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    next = items[i + 1];
                    prev = items[i - 1];
                    curr = items[i];
                    if (Math.round((next + prev) / 2) !== curr) table.push({
                        time: curr,
                        pos: i / (ilen - 1)
                    });
                }
                return table;
            }
            _generate() {
                const min = this.min;
                const max = this.max;
                let timestamps = super.getDataTimestamps();
                if (!timestamps.includes(min) || !timestamps.length) timestamps.splice(0, 0, min);
                if (!timestamps.includes(max) || timestamps.length === 1) timestamps.push(max);
                return timestamps.sort(((a, b) => a - b));
            }
            _getTimestampsForTable() {
                let timestamps = this._cache.all || [];
                if (timestamps.length) return timestamps;
                const data = this.getDataTimestamps();
                const label = this.getLabelTimestamps();
                if (data.length && label.length) timestamps = this.normalize(data.concat(label)); else timestamps = data.length ? data : label;
                timestamps = this._cache.all = timestamps;
                return timestamps;
            }
            getDecimalForValue(value) {
                return (chart_interpolate(this._table, value) - this._minPos) / this._tableRange;
            }
            getValueForPixel(pixel) {
                const offsets = this._offsets;
                const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                return chart_interpolate(this._table, decimal * this._tableRange + this._minPos, true);
            }
        }
        var scales = Object.freeze({
            __proto__: null,
            CategoryScale,
            LinearScale,
            LogarithmicScale,
            RadialLinearScale,
            TimeScale,
            TimeSeriesScale
        });
        const registerables = [ controllers, chart_elements, plugins, scales ];
        chart_Chart.register(...registerables);
        null && Chart;
        var can_use_dom = __webpack_require__(807);
        function isObject_isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
        }
        const lodash_es_isObject = isObject_isObject;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        const _freeGlobal = freeGlobal;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = _freeGlobal || freeSelf || Function("return this")();
        const _root = root;
        var now_now = function() {
            return _root.Date.now();
        };
        const lodash_es_now = now_now;
        var reWhitespace = /\s/;
        function trimmedEndIndex(string) {
            var index = string.length;
            while (index-- && reWhitespace.test(string.charAt(index))) ;
            return index;
        }
        const _trimmedEndIndex = trimmedEndIndex;
        var reTrimStart = /^\s+/;
        function baseTrim(string) {
            return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        const _baseTrim = baseTrim;
        var _Symbol_Symbol = _root.Symbol;
        const _Symbol = _Symbol_Symbol;
        var objectProto = Object.prototype;
        var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function getRawTag(value) {
            var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = void 0;
                var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) if (isOwn) value[symToStringTag] = tag; else delete value[symToStringTag];
            return result;
        }
        const _getRawTag = getRawTag;
        var _objectToString_objectProto = Object.prototype;
        var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;
        function objectToString(value) {
            return _objectToString_nativeObjectToString.call(value);
        }
        const _objectToString = objectToString;
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
        var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function baseGetTag(value) {
            if (value == null) return value === void 0 ? undefinedTag : nullTag;
            return _baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
        }
        const _baseGetTag = baseGetTag;
        function isObjectLike(value) {
            return value != null && typeof value == "object";
        }
        const lodash_es_isObjectLike = isObjectLike;
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
            return typeof value == "symbol" || lodash_es_isObjectLike(value) && _baseGetTag(value) == symbolTag;
        }
        const lodash_es_isSymbol = isSymbol;
        var NAN = 0 / 0;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsOctal = /^0o[0-7]+$/i;
        var freeParseInt = parseInt;
        function toNumber(value) {
            if (typeof value == "number") return value;
            if (lodash_es_isSymbol(value)) return NAN;
            if (lodash_es_isObject(value)) {
                var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                value = lodash_es_isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") return value === 0 ? value : +value;
            value = _baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        const lodash_es_toNumber = toNumber;
        var FUNC_ERROR_TEXT = "Expected a function";
        var nativeMax = Math.max, nativeMin = Math.min;
        function debounce_debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            wait = lodash_es_toNumber(wait) || 0;
            if (lodash_es_isObject(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(lodash_es_toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = void 0;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }
            function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = lodash_es_now();
                if (shouldInvoke(time)) return trailingEdge(time);
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                timerId = void 0;
                if (trailing && lastArgs) return invokeFunc(time);
                lastArgs = lastThis = void 0;
                return result;
            }
            function cancel() {
                if (timerId !== void 0) clearTimeout(timerId);
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = void 0;
            }
            function flush() {
                return timerId === void 0 ? result : trailingEdge(lodash_es_now());
            }
            function debounced() {
                var time = lodash_es_now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === void 0) return leadingEdge(lastCallTime);
                    if (maxing) {
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
                return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
        }
        const lodash_es_debounce = debounce_debounce;
        var throttle_FUNC_ERROR_TEXT = "Expected a function";
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") throw new TypeError(throttle_FUNC_ERROR_TEXT);
            if (lodash_es_isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return lodash_es_debounce(func, wait, {
                leading,
                maxWait: wait,
                trailing
            });
        }
        const lodash_es_throttle = throttle;
        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };
        var cachedScrollbarWidth = null;
        var cachedDevicePixelRatio = null;
        if (can_use_dom) window.addEventListener("resize", (function() {
            if (cachedDevicePixelRatio !== window.devicePixelRatio) {
                cachedDevicePixelRatio = window.devicePixelRatio;
                cachedScrollbarWidth = null;
            }
        }));
        function scrollbarWidth() {
            if (cachedScrollbarWidth === null) {
                if (typeof document === "undefined") {
                    cachedScrollbarWidth = 0;
                    return cachedScrollbarWidth;
                }
                var body = document.body;
                var box = document.createElement("div");
                box.classList.add("simplebar-hide-scrollbar");
                body.appendChild(box);
                var width = box.getBoundingClientRect().right;
                body.removeChild(box);
                cachedScrollbarWidth = width;
            }
            return cachedScrollbarWidth;
        }
        function getElementWindow$1(element) {
            if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) return window;
            return element.ownerDocument.defaultView;
        }
        function getElementDocument$1(element) {
            if (!element || !element.ownerDocument) return document;
            return element.ownerDocument;
        }
        var getOptions$1 = function(obj) {
            var initialObj = {};
            var options = Array.prototype.reduce.call(obj, (function(acc, attribute) {
                var option = attribute.name.match(/data-simplebar-(.+)/);
                if (option) {
                    var key = option[1].replace(/\W+(.)/g, (function(_, chr) {
                        return chr.toUpperCase();
                    }));
                    switch (attribute.value) {
                      case "true":
                        acc[key] = true;
                        break;

                      case "false":
                        acc[key] = false;
                        break;

                      case void 0:
                        acc[key] = true;
                        break;

                      default:
                        acc[key] = attribute.value;
                    }
                }
                return acc;
            }), initialObj);
            return options;
        };
        function addClasses$1(el, classes) {
            var _a;
            if (!el) return;
            (_a = el.classList).add.apply(_a, classes.split(" "));
        }
        function removeClasses$1(el, classes) {
            if (!el) return;
            classes.split(" ").forEach((function(className) {
                el.classList.remove(className);
            }));
        }
        function classNamesToQuery$1(classNames) {
            return ".".concat(classNames.split(" ").join("."));
        }
        var helpers = Object.freeze({
            __proto__: null,
            getElementWindow: getElementWindow$1,
            getElementDocument: getElementDocument$1,
            getOptions: getOptions$1,
            addClasses: addClasses$1,
            removeClasses: removeClasses$1,
            classNamesToQuery: classNamesToQuery$1
        });
        var getElementWindow = getElementWindow$1, getElementDocument = getElementDocument$1, getOptions = getOptions$1, dist_addClasses = addClasses$1, dist_removeClasses = removeClasses$1, classNamesToQuery = classNamesToQuery$1;
        var SimpleBarCore = function() {
            function SimpleBarCore(element, options) {
                if (options === void 0) options = {};
                var _this = this;
                this.removePreventClickId = null;
                this.minScrollbarWidth = 20;
                this.stopScrollDelay = 175;
                this.isScrolling = false;
                this.isMouseEntering = false;
                this.scrollXTicking = false;
                this.scrollYTicking = false;
                this.wrapperEl = null;
                this.contentWrapperEl = null;
                this.contentEl = null;
                this.offsetEl = null;
                this.maskEl = null;
                this.placeholderEl = null;
                this.heightAutoObserverWrapperEl = null;
                this.heightAutoObserverEl = null;
                this.rtlHelpers = null;
                this.scrollbarWidth = 0;
                this.resizeObserver = null;
                this.mutationObserver = null;
                this.elStyles = null;
                this.isRtl = null;
                this.mouseX = 0;
                this.mouseY = 0;
                this.onMouseMove = function() {};
                this.onWindowResize = function() {};
                this.onStopScrolling = function() {};
                this.onMouseEntered = function() {};
                this.onScroll = function() {
                    var elWindow = getElementWindow(_this.el);
                    if (!_this.scrollXTicking) {
                        elWindow.requestAnimationFrame(_this.scrollX);
                        _this.scrollXTicking = true;
                    }
                    if (!_this.scrollYTicking) {
                        elWindow.requestAnimationFrame(_this.scrollY);
                        _this.scrollYTicking = true;
                    }
                    if (!_this.isScrolling) {
                        _this.isScrolling = true;
                        dist_addClasses(_this.el, _this.classNames.scrolling);
                    }
                    _this.showScrollbar("x");
                    _this.showScrollbar("y");
                    _this.onStopScrolling();
                };
                this.scrollX = function() {
                    if (_this.axis.x.isOverflowing) _this.positionScrollbar("x");
                    _this.scrollXTicking = false;
                };
                this.scrollY = function() {
                    if (_this.axis.y.isOverflowing) _this.positionScrollbar("y");
                    _this.scrollYTicking = false;
                };
                this._onStopScrolling = function() {
                    dist_removeClasses(_this.el, _this.classNames.scrolling);
                    if (_this.options.autoHide) {
                        _this.hideScrollbar("x");
                        _this.hideScrollbar("y");
                    }
                    _this.isScrolling = false;
                };
                this.onMouseEnter = function() {
                    if (!_this.isMouseEntering) {
                        dist_addClasses(_this.el, _this.classNames.mouseEntered);
                        _this.showScrollbar("x");
                        _this.showScrollbar("y");
                        _this.isMouseEntering = true;
                    }
                    _this.onMouseEntered();
                };
                this._onMouseEntered = function() {
                    dist_removeClasses(_this.el, _this.classNames.mouseEntered);
                    if (_this.options.autoHide) {
                        _this.hideScrollbar("x");
                        _this.hideScrollbar("y");
                    }
                    _this.isMouseEntering = false;
                };
                this._onMouseMove = function(e) {
                    _this.mouseX = e.clientX;
                    _this.mouseY = e.clientY;
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseMoveForAxis("x");
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseMoveForAxis("y");
                };
                this.onMouseLeave = function() {
                    _this.onMouseMove.cancel();
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseLeaveForAxis("x");
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseLeaveForAxis("y");
                    _this.mouseX = -1;
                    _this.mouseY = -1;
                };
                this._onWindowResize = function() {
                    _this.scrollbarWidth = _this.getScrollbarWidth();
                    _this.hideNativeScrollbar();
                };
                this.onPointerEvent = function(e) {
                    if (!_this.axis.x.track.el || !_this.axis.y.track.el || !_this.axis.x.scrollbar.el || !_this.axis.y.scrollbar.el) return;
                    var isWithinTrackXBounds, isWithinTrackYBounds;
                    _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
                    _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);
                    if (isWithinTrackXBounds || isWithinTrackYBounds) {
                        e.stopPropagation();
                        if (e.type === "pointerdown" && e.pointerType !== "touch") {
                            if (isWithinTrackXBounds) {
                                _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();
                                if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) _this.onDragStart(e, "x"); else _this.onTrackClick(e, "x");
                            }
                            if (isWithinTrackYBounds) {
                                _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();
                                if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) _this.onDragStart(e, "y"); else _this.onTrackClick(e, "y");
                            }
                        }
                    }
                };
                this.drag = function(e) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                    if (!_this.draggedAxis || !_this.contentWrapperEl) return;
                    var eventOffset;
                    var track = _this.axis[_this.draggedAxis].track;
                    var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;
                    var scrollbar = _this.axis[_this.draggedAxis].scrollbar;
                    var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;
                    var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : "0px", 10);
                    e.preventDefault();
                    e.stopPropagation();
                    if (_this.draggedAxis === "y") eventOffset = e.pageY; else eventOffset = e.pageX;
                    var dragPos = eventOffset - ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) - _this.axis[_this.draggedAxis].dragOffset;
                    dragPos = _this.draggedAxis === "x" && _this.isRtl ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) - scrollbar.size - dragPos : dragPos;
                    var dragPerc = dragPos / (trackSize - scrollbar.size);
                    var scrollPos = dragPerc * (contentSize - hostSize);
                    if (_this.draggedAxis === "x" && _this.isRtl) scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative) ? -scrollPos : scrollPos;
                    _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;
                };
                this.onEndDrag = function(e) {
                    var elDocument = getElementDocument(_this.el);
                    var elWindow = getElementWindow(_this.el);
                    e.preventDefault();
                    e.stopPropagation();
                    dist_removeClasses(_this.el, _this.classNames.dragging);
                    elDocument.removeEventListener("mousemove", _this.drag, true);
                    elDocument.removeEventListener("mouseup", _this.onEndDrag, true);
                    _this.removePreventClickId = elWindow.setTimeout((function() {
                        elDocument.removeEventListener("click", _this.preventClick, true);
                        elDocument.removeEventListener("dblclick", _this.preventClick, true);
                        _this.removePreventClickId = null;
                    }));
                };
                this.preventClick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                };
                this.el = element;
                this.options = __assign(__assign({}, SimpleBarCore.defaultOptions), options);
                this.classNames = __assign(__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);
                this.axis = {
                    x: {
                        scrollOffsetAttr: "scrollLeft",
                        sizeAttr: "width",
                        scrollSizeAttr: "scrollWidth",
                        offsetSizeAttr: "offsetWidth",
                        offsetAttr: "left",
                        overflowAttr: "overflowX",
                        dragOffset: 0,
                        isOverflowing: true,
                        forceVisible: false,
                        track: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        },
                        scrollbar: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        }
                    },
                    y: {
                        scrollOffsetAttr: "scrollTop",
                        sizeAttr: "height",
                        scrollSizeAttr: "scrollHeight",
                        offsetSizeAttr: "offsetHeight",
                        offsetAttr: "top",
                        overflowAttr: "overflowY",
                        dragOffset: 0,
                        isOverflowing: true,
                        forceVisible: false,
                        track: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        },
                        scrollbar: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        }
                    }
                };
                if (typeof this.el !== "object" || !this.el.nodeName) throw new Error("Argument passed to SimpleBar must be an HTML element instead of ".concat(this.el));
                this.onMouseMove = lodash_es_throttle(this._onMouseMove, 64);
                this.onWindowResize = lodash_es_debounce(this._onWindowResize, 64, {
                    leading: true
                });
                this.onStopScrolling = lodash_es_debounce(this._onStopScrolling, this.stopScrollDelay);
                this.onMouseEntered = lodash_es_debounce(this._onMouseEntered, this.stopScrollDelay);
                this.init();
            }
            SimpleBarCore.getRtlHelpers = function() {
                if (SimpleBarCore.rtlHelpers) return SimpleBarCore.rtlHelpers;
                var dummyDiv = document.createElement("div");
                dummyDiv.innerHTML = '<div class="simplebar-dummy-scrollbar-size"><div></div></div>';
                var scrollbarDummyEl = dummyDiv.firstElementChild;
                var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;
                if (!dummyChild) return null;
                document.body.appendChild(scrollbarDummyEl);
                scrollbarDummyEl.scrollLeft = 0;
                var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);
                var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);
                scrollbarDummyEl.scrollLeft = -999;
                var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);
                document.body.removeChild(scrollbarDummyEl);
                SimpleBarCore.rtlHelpers = {
                    isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,
                    isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left
                };
                return SimpleBarCore.rtlHelpers;
            };
            SimpleBarCore.prototype.getScrollbarWidth = function() {
                try {
                    if (this.contentWrapperEl && getComputedStyle(this.contentWrapperEl, "::-webkit-scrollbar").display === "none" || "scrollbarWidth" in document.documentElement.style || "-ms-overflow-style" in document.documentElement.style) return 0; else return scrollbarWidth();
                } catch (e) {
                    return scrollbarWidth();
                }
            };
            SimpleBarCore.getOffset = function(el) {
                var rect = el.getBoundingClientRect();
                var elDocument = getElementDocument(el);
                var elWindow = getElementWindow(el);
                return {
                    top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),
                    left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)
                };
            };
            SimpleBarCore.prototype.init = function() {
                if (can_use_dom) {
                    this.initDOM();
                    this.rtlHelpers = SimpleBarCore.getRtlHelpers();
                    this.scrollbarWidth = this.getScrollbarWidth();
                    this.recalculate();
                    this.initListeners();
                }
            };
            SimpleBarCore.prototype.initDOM = function() {
                var _a, _b;
                this.wrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.wrapper));
                this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));
                this.contentEl = this.options.contentNode || this.el.querySelector(classNamesToQuery(this.classNames.contentEl));
                this.offsetEl = this.el.querySelector(classNamesToQuery(this.classNames.offset));
                this.maskEl = this.el.querySelector(classNamesToQuery(this.classNames.mask));
                this.placeholderEl = this.findChild(this.wrapperEl, classNamesToQuery(this.classNames.placeholder));
                this.heightAutoObserverWrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));
                this.heightAutoObserverEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverEl));
                this.axis.x.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.horizontal)));
                this.axis.y.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.vertical)));
                this.axis.x.scrollbar.el = ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
                this.axis.y.scrollbar.el = ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
                if (!this.options.autoHide) {
                    dist_addClasses(this.axis.x.scrollbar.el, this.classNames.visible);
                    dist_addClasses(this.axis.y.scrollbar.el, this.classNames.visible);
                }
            };
            SimpleBarCore.prototype.initListeners = function() {
                var _this = this;
                var _a;
                var elWindow = getElementWindow(this.el);
                this.el.addEventListener("mouseenter", this.onMouseEnter);
                this.el.addEventListener("pointerdown", this.onPointerEvent, true);
                this.el.addEventListener("mousemove", this.onMouseMove);
                this.el.addEventListener("mouseleave", this.onMouseLeave);
                (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.addEventListener("scroll", this.onScroll);
                elWindow.addEventListener("resize", this.onWindowResize);
                if (!this.contentEl) return;
                if (window.ResizeObserver) {
                    var resizeObserverStarted_1 = false;
                    var resizeObserver = elWindow.ResizeObserver || ResizeObserver;
                    this.resizeObserver = new resizeObserver((function() {
                        if (!resizeObserverStarted_1) return;
                        elWindow.requestAnimationFrame((function() {
                            _this.recalculate();
                        }));
                    }));
                    this.resizeObserver.observe(this.el);
                    this.resizeObserver.observe(this.contentEl);
                    elWindow.requestAnimationFrame((function() {
                        resizeObserverStarted_1 = true;
                    }));
                }
                this.mutationObserver = new elWindow.MutationObserver((function() {
                    elWindow.requestAnimationFrame((function() {
                        _this.recalculate();
                    }));
                }));
                this.mutationObserver.observe(this.contentEl, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            };
            SimpleBarCore.prototype.recalculate = function() {
                if (!this.heightAutoObserverEl || !this.contentEl || !this.contentWrapperEl || !this.wrapperEl || !this.placeholderEl) return;
                var elWindow = getElementWindow(this.el);
                this.elStyles = elWindow.getComputedStyle(this.el);
                this.isRtl = this.elStyles.direction === "rtl";
                var contentElOffsetWidth = this.contentEl.offsetWidth;
                var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;
                var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;
                var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;
                var elOverflowX = this.elStyles.overflowX;
                var elOverflowY = this.elStyles.overflowY;
                this.contentEl.style.padding = "".concat(this.elStyles.paddingTop, " ").concat(this.elStyles.paddingRight, " ").concat(this.elStyles.paddingBottom, " ").concat(this.elStyles.paddingLeft);
                this.wrapperEl.style.margin = "-".concat(this.elStyles.paddingTop, " -").concat(this.elStyles.paddingRight, " -").concat(this.elStyles.paddingBottom, " -").concat(this.elStyles.paddingLeft);
                var contentElScrollHeight = this.contentEl.scrollHeight;
                var contentElScrollWidth = this.contentEl.scrollWidth;
                this.contentWrapperEl.style.height = isHeightAuto ? "auto" : "100%";
                this.placeholderEl.style.width = isWidthAuto ? "".concat(contentElOffsetWidth || contentElScrollWidth, "px") : "auto";
                this.placeholderEl.style.height = "".concat(contentElScrollHeight, "px");
                var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;
                this.axis.x.isOverflowing = contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;
                this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight;
                this.axis.x.isOverflowing = elOverflowX === "hidden" ? false : this.axis.x.isOverflowing;
                this.axis.y.isOverflowing = elOverflowY === "hidden" ? false : this.axis.y.isOverflowing;
                this.axis.x.forceVisible = this.options.forceVisible === "x" || this.options.forceVisible === true;
                this.axis.y.forceVisible = this.options.forceVisible === "y" || this.options.forceVisible === true;
                this.hideNativeScrollbar();
                var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;
                var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;
                this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;
                this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;
                this.axis.x.scrollbar.size = this.getScrollbarSize("x");
                this.axis.y.scrollbar.size = this.getScrollbarSize("y");
                if (this.axis.x.scrollbar.el) this.axis.x.scrollbar.el.style.width = "".concat(this.axis.x.scrollbar.size, "px");
                if (this.axis.y.scrollbar.el) this.axis.y.scrollbar.el.style.height = "".concat(this.axis.y.scrollbar.size, "px");
                this.positionScrollbar("x");
                this.positionScrollbar("y");
                this.toggleTrackVisibility("x");
                this.toggleTrackVisibility("y");
            };
            SimpleBarCore.prototype.getScrollbarSize = function(axis) {
                var _a, _b;
                if (axis === void 0) axis = "y";
                if (!this.axis[axis].isOverflowing || !this.contentEl) return 0;
                var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];
                var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;
                var scrollbarRatio = trackSize / contentSize;
                var scrollbarSize;
                scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);
                if (this.options.scrollbarMaxSize) scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);
                return scrollbarSize;
            };
            SimpleBarCore.prototype.positionScrollbar = function(axis) {
                var _a, _b, _c;
                if (axis === void 0) axis = "y";
                var scrollbar = this.axis[axis].scrollbar;
                if (!this.axis[axis].isOverflowing || !this.contentWrapperEl || !scrollbar.el || !this.elStyles) return;
                var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];
                var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;
                var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);
                var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
                scrollOffset = axis === "x" && this.isRtl && ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero) ? -scrollOffset : scrollOffset;
                if (axis === "x" && this.isRtl) scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative) ? scrollOffset : -scrollOffset;
                var scrollPourcent = scrollOffset / (contentSize - hostSize);
                var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);
                handleOffset = axis === "x" && this.isRtl ? -handleOffset + (trackSize - scrollbar.size) : handleOffset;
                scrollbar.el.style.transform = axis === "x" ? "translate3d(".concat(handleOffset, "px, 0, 0)") : "translate3d(0, ".concat(handleOffset, "px, 0)");
            };
            SimpleBarCore.prototype.toggleTrackVisibility = function(axis) {
                if (axis === void 0) axis = "y";
                var track = this.axis[axis].track.el;
                var scrollbar = this.axis[axis].scrollbar.el;
                if (!track || !scrollbar || !this.contentWrapperEl) return;
                if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {
                    track.style.visibility = "visible";
                    this.contentWrapperEl.style[this.axis[axis].overflowAttr] = "scroll";
                    this.el.classList.add("".concat(this.classNames.scrollable, "-").concat(axis));
                } else {
                    track.style.visibility = "hidden";
                    this.contentWrapperEl.style[this.axis[axis].overflowAttr] = "hidden";
                    this.el.classList.remove("".concat(this.classNames.scrollable, "-").concat(axis));
                }
                if (this.axis[axis].isOverflowing) scrollbar.style.display = "block"; else scrollbar.style.display = "none";
            };
            SimpleBarCore.prototype.showScrollbar = function(axis) {
                if (axis === void 0) axis = "y";
                if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {
                    dist_addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
                    this.axis[axis].scrollbar.isVisible = true;
                }
            };
            SimpleBarCore.prototype.hideScrollbar = function(axis) {
                if (axis === void 0) axis = "y";
                if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {
                    dist_removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
                    this.axis[axis].scrollbar.isVisible = false;
                }
            };
            SimpleBarCore.prototype.hideNativeScrollbar = function() {
                if (!this.offsetEl) return;
                this.offsetEl.style[this.isRtl ? "left" : "right"] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px";
                this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px";
            };
            SimpleBarCore.prototype.onMouseMoveForAxis = function(axis) {
                if (axis === void 0) axis = "y";
                var currentAxis = this.axis[axis];
                if (!currentAxis.track.el || !currentAxis.scrollbar.el) return;
                currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();
                currentAxis.scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();
                if (this.isWithinBounds(currentAxis.track.rect)) {
                    this.showScrollbar(axis);
                    dist_addClasses(currentAxis.track.el, this.classNames.hover);
                    if (this.isWithinBounds(currentAxis.scrollbar.rect)) dist_addClasses(currentAxis.scrollbar.el, this.classNames.hover); else dist_removeClasses(currentAxis.scrollbar.el, this.classNames.hover);
                } else {
                    dist_removeClasses(currentAxis.track.el, this.classNames.hover);
                    if (this.options.autoHide) this.hideScrollbar(axis);
                }
            };
            SimpleBarCore.prototype.onMouseLeaveForAxis = function(axis) {
                if (axis === void 0) axis = "y";
                dist_removeClasses(this.axis[axis].track.el, this.classNames.hover);
                dist_removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);
                if (this.options.autoHide) this.hideScrollbar(axis);
            };
            SimpleBarCore.prototype.onDragStart = function(e, axis) {
                var _a;
                if (axis === void 0) axis = "y";
                var elDocument = getElementDocument(this.el);
                var elWindow = getElementWindow(this.el);
                var scrollbar = this.axis[axis].scrollbar;
                var eventOffset = axis === "y" ? e.pageY : e.pageX;
                this.axis[axis].dragOffset = eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);
                this.draggedAxis = axis;
                dist_addClasses(this.el, this.classNames.dragging);
                elDocument.addEventListener("mousemove", this.drag, true);
                elDocument.addEventListener("mouseup", this.onEndDrag, true);
                if (this.removePreventClickId === null) {
                    elDocument.addEventListener("click", this.preventClick, true);
                    elDocument.addEventListener("dblclick", this.preventClick, true);
                } else {
                    elWindow.clearTimeout(this.removePreventClickId);
                    this.removePreventClickId = null;
                }
            };
            SimpleBarCore.prototype.onTrackClick = function(e, axis) {
                var _this = this;
                var _a, _b, _c, _d;
                if (axis === void 0) axis = "y";
                var currentAxis = this.axis[axis];
                if (!this.options.clickOnTrack || !currentAxis.scrollbar.el || !this.contentWrapperEl) return;
                e.preventDefault();
                var elWindow = getElementWindow(this.el);
                this.axis[axis].scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();
                var scrollbar = this.axis[axis].scrollbar;
                var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;
                var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : "0px", 10);
                var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
                var t = axis === "y" ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;
                var dir = t < 0 ? -1 : 1;
                var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;
                var speed = 40;
                var scrollTo = function() {
                    if (!_this.contentWrapperEl) return;
                    if (dir === -1) {
                        if (scrolled > scrollSize) {
                            scrolled -= speed;
                            _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                            elWindow.requestAnimationFrame(scrollTo);
                        }
                    } else if (scrolled < scrollSize) {
                        scrolled += speed;
                        _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                        elWindow.requestAnimationFrame(scrollTo);
                    }
                };
                scrollTo();
            };
            SimpleBarCore.prototype.getContentElement = function() {
                return this.contentEl;
            };
            SimpleBarCore.prototype.getScrollElement = function() {
                return this.contentWrapperEl;
            };
            SimpleBarCore.prototype.removeListeners = function() {
                var elWindow = getElementWindow(this.el);
                this.el.removeEventListener("mouseenter", this.onMouseEnter);
                this.el.removeEventListener("pointerdown", this.onPointerEvent, true);
                this.el.removeEventListener("mousemove", this.onMouseMove);
                this.el.removeEventListener("mouseleave", this.onMouseLeave);
                if (this.contentWrapperEl) this.contentWrapperEl.removeEventListener("scroll", this.onScroll);
                elWindow.removeEventListener("resize", this.onWindowResize);
                if (this.mutationObserver) this.mutationObserver.disconnect();
                if (this.resizeObserver) this.resizeObserver.disconnect();
                this.onMouseMove.cancel();
                this.onWindowResize.cancel();
                this.onStopScrolling.cancel();
                this.onMouseEntered.cancel();
            };
            SimpleBarCore.prototype.unMount = function() {
                this.removeListeners();
            };
            SimpleBarCore.prototype.isWithinBounds = function(bbox) {
                return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;
            };
            SimpleBarCore.prototype.findChild = function(el, query) {
                var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;
                return Array.prototype.filter.call(el.children, (function(child) {
                    return matches.call(child, query);
                }))[0];
            };
            SimpleBarCore.rtlHelpers = null;
            SimpleBarCore.defaultOptions = {
                forceVisible: false,
                clickOnTrack: true,
                scrollbarMinSize: 25,
                scrollbarMaxSize: 0,
                ariaLabel: "scrollable content",
                classNames: {
                    contentEl: "simplebar-content",
                    contentWrapper: "simplebar-content-wrapper",
                    offset: "simplebar-offset",
                    mask: "simplebar-mask",
                    wrapper: "simplebar-wrapper",
                    placeholder: "simplebar-placeholder",
                    scrollbar: "simplebar-scrollbar",
                    track: "simplebar-track",
                    heightAutoObserverWrapperEl: "simplebar-height-auto-observer-wrapper",
                    heightAutoObserverEl: "simplebar-height-auto-observer",
                    visible: "simplebar-visible",
                    horizontal: "simplebar-horizontal",
                    vertical: "simplebar-vertical",
                    hover: "simplebar-hover",
                    dragging: "simplebar-dragging",
                    scrolling: "simplebar-scrolling",
                    scrollable: "simplebar-scrollable",
                    mouseEntered: "simplebar-mouse-entered"
                },
                scrollableNode: null,
                contentNode: null,
                autoHide: true
            };
            SimpleBarCore.getOptions = getOptions;
            SimpleBarCore.helpers = helpers;
            return SimpleBarCore;
        }();
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        function __extends(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
        }
        var _a = SimpleBarCore.helpers, dist_getOptions = _a.getOptions, simplebar_dist_addClasses = _a.addClasses;
        var SimpleBar = function(_super) {
            __extends(SimpleBar, _super);
            function SimpleBar() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                var _this = _super.apply(this, args) || this;
                SimpleBar.instances.set(args[0], _this);
                return _this;
            }
            SimpleBar.initDOMLoadedElements = function() {
                document.removeEventListener("DOMContentLoaded", this.initDOMLoadedElements);
                window.removeEventListener("load", this.initDOMLoadedElements);
                Array.prototype.forEach.call(document.querySelectorAll("[data-simplebar]"), (function(el) {
                    if (el.getAttribute("data-simplebar") !== "init" && !SimpleBar.instances.has(el)) new SimpleBar(el, dist_getOptions(el.attributes));
                }));
            };
            SimpleBar.removeObserver = function() {
                var _a;
                (_a = SimpleBar.globalObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
            };
            SimpleBar.prototype.initDOM = function() {
                var _this = this;
                var _a, _b, _c;
                if (!Array.prototype.filter.call(this.el.children, (function(child) {
                    return child.classList.contains(_this.classNames.wrapper);
                })).length) {
                    this.wrapperEl = document.createElement("div");
                    this.contentWrapperEl = document.createElement("div");
                    this.offsetEl = document.createElement("div");
                    this.maskEl = document.createElement("div");
                    this.contentEl = document.createElement("div");
                    this.placeholderEl = document.createElement("div");
                    this.heightAutoObserverWrapperEl = document.createElement("div");
                    this.heightAutoObserverEl = document.createElement("div");
                    simplebar_dist_addClasses(this.wrapperEl, this.classNames.wrapper);
                    simplebar_dist_addClasses(this.contentWrapperEl, this.classNames.contentWrapper);
                    simplebar_dist_addClasses(this.offsetEl, this.classNames.offset);
                    simplebar_dist_addClasses(this.maskEl, this.classNames.mask);
                    simplebar_dist_addClasses(this.contentEl, this.classNames.contentEl);
                    simplebar_dist_addClasses(this.placeholderEl, this.classNames.placeholder);
                    simplebar_dist_addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);
                    simplebar_dist_addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);
                    while (this.el.firstChild) this.contentEl.appendChild(this.el.firstChild);
                    this.contentWrapperEl.appendChild(this.contentEl);
                    this.offsetEl.appendChild(this.contentWrapperEl);
                    this.maskEl.appendChild(this.offsetEl);
                    this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);
                    this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);
                    this.wrapperEl.appendChild(this.maskEl);
                    this.wrapperEl.appendChild(this.placeholderEl);
                    this.el.appendChild(this.wrapperEl);
                    (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.setAttribute("tabindex", "0");
                    (_b = this.contentWrapperEl) === null || _b === void 0 ? void 0 : _b.setAttribute("role", "region");
                    (_c = this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c.setAttribute("aria-label", this.options.ariaLabel);
                }
                if (!this.axis.x.track.el || !this.axis.y.track.el) {
                    var track = document.createElement("div");
                    var scrollbar = document.createElement("div");
                    simplebar_dist_addClasses(track, this.classNames.track);
                    simplebar_dist_addClasses(scrollbar, this.classNames.scrollbar);
                    track.appendChild(scrollbar);
                    this.axis.x.track.el = track.cloneNode(true);
                    simplebar_dist_addClasses(this.axis.x.track.el, this.classNames.horizontal);
                    this.axis.y.track.el = track.cloneNode(true);
                    simplebar_dist_addClasses(this.axis.y.track.el, this.classNames.vertical);
                    this.el.appendChild(this.axis.x.track.el);
                    this.el.appendChild(this.axis.y.track.el);
                }
                SimpleBarCore.prototype.initDOM.call(this);
                this.el.setAttribute("data-simplebar", "init");
            };
            SimpleBar.prototype.unMount = function() {
                SimpleBarCore.prototype.unMount.call(this);
                SimpleBar.instances["delete"](this.el);
            };
            SimpleBar.initHtmlApi = function() {
                this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);
                if (typeof MutationObserver !== "undefined") {
                    this.globalObserver = new MutationObserver(SimpleBar.handleMutations);
                    this.globalObserver.observe(document, {
                        childList: true,
                        subtree: true
                    });
                }
                if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) window.setTimeout(this.initDOMLoadedElements); else {
                    document.addEventListener("DOMContentLoaded", this.initDOMLoadedElements);
                    window.addEventListener("load", this.initDOMLoadedElements);
                }
            };
            SimpleBar.handleMutations = function(mutations) {
                mutations.forEach((function(mutation) {
                    mutation.addedNodes.forEach((function(addedNode) {
                        if (addedNode.nodeType === 1) if (addedNode.hasAttribute("data-simplebar")) !SimpleBar.instances.has(addedNode) && document.documentElement.contains(addedNode) && new SimpleBar(addedNode, dist_getOptions(addedNode.attributes)); else addedNode.querySelectorAll("[data-simplebar]").forEach((function(el) {
                            if (el.getAttribute("data-simplebar") !== "init" && !SimpleBar.instances.has(el) && document.documentElement.contains(el)) new SimpleBar(el, dist_getOptions(el.attributes));
                        }));
                    }));
                    mutation.removedNodes.forEach((function(removedNode) {
                        if (removedNode.nodeType === 1) if (removedNode.getAttribute("data-simplebar") === "init") SimpleBar.instances.has(removedNode) && !document.documentElement.contains(removedNode) && SimpleBar.instances.get(removedNode).unMount(); else Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar="init"]'), (function(el) {
                            SimpleBar.instances.has(el) && !document.documentElement.contains(el) && SimpleBar.instances.get(el).unMount();
                        }));
                    }));
                }));
            };
            SimpleBar.instances = new WeakMap;
            return SimpleBar;
        }(SimpleBarCore);
        if (can_use_dom) SimpleBar.initHtmlApi();
        let addWindowScrollEvent = false;
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        function _assertThisInitialized(self) {
            if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
        }
        /*!
 * GSAP 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/        var _suppressOverwrites, _reverting, _context, _globalTimeline, _win, _coreInitted, _doc, _coreReady, _lastRenderedFrame, _quickTween, _tickerActive, _config = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        }, _defaults = {
            duration: .5,
            overwrite: false,
            delay: 0
        }, _bigNum = 1e8, _tinyNum = 1 / _bigNum, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString(value) {
            return typeof value === "string";
        }, _isFunction = function _isFunction(value) {
            return typeof value === "function";
        }, _isNumber = function _isNumber(value) {
            return typeof value === "number";
        }, _isUndefined = function _isUndefined(value) {
            return typeof value === "undefined";
        }, _isObject = function _isObject(value) {
            return typeof value === "object";
        }, _isNotFalse = function _isNotFalse(value) {
            return value !== false;
        }, _windowExists = function _windowExists() {
            return typeof window !== "undefined";
        }, _isFuncOrString = function _isFuncOrString(value) {
            return _isFunction(value) || _isString(value);
        }, _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {}, _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globals = {}, _installScope = {}, _install = function _install(scope) {
            return (_installScope = _merge(scope, _globals)) && gsap;
        }, _missingPlugin = function _missingPlugin(property, value) {
            return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
        }, _warn = function _warn(message, suppress) {
            return !suppress && console.warn(message);
        }, _addGlobal = function _addGlobal(name, obj) {
            return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
        }, _emptyFunc = function _emptyFunc() {
            return 0;
        }, _startAtRevertConfig = {
            suppressEvents: true,
            isStart: true,
            kill: false
        }, _revertConfigNoKill = {
            suppressEvents: true,
            kill: false
        }, _revertConfig = {
            suppressEvents: true
        }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function _harness(targets) {
            var harnessPlugin, i, target = targets[0];
            _isObject(target) || _isFunction(target) || (targets = [ targets ]);
            if (!(harnessPlugin = (target._gsap || {}).harness)) {
                i = _harnessPlugins.length;
                while (i-- && !_harnessPlugins[i].targetTest(target)) ;
                harnessPlugin = _harnessPlugins[i];
            }
            i = targets.length;
            while (i--) targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
            return targets;
        }, _getCache = function _getCache(target) {
            return target._gsap || _harness(toArray(target))[0]._gsap;
        }, _getProperty = function _getProperty(target, property, v) {
            return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
        }, _forEachName = function _forEachName(names, func) {
            return (names = names.split(",")).forEach(func) || names;
        }, _round = function _round(value) {
            return Math.round(value * 1e5) / 1e5 || 0;
        }, _roundPrecise = function _roundPrecise(value) {
            return Math.round(value * 1e7) / 1e7 || 0;
        }, _parseRelative = function _parseRelative(start, value) {
            var operator = value.charAt(0), end = parseFloat(value.substr(2));
            start = parseFloat(start);
            return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
        }, _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
            var l = toFind.length, i = 0;
            for (;toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) ;
            return i < l;
        }, _lazyRender = function _lazyRender() {
            var i, tween, l = _lazyTweens.length, a = _lazyTweens.slice(0);
            _lazyLookup = {};
            _lazyTweens.length = 0;
            for (i = 0; i < l; i++) {
                tween = a[i];
                tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
            }
        }, _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
            _lazyTweens.length && !_reverting && _lazyRender();
            animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
            _lazyTweens.length && !_reverting && _lazyRender();
        }, _numericIfPossible = function _numericIfPossible(value) {
            var n = parseFloat(value);
            return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
        }, _passThrough = function _passThrough(p) {
            return p;
        }, _setDefaults = function _setDefaults(obj, defaults) {
            for (var p in defaults) p in obj || (obj[p] = defaults[p]);
            return obj;
        }, _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
            return function(obj, defaults) {
                for (var p in defaults) p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
            };
        }, _merge = function _merge(base, toMerge) {
            for (var p in toMerge) base[p] = toMerge[p];
            return base;
        }, _mergeDeep = function _mergeDeep(base, toMerge) {
            for (var p in toMerge) p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
            return base;
        }, _copyExcluding = function _copyExcluding(obj, excluding) {
            var p, copy = {};
            for (p in obj) p in excluding || (copy[p] = obj[p]);
            return copy;
        }, _inheritDefaults = function _inheritDefaults(vars) {
            var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
            if (_isNotFalse(vars.inherit)) while (parent) {
                func(vars, parent.vars.defaults);
                parent = parent.parent || parent._dp;
            }
            return vars;
        }, _arraysMatch = function _arraysMatch(a1, a2) {
            var i = a1.length, match = i === a2.length;
            while (match && i-- && a1[i] === a2[i]) ;
            return i < 0;
        }, _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
            if (firstProp === void 0) firstProp = "_first";
            if (lastProp === void 0) lastProp = "_last";
            var t, prev = parent[lastProp];
            if (sortBy) {
                t = child[sortBy];
                while (prev && prev[sortBy] > t) prev = prev._prev;
            }
            if (prev) {
                child._next = prev._next;
                prev._next = child;
            } else {
                child._next = parent[firstProp];
                parent[firstProp] = child;
            }
            if (child._next) child._next._prev = child; else parent[lastProp] = child;
            child._prev = prev;
            child.parent = child._dp = parent;
            return child;
        }, _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
            if (firstProp === void 0) firstProp = "_first";
            if (lastProp === void 0) lastProp = "_last";
            var prev = child._prev, next = child._next;
            if (prev) prev._next = next; else if (parent[firstProp] === child) parent[firstProp] = next;
            if (next) next._prev = prev; else if (parent[lastProp] === child) parent[lastProp] = prev;
            child._next = child._prev = child.parent = null;
        }, _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
            child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
            child._act = 0;
        }, _uncache = function _uncache(animation, child) {
            if (animation && (!child || child._end > animation._dur || child._start < 0)) {
                var a = animation;
                while (a) {
                    a._dirty = 1;
                    a = a.parent;
                }
            }
            return animation;
        }, _recacheAncestors = function _recacheAncestors(animation) {
            var parent = animation.parent;
            while (parent && parent.parent) {
                parent._dirty = 1;
                parent.totalDuration();
                parent = parent.parent;
            }
            return animation;
        }, _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
            return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
        }, _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
            return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
        }, _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
            return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
        }, _animationCycle = function _animationCycle(tTime, cycleDuration) {
            var whole = Math.floor(tTime /= cycleDuration);
            return tTime && whole === tTime ? whole - 1 : whole;
        }, _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
            return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
        }, _setEnd = function _setEnd(animation) {
            return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
        }, _alignPlayhead = function _alignPlayhead(animation, totalTime) {
            var parent = animation._dp;
            if (parent && parent.smoothChildTiming && animation._ts) {
                animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
                _setEnd(animation);
                parent._dirty || _uncache(parent, animation);
            }
            return animation;
        }, _postAddChecks = function _postAddChecks(timeline, child) {
            var t;
            if (child._time || child._initted && !child._dur) {
                t = _parentToChildTotalTime(timeline.rawTime(), child);
                if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) child.render(t, true);
            }
            if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
                if (timeline._dur < timeline.duration()) {
                    t = timeline;
                    while (t._dp) {
                        t.rawTime() >= 0 && t.totalTime(t._tTime);
                        t = t._dp;
                    }
                }
                timeline._zTime = -_tinyNum;
            }
        }, _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
            child.parent && _removeFromParent(child);
            child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
            child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
            _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
            _isFromOrFromStart(child) || (timeline._recent = child);
            skipChecks || _postAddChecks(timeline, child);
            timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);
            return timeline;
        }, _scrollTrigger = function _scrollTrigger(animation, trigger) {
            return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
        }, _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
            _initTween(tween, time, tTime);
            if (!tween._initted) return 1;
            if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
                _lazyTweens.push(tween);
                tween._lazy = [ tTime, suppressEvents ];
                return 1;
            }
        }, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
            var parent = _ref.parent;
            return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
        }, _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
            var data = _ref2.data;
            return data === "isFromStart" || data === "isStart";
        }, _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
            var pt, iteration, prevIteration, prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0;
            if (repeatDelay && tween._repeat) {
                tTime = _clamp(0, tween._tDur, totalTime);
                iteration = _animationCycle(tTime, repeatDelay);
                tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
                if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
                    prevRatio = 1 - ratio;
                    tween.vars.repeatRefresh && tween._initted && tween.invalidate();
                }
            }
            if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
                if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) return;
                prevIteration = tween._zTime;
                tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
                suppressEvents || (suppressEvents = totalTime && !prevIteration);
                tween.ratio = ratio;
                tween._from && (ratio = 1 - ratio);
                tween._time = 0;
                tween._tTime = tTime;
                pt = tween._pt;
                while (pt) {
                    pt.r(ratio, pt.d);
                    pt = pt._next;
                }
                totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
                tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
                tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
                if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
                    ratio && _removeFromParent(tween, 1);
                    if (!suppressEvents && !_reverting) {
                        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
                        tween._prom && tween._prom();
                    }
                }
            } else if (!tween._zTime) tween._zTime = totalTime;
        }, _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
            var child;
            if (time > prevTime) {
                child = animation._first;
                while (child && child._start <= time) {
                    if (child.data === "isPause" && child._start > prevTime) return child;
                    child = child._next;
                }
            } else {
                child = animation._last;
                while (child && child._start >= time) {
                    if (child.data === "isPause" && child._start < prevTime) return child;
                    child = child._prev;
                }
            }
        }, _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
            var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
            totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
            animation._dur = dur;
            animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
            totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
            animation.parent && _setEnd(animation);
            skipUncache || _uncache(animation.parent, animation);
            return animation;
        }, _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
            return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
        }, _zeroPosition = {
            _start: 0,
            endTime: _emptyFunc,
            totalDuration: _emptyFunc
        }, _parsePosition = function _parsePosition(animation, position, percentAnimation) {
            var i, offset, isPercent, labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur;
            if (_isString(position) && (isNaN(position) || position in labels)) {
                offset = position.charAt(0);
                isPercent = position.substr(-1) === "%";
                i = position.indexOf("=");
                if (offset === "<" || offset === ">") {
                    i >= 0 && (position = position.replace(/=/, ""));
                    return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
                }
                if (i < 0) {
                    position in labels || (labels[position] = clippedDuration);
                    return labels[position];
                }
                offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
                if (isPercent && percentAnimation) offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
                return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
            }
            return position == null ? clippedDuration : +position;
        }, _createTweenType = function _createTweenType(type, params, timeline) {
            var irVars, parent, isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex];
            isLegacy && (vars.duration = params[1]);
            vars.parent = timeline;
            if (type) {
                irVars = vars;
                parent = timeline;
                while (parent && !("immediateRender" in irVars)) {
                    irVars = parent.vars.defaults || {};
                    parent = _isNotFalse(parent.vars.inherit) && parent.parent;
                }
                vars.immediateRender = _isNotFalse(irVars.immediateRender);
                type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
            }
            return new Tween(params[0], vars, params[varsIndex + 1]);
        }, _conditionalReturn = function _conditionalReturn(value, func) {
            return value || value === 0 ? func(value) : func;
        }, _clamp = function _clamp(min, max, value) {
            return value < min ? min : value > max ? max : value;
        }, getUnit = function getUnit(value, v) {
            return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
        }, clamp = function clamp(min, max, value) {
            return _conditionalReturn(value, (function(v) {
                return _clamp(min, max, v);
            }));
        }, _slice = [].slice, _isArrayLike = function _isArrayLike(value, nonEmpty) {
            return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
        }, _flatten = function _flatten(ar, leaveStrings, accumulator) {
            if (accumulator === void 0) accumulator = [];
            return ar.forEach((function(value) {
                var _accumulator;
                return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
            })) || accumulator;
        }, toArray = function toArray(value, scope, leaveStrings) {
            return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [ value ] : [];
        }, selector = function selector(value) {
            value = toArray(value)[0] || _warn("Invalid scope") || {};
            return function(v) {
                var el = value.current || value.nativeElement || value;
                return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
            };
        }, shuffle = function shuffle(a) {
            return a.sort((function() {
                return .5 - Math.random();
            }));
        }, distribute = function distribute(v) {
            if (_isFunction(v)) return v;
            var vars = _isObject(v) ? v : {
                each: v
            }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
            if (_isString(from)) ratioX = ratioY = {
                center: .5,
                edges: .5,
                end: 1
            }[from] || 0; else if (!isDecimal && ratios) {
                ratioX = from[0];
                ratioY = from[1];
            }
            return function(i, target, a) {
                var originX, originY, x, y, d, j, max, min, wrapAt, l = (a || vars).length, distances = cache[l];
                if (!distances) {
                    wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [ 1, _bigNum ])[1];
                    if (!wrapAt) {
                        max = -_bigNum;
                        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) ;
                        wrapAt--;
                    }
                    distances = cache[l] = [];
                    originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
                    originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
                    max = 0;
                    min = _bigNum;
                    for (j = 0; j < l; j++) {
                        x = j % wrapAt - originX;
                        y = originY - (j / wrapAt | 0);
                        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
                        d > max && (max = d);
                        d < min && (min = d);
                    }
                    from === "random" && shuffle(distances);
                    distances.max = max - min;
                    distances.min = min;
                    distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
                    distances.b = l < 0 ? base - l : base;
                    distances.u = getUnit(vars.amount || vars.each) || 0;
                    ease = ease && l < 0 ? _invertEase(ease) : ease;
                }
                l = (distances[i] - distances.min) / distances.max || 0;
                return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
            };
        }, _roundModifier = function _roundModifier(v) {
            var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
            return function(raw) {
                var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
                return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
            };
        }, snap = function snap(snapTo, value) {
            var radius, is2D, isArray = _isArray(snapTo);
            if (!isArray && _isObject(snapTo)) {
                radius = isArray = snapTo.radius || _bigNum;
                if (snapTo.values) {
                    snapTo = toArray(snapTo.values);
                    if (is2D = !_isNumber(snapTo[0])) radius *= radius;
                } else snapTo = _roundModifier(snapTo.increment);
            }
            return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
                is2D = snapTo(raw);
                return Math.abs(is2D - raw) <= radius ? is2D : raw;
            } : function(raw) {
                var dx, dy, x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length;
                while (i--) {
                    if (is2D) {
                        dx = snapTo[i].x - x;
                        dy = snapTo[i].y - y;
                        dx = dx * dx + dy * dy;
                    } else dx = Math.abs(snapTo[i] - x);
                    if (dx < min) {
                        min = dx;
                        closest = i;
                    }
                }
                closest = !radius || min <= radius ? snapTo[closest] : raw;
                return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
            });
        }, random = function random(min, max, roundingIncrement, returnFunction) {
            return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, (function() {
                return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
            }));
        }, pipe = function pipe() {
            for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) functions[_key] = arguments[_key];
            return function(value) {
                return functions.reduce((function(v, f) {
                    return f(v);
                }), value);
            };
        }, unitize = function unitize(func, unit) {
            return function(value) {
                return func(parseFloat(value)) + (unit || getUnit(value));
            };
        }, normalize = function normalize(min, max, value) {
            return mapRange(min, max, 0, 1, value);
        }, _wrapArray = function _wrapArray(a, wrapper, value) {
            return _conditionalReturn(value, (function(index) {
                return a[~~wrapper(index)];
            }));
        }, wrap = function wrap(min, max, value) {
            var range = max - min;
            return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, (function(value) {
                return (range + (value - min) % range) % range + min;
            }));
        }, wrapYoyo = function wrapYoyo(min, max, value) {
            var range = max - min, total = range * 2;
            return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, (function(value) {
                value = (total + (value - min) % total) % total || 0;
                return min + (value > range ? total - value : value);
            }));
        }, _replaceRandom = function _replaceRandom(value) {
            var i, nums, end, isArray, prev = 0, s = "";
            while (~(i = value.indexOf("random(", prev))) {
                end = value.indexOf(")", i);
                isArray = value.charAt(i + 7) === "[";
                nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
                s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
                prev = end + 1;
            }
            return s + value.substr(prev, value.length - prev);
        }, mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
            var inRange = inMax - inMin, outRange = outMax - outMin;
            return _conditionalReturn(value, (function(value) {
                return outMin + ((value - inMin) / inRange * outRange || 0);
            }));
        }, gsap_core_interpolate = function interpolate(start, end, progress, mutate) {
            var func = isNaN(start + end) ? 0 : function(p) {
                return (1 - p) * start + p * end;
            };
            if (!func) {
                var p, i, interpolators, l, il, isString = _isString(start), master = {};
                progress === true && (mutate = 1) && (progress = null);
                if (isString) {
                    start = {
                        p: start
                    };
                    end = {
                        p: end
                    };
                } else if (_isArray(start) && !_isArray(end)) {
                    interpolators = [];
                    l = start.length;
                    il = l - 2;
                    for (i = 1; i < l; i++) interpolators.push(interpolate(start[i - 1], start[i]));
                    l--;
                    func = function func(p) {
                        p *= l;
                        var i = Math.min(il, ~~p);
                        return interpolators[i](p - i);
                    };
                    progress = end;
                } else if (!mutate) start = _merge(_isArray(start) ? [] : {}, start);
                if (!interpolators) {
                    for (p in end) _addPropTween.call(master, start, p, "get", end[p]);
                    func = function func(p) {
                        return _renderPropTweens(p, master) || (isString ? start.p : start);
                    };
                }
            }
            return _conditionalReturn(progress, func);
        }, _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
            var p, distance, label, labels = timeline.labels, min = _bigNum;
            for (p in labels) {
                distance = labels[p] - fromTime;
                if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
                    label = p;
                    min = distance;
                }
            }
            return label;
        }, _callback = function _callback(animation, type, executeLazyFirst) {
            var params, scope, result, v = animation.vars, callback = v[type], prevContext = _context, context = animation._ctx;
            if (!callback) return;
            params = v[type + "Params"];
            scope = v.callbackScope || animation;
            executeLazyFirst && _lazyTweens.length && _lazyRender();
            context && (_context = context);
            result = params ? callback.apply(scope, params) : callback.call(scope);
            _context = prevContext;
            return result;
        }, _interrupt = function _interrupt(animation) {
            _removeFromParent(animation);
            animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
            animation.progress() < 1 && _callback(animation, "onInterrupt");
            return animation;
        }, _registerPluginQueue = [], _createPlugin = function _createPlugin(config) {
            if (_windowExists() && config) {
                config = !config.name && config["default"] || config;
                var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function() {
                    this._props = [];
                } : config, instanceDefaults = {
                    init: _emptyFunc,
                    render: _renderPropTweens,
                    add: _addPropTween,
                    kill: _killPropTweensOf,
                    modifier: _addPluginModifier,
                    rawVars: 0
                }, statics = {
                    targetTest: 0,
                    get: 0,
                    getSetter: _getSetter,
                    aliases: {},
                    register: 0
                };
                _wake();
                if (config !== Plugin) {
                    if (_plugins[name]) return;
                    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
                    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
                    _plugins[Plugin.prop = name] = Plugin;
                    if (config.targetTest) {
                        _harnessPlugins.push(Plugin);
                        _reservedProps[name] = 1;
                    }
                    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
                }
                _addGlobal(name, Plugin);
                config.register && config.register(gsap, Plugin, PropTween);
            } else config && _registerPluginQueue.push(config);
        }, _255 = 255, _colorLookup = {
            aqua: [ 0, _255, _255 ],
            lime: [ 0, _255, 0 ],
            silver: [ 192, 192, 192 ],
            black: [ 0, 0, 0 ],
            maroon: [ 128, 0, 0 ],
            teal: [ 0, 128, 128 ],
            blue: [ 0, 0, _255 ],
            navy: [ 0, 0, 128 ],
            white: [ _255, _255, _255 ],
            olive: [ 128, 128, 0 ],
            yellow: [ _255, _255, 0 ],
            orange: [ _255, 165, 0 ],
            gray: [ 128, 128, 128 ],
            purple: [ 128, 0, 128 ],
            green: [ 0, 128, 0 ],
            red: [ _255, 0, 0 ],
            pink: [ _255, 192, 203 ],
            cyan: [ 0, _255, _255 ],
            transparent: [ _255, _255, _255, 0 ]
        }, _hue = function _hue(h, m1, m2) {
            h += h < 0 ? 1 : h > 1 ? -1 : 0;
            return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
        }, splitColor = function splitColor(v, toHSL, forceAlpha) {
            var r, g, b, h, s, l, max, min, d, wasHSL, a = !v ? _colorLookup.black : _isNumber(v) ? [ v >> 16, v >> 8 & _255, v & _255 ] : 0;
            if (!a) {
                if (v.substr(-1) === ",") v = v.substr(0, v.length - 1);
                if (_colorLookup[v]) a = _colorLookup[v]; else if (v.charAt(0) === "#") {
                    if (v.length < 6) {
                        r = v.charAt(1);
                        g = v.charAt(2);
                        b = v.charAt(3);
                        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
                    }
                    if (v.length === 9) {
                        a = parseInt(v.substr(1, 6), 16);
                        return [ a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255 ];
                    }
                    v = parseInt(v.substr(1), 16);
                    a = [ v >> 16, v >> 8 & _255, v & _255 ];
                } else if (v.substr(0, 3) === "hsl") {
                    a = wasHSL = v.match(_strictNumExp);
                    if (!toHSL) {
                        h = +a[0] % 360 / 360;
                        s = +a[1] / 100;
                        l = +a[2] / 100;
                        g = l <= .5 ? l * (s + 1) : l + s - l * s;
                        r = l * 2 - g;
                        a.length > 3 && (a[3] *= 1);
                        a[0] = _hue(h + 1 / 3, r, g);
                        a[1] = _hue(h, r, g);
                        a[2] = _hue(h - 1 / 3, r, g);
                    } else if (~v.indexOf("=")) {
                        a = v.match(_numExp);
                        forceAlpha && a.length < 4 && (a[3] = 1);
                        return a;
                    }
                } else a = v.match(_strictNumExp) || _colorLookup.transparent;
                a = a.map(Number);
            }
            if (toHSL && !wasHSL) {
                r = a[0] / _255;
                g = a[1] / _255;
                b = a[2] / _255;
                max = Math.max(r, g, b);
                min = Math.min(r, g, b);
                l = (max + min) / 2;
                if (max === min) h = s = 0; else {
                    d = max - min;
                    s = l > .5 ? d / (2 - max - min) : d / (max + min);
                    h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
                    h *= 60;
                }
                a[0] = ~~(h + .5);
                a[1] = ~~(s * 100 + .5);
                a[2] = ~~(l * 100 + .5);
            }
            forceAlpha && a.length < 4 && (a[3] = 1);
            return a;
        }, _colorOrderData = function _colorOrderData(v) {
            var values = [], c = [], i = -1;
            v.split(_colorExp).forEach((function(v) {
                var a = v.match(_numWithUnitExp) || [];
                values.push.apply(values, a);
                c.push(i += a.length + 1);
            }));
            values.c = c;
            return values;
        }, _formatColors = function _formatColors(s, toHSL, orderMatchData) {
            var c, shell, d, l, result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0;
            if (!colors) return s;
            colors = colors.map((function(color) {
                return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
            }));
            if (orderMatchData) {
                d = _colorOrderData(s);
                c = orderMatchData.c;
                if (c.join(result) !== d.c.join(result)) {
                    shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
                    l = shell.length - 1;
                    for (;i < l; i++) result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
                }
            }
            if (!shell) {
                shell = s.split(_colorExp);
                l = shell.length - 1;
                for (;i < l; i++) result += shell[i] + colors[i];
            }
            return result + shell[l];
        }, _colorExp = function() {
            var p, s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (p in _colorLookup) s += "|" + p + "\\b";
            return new RegExp(s + ")", "gi");
        }(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function _colorStringFilter(a) {
            var toHSL, combined = a.join(" ");
            _colorExp.lastIndex = 0;
            if (_colorExp.test(combined)) {
                toHSL = _hslExp.test(combined);
                a[1] = _formatColors(a[1], toHSL);
                a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
                return true;
            }
        }, _ticker = function() {
            var _id, _req, _raf, _self, _delta, _i, _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners = [], _tick = function _tick(v) {
                var overlap, dispatch, time, frame, elapsed = _getTime() - _lastUpdate, manual = v === true;
                elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
                _lastUpdate += elapsed;
                time = _lastUpdate - _startTime;
                overlap = time - _nextTime;
                if (overlap > 0 || manual) {
                    frame = ++_self.frame;
                    _delta = time - _self.time * 1e3;
                    _self.time = time /= 1e3;
                    _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
                    dispatch = 1;
                }
                manual || (_id = _req(_tick));
                if (dispatch) for (_i = 0; _i < _listeners.length; _i++) _listeners[_i](time, _delta, frame, v);
            };
            _self = {
                time: 0,
                frame: 0,
                tick: function tick() {
                    _tick(true);
                },
                deltaRatio: function deltaRatio(fps) {
                    return _delta / (1e3 / (fps || 60));
                },
                wake: function wake() {
                    if (_coreReady) {
                        if (!_coreInitted && _windowExists()) {
                            _win = _coreInitted = window;
                            _doc = _win.document || {};
                            _globals.gsap = gsap;
                            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
                            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                            _raf = _win.requestAnimationFrame;
                            _registerPluginQueue.forEach(_createPlugin);
                        }
                        _id && _self.sleep();
                        _req = _raf || function(f) {
                            return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
                        };
                        _tickerActive = 1;
                        _tick(2);
                    }
                },
                sleep: function sleep() {
                    (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
                    _tickerActive = 0;
                    _req = _emptyFunc;
                },
                lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
                    _lagThreshold = threshold || 1 / 0;
                    _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
                },
                fps: function fps(_fps) {
                    _gap = 1e3 / (_fps || 240);
                    _nextTime = _self.time * 1e3 + _gap;
                },
                add: function add(callback, once, prioritize) {
                    var func = once ? function(t, d, f, v) {
                        callback(t, d, f, v);
                        _self.remove(func);
                    } : callback;
                    _self.remove(callback);
                    _listeners[prioritize ? "unshift" : "push"](func);
                    _wake();
                    return func;
                },
                remove: function remove(callback, i) {
                    ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
                },
                _listeners
            };
            return _self;
        }(), _wake = function _wake() {
            return !_tickerActive && _ticker.wake();
        }, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function _parseObjectInString(value) {
            var index, val, parsedVal, obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length;
            for (;i < l; i++) {
                val = split[i];
                index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
                parsedVal = val.substr(0, index);
                obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
                key = val.substr(index + 1).trim();
            }
            return obj;
        }, _valueInParentheses = function _valueInParentheses(value) {
            var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
            return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
        }, _configEaseFromString = function _configEaseFromString(name) {
            var split = (name + "").split("("), ease = _easeMap[split[0]];
            return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [ _parseObjectInString(split[1]) ] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
        }, _invertEase = function _invertEase(ease) {
            return function(p) {
                return 1 - ease(1 - p);
            };
        }, _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
            var ease, child = timeline._first;
            while (child) {
                if (child instanceof Timeline) _propagateYoyoEase(child, isYoyo); else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) if (child.timeline) _propagateYoyoEase(child.timeline, isYoyo); else {
                    ease = child._ease;
                    child._ease = child._yEase;
                    child._yEase = ease;
                    child._yoyo = isYoyo;
                }
                child = child._next;
            }
        }, _parseEase = function _parseEase(ease, defaultEase) {
            return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
        }, _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
            if (easeOut === void 0) easeOut = function easeOut(p) {
                return 1 - easeIn(1 - p);
            };
            if (easeInOut === void 0) easeInOut = function easeInOut(p) {
                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
            };
            var lowercaseName, ease = {
                easeIn,
                easeOut,
                easeInOut
            };
            _forEachName(names, (function(name) {
                _easeMap[name] = _globals[name] = ease;
                _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
                for (var p in ease) _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
            }));
            return ease;
        }, _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
            return function(p) {
                return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
            };
        }, _configElastic = function _configElastic(type, amplitude, period) {
            var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut(p) {
                return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
            }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
                return 1 - easeOut(1 - p);
            } : _easeInOutFromOut(easeOut);
            p2 = _2PI / p2;
            ease.config = function(amplitude, period) {
                return _configElastic(type, amplitude, period);
            };
            return ease;
        }, _configBack = function _configBack(type, overshoot) {
            if (overshoot === void 0) overshoot = 1.70158;
            var easeOut = function easeOut(p) {
                return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
            }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
                return 1 - easeOut(1 - p);
            } : _easeInOutFromOut(easeOut);
            ease.config = function(overshoot) {
                return _configBack(type, overshoot);
            };
            return ease;
        };
        _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", (function(name, i) {
            var power = i < 5 ? i + 1 : i;
            _insertEase(name + ",Power" + (power - 1), i ? function(p) {
                return Math.pow(p, power);
            } : function(p) {
                return p;
            }, (function(p) {
                return 1 - Math.pow(1 - p, power);
            }), (function(p) {
                return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
            }));
        }));
        _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
        _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
        (function(n, c) {
            var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut(p) {
                return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
            };
            _insertEase("Bounce", (function(p) {
                return 1 - easeOut(1 - p);
            }), easeOut);
        })(7.5625, 2.75);
        _insertEase("Expo", (function(p) {
            return p ? Math.pow(2, 10 * (p - 1)) : 0;
        }));
        _insertEase("Circ", (function(p) {
            return -(_sqrt(1 - p * p) - 1);
        }));
        _insertEase("Sine", (function(p) {
            return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
        }));
        _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
        _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
            config: function config(steps, immediateStart) {
                if (steps === void 0) steps = 1;
                var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
                return function(p) {
                    return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
                };
            }
        };
        _defaults.ease = _easeMap["quad.out"];
        _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(name) {
            return _callbackNames += name + "," + name + "Params,";
        }));
        var GSCache = function GSCache(target, harness) {
            this.id = _gsID++;
            target._gsap = this;
            this.target = target;
            this.harness = harness;
            this.get = harness ? harness.get : _getProperty;
            this.set = harness ? harness.getSetter : _getSetter;
        };
        var gsap_core_Animation = function() {
            function Animation(vars) {
                this.vars = vars;
                this._delay = +vars.delay || 0;
                if (this._repeat = vars.repeat === 1 / 0 ? -2 : vars.repeat || 0) {
                    this._rDelay = vars.repeatDelay || 0;
                    this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
                }
                this._ts = 1;
                _setDuration(this, +vars.duration, 1, 1);
                this.data = vars.data;
                if (_context) {
                    this._ctx = _context;
                    _context.data.push(this);
                }
                _tickerActive || _ticker.wake();
            }
            var _proto = Animation.prototype;
            _proto.delay = function delay(value) {
                if (value || value === 0) {
                    this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
                    this._delay = value;
                    return this;
                }
                return this._delay;
            };
            _proto.duration = function duration(value) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
            };
            _proto.totalDuration = function totalDuration(value) {
                if (!arguments.length) return this._tDur;
                this._dirty = 0;
                return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
            };
            _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
                _wake();
                if (!arguments.length) return this._tTime;
                var parent = this._dp;
                if (parent && parent.smoothChildTiming && this._ts) {
                    _alignPlayhead(this, _totalTime);
                    !parent._dp || parent.parent || _postAddChecks(parent, this);
                    while (parent && parent.parent) {
                        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) parent.totalTime(parent._tTime, true);
                        parent = parent.parent;
                    }
                    if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) _addToTimeline(this._dp, this, this._start - this._delay);
                }
                if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
                    this._ts || (this._pTime = _totalTime);
                    _lazySafeRender(this, _totalTime, suppressEvents);
                }
                return this;
            };
            _proto.time = function time(value, suppressEvents) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
            };
            _proto.totalProgress = function totalProgress(value, suppressEvents) {
                return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
            };
            _proto.progress = function progress(value, suppressEvents) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
            };
            _proto.iteration = function iteration(value, suppressEvents) {
                var cycleDuration = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
            };
            _proto.timeScale = function timeScale(value) {
                if (!arguments.length) return this._rts === -_tinyNum ? 0 : this._rts;
                if (this._rts === value) return this;
                var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
                this._rts = +value || 0;
                this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
                this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), true);
                _setEnd(this);
                return _recacheAncestors(this);
            };
            _proto.paused = function paused(value) {
                if (!arguments.length) return this._ps;
                if (this._ps !== value) {
                    this._ps = value;
                    if (value) {
                        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
                        this._ts = this._act = 0;
                    } else {
                        _wake();
                        this._ts = this._rts;
                        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
                    }
                }
                return this;
            };
            _proto.startTime = function startTime(value) {
                if (arguments.length) {
                    this._start = value;
                    var parent = this.parent || this._dp;
                    parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
                    return this;
                }
                return this._start;
            };
            _proto.endTime = function endTime(includeRepeats) {
                return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
            };
            _proto.rawTime = function rawTime(wrapRepeats) {
                var parent = this.parent || this._dp;
                return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
            };
            _proto.revert = function revert(config) {
                if (config === void 0) config = _revertConfig;
                var prevIsReverting = _reverting;
                _reverting = config;
                if (this._initted || this._startAt) {
                    this.timeline && this.timeline.revert(config);
                    this.totalTime(-.01, config.suppressEvents);
                }
                this.data !== "nested" && config.kill !== false && this.kill();
                _reverting = prevIsReverting;
                return this;
            };
            _proto.globalTime = function globalTime(rawTime) {
                var animation = this, time = arguments.length ? rawTime : animation.rawTime();
                while (animation) {
                    time = animation._start + time / (animation._ts || 1);
                    animation = animation._dp;
                }
                return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(rawTime) : time;
            };
            _proto.repeat = function repeat(value) {
                if (arguments.length) {
                    this._repeat = value === 1 / 0 ? -2 : value;
                    return _onUpdateTotalDuration(this);
                }
                return this._repeat === -2 ? 1 / 0 : this._repeat;
            };
            _proto.repeatDelay = function repeatDelay(value) {
                if (arguments.length) {
                    var time = this._time;
                    this._rDelay = value;
                    _onUpdateTotalDuration(this);
                    return time ? this.time(time) : this;
                }
                return this._rDelay;
            };
            _proto.yoyo = function yoyo(value) {
                if (arguments.length) {
                    this._yoyo = value;
                    return this;
                }
                return this._yoyo;
            };
            _proto.seek = function seek(position, suppressEvents) {
                return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
            };
            _proto.restart = function restart(includeDelay, suppressEvents) {
                return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
            };
            _proto.play = function play(from, suppressEvents) {
                from != null && this.seek(from, suppressEvents);
                return this.reversed(false).paused(false);
            };
            _proto.reverse = function reverse(from, suppressEvents) {
                from != null && this.seek(from || this.totalDuration(), suppressEvents);
                return this.reversed(true).paused(false);
            };
            _proto.pause = function pause(atTime, suppressEvents) {
                atTime != null && this.seek(atTime, suppressEvents);
                return this.paused(true);
            };
            _proto.resume = function resume() {
                return this.paused(false);
            };
            _proto.reversed = function reversed(value) {
                if (arguments.length) {
                    !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
                    return this;
                }
                return this._rts < 0;
            };
            _proto.invalidate = function invalidate() {
                this._initted = this._act = 0;
                this._zTime = -_tinyNum;
                return this;
            };
            _proto.isActive = function isActive() {
                var rawTime, parent = this.parent || this._dp, start = this._start;
                return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
            };
            _proto.eventCallback = function eventCallback(type, callback, params) {
                var vars = this.vars;
                if (arguments.length > 1) {
                    if (!callback) delete vars[type]; else {
                        vars[type] = callback;
                        params && (vars[type + "Params"] = params);
                        type === "onUpdate" && (this._onUpdate = callback);
                    }
                    return this;
                }
                return vars[type];
            };
            _proto.then = function then(onFulfilled) {
                var self = this;
                return new Promise((function(resolve) {
                    var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve() {
                        var _then = self.then;
                        self.then = null;
                        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
                        resolve(f);
                        self.then = _then;
                    };
                    if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) _resolve(); else self._prom = _resolve;
                }));
            };
            _proto.kill = function kill() {
                _interrupt(this);
            };
            return Animation;
        }();
        _setDefaults(gsap_core_Animation.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: false,
            parent: null,
            _initted: false,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -_tinyNum,
            _prom: 0,
            _ps: false,
            _rts: 1
        });
        var Timeline = function(_Animation) {
            _inheritsLoose(Timeline, _Animation);
            function Timeline(vars, position) {
                var _this;
                if (vars === void 0) vars = {};
                _this = _Animation.call(this, vars) || this;
                _this.labels = {};
                _this.smoothChildTiming = !!vars.smoothChildTiming;
                _this.autoRemoveChildren = !!vars.autoRemoveChildren;
                _this._sort = _isNotFalse(vars.sortChildren);
                _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
                vars.reversed && _this.reverse();
                vars.paused && _this.paused(true);
                vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
                return _this;
            }
            var _proto2 = Timeline.prototype;
            _proto2.to = function to(targets, vars, position) {
                _createTweenType(0, arguments, this);
                return this;
            };
            _proto2.from = function from(targets, vars, position) {
                _createTweenType(1, arguments, this);
                return this;
            };
            _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
                _createTweenType(2, arguments, this);
                return this;
            };
            _proto2.set = function set(targets, vars, position) {
                vars.duration = 0;
                vars.parent = this;
                _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
                vars.immediateRender = !!vars.immediateRender;
                new Tween(targets, vars, _parsePosition(this, position), 1);
                return this;
            };
            _proto2.call = function call(callback, params, position) {
                return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
            };
            _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                vars.duration = duration;
                vars.stagger = vars.stagger || stagger;
                vars.onComplete = onCompleteAll;
                vars.onCompleteParams = onCompleteAllParams;
                vars.parent = this;
                new Tween(targets, vars, _parsePosition(this, position));
                return this;
            };
            _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                vars.runBackwards = 1;
                _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
                return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
            };
            _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
                toVars.startAt = fromVars;
                _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
                return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
            };
            _proto2.render = function render(totalTime, suppressEvents, force) {
                var time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo, prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur);
                this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
                if (tTime !== this._tTime || force || crossingStart) {
                    if (prevTime !== this._time && dur) {
                        tTime += this._time - prevTime;
                        totalTime += this._time - prevTime;
                    }
                    time = tTime;
                    prevStart = this._start;
                    timeScale = this._ts;
                    prevPaused = !timeScale;
                    if (crossingStart) {
                        dur || (prevTime = this._zTime);
                        (totalTime || !suppressEvents) && (this._zTime = totalTime);
                    }
                    if (this._repeat) {
                        yoyo = this._yoyo;
                        cycleDuration = dur + this._rDelay;
                        if (this._repeat < -1 && totalTime < 0) return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
                        time = _roundPrecise(tTime % cycleDuration);
                        if (tTime === tDur) {
                            iteration = this._repeat;
                            time = dur;
                        } else {
                            iteration = ~~(tTime / cycleDuration);
                            if (iteration && iteration === tTime / cycleDuration) {
                                time = dur;
                                iteration--;
                            }
                            time > dur && (time = dur);
                        }
                        prevIteration = _animationCycle(this._tTime, cycleDuration);
                        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
                        if (yoyo && iteration & 1) {
                            time = dur - time;
                            isYoyo = 1;
                        }
                        if (iteration !== prevIteration && !this._lock) {
                            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
                            iteration < prevIteration && (rewinding = !rewinding);
                            prevTime = rewinding ? 0 : dur;
                            this._lock = 1;
                            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                            this._tTime = tTime;
                            !suppressEvents && this.parent && _callback(this, "onRepeat");
                            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            dur = this._dur;
                            tDur = this._tDur;
                            if (doesWrap) {
                                this._lock = 2;
                                prevTime = rewinding ? dur : -1e-4;
                                this.render(prevTime, true);
                                this.vars.repeatRefresh && !isYoyo && this.invalidate();
                            }
                            this._lock = 0;
                            if (!this._ts && !prevPaused) return this;
                            _propagateYoyoEase(this, isYoyo);
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2) {
                        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
                        if (pauseTween) tTime -= time - (time = pauseTween._start);
                    }
                    this._tTime = tTime;
                    this._time = time;
                    this._act = !timeScale;
                    if (!this._initted) {
                        this._onUpdate = this.vars.onUpdate;
                        this._initted = 1;
                        this._zTime = totalTime;
                        prevTime = 0;
                    }
                    if (!prevTime && time && !suppressEvents && !iteration) {
                        _callback(this, "onStart");
                        if (this._tTime !== tTime) return this;
                    }
                    if (time >= prevTime && totalTime >= 0) {
                        child = this._first;
                        while (child) {
                            next = child._next;
                            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                                if (child.parent !== this) return this.render(totalTime, suppressEvents, force);
                                child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                                if (time !== this._time || !this._ts && !prevPaused) {
                                    pauseTween = 0;
                                    next && (tTime += this._zTime = -_tinyNum);
                                    break;
                                }
                            }
                            child = next;
                        }
                    } else {
                        child = this._last;
                        var adjustedTime = totalTime < 0 ? totalTime : time;
                        while (child) {
                            next = child._prev;
                            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                                if (child.parent !== this) return this.render(totalTime, suppressEvents, force);
                                child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
                                if (time !== this._time || !this._ts && !prevPaused) {
                                    pauseTween = 0;
                                    next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                                    break;
                                }
                            }
                            child = next;
                        }
                    }
                    if (pauseTween && !suppressEvents) {
                        this.pause();
                        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
                        if (this._ts) {
                            this._start = prevStart;
                            _setEnd(this);
                            return this.render(totalTime, suppressEvents, force);
                        }
                    }
                    this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
                    if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
                        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                            _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                        }
                    }
                }
                return this;
            };
            _proto2.add = function add(child, position) {
                var _this2 = this;
                _isNumber(position) || (position = _parsePosition(this, position, child));
                if (!(child instanceof gsap_core_Animation)) {
                    if (_isArray(child)) {
                        child.forEach((function(obj) {
                            return _this2.add(obj, position);
                        }));
                        return this;
                    }
                    if (_isString(child)) return this.addLabel(child, position);
                    if (_isFunction(child)) child = Tween.delayedCall(0, child); else return this;
                }
                return this !== child ? _addToTimeline(this, child, position) : this;
            };
            _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
                if (nested === void 0) nested = true;
                if (tweens === void 0) tweens = true;
                if (timelines === void 0) timelines = true;
                if (ignoreBeforeTime === void 0) ignoreBeforeTime = -_bigNum;
                var a = [], child = this._first;
                while (child) {
                    if (child._start >= ignoreBeforeTime) if (child instanceof Tween) tweens && a.push(child); else {
                        timelines && a.push(child);
                        nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
                    }
                    child = child._next;
                }
                return a;
            };
            _proto2.getById = function getById(id) {
                var animations = this.getChildren(1, 1, 1), i = animations.length;
                while (i--) if (animations[i].vars.id === id) return animations[i];
            };
            _proto2.remove = function remove(child) {
                if (_isString(child)) return this.removeLabel(child);
                if (_isFunction(child)) return this.killTweensOf(child);
                _removeLinkedListItem(this, child);
                if (child === this._recent) this._recent = this._last;
                return _uncache(this);
            };
            _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
                if (!arguments.length) return this._tTime;
                this._forcing = 1;
                if (!this._dp && this._ts) this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
                _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
                this._forcing = 0;
                return this;
            };
            _proto2.addLabel = function addLabel(label, position) {
                this.labels[label] = _parsePosition(this, position);
                return this;
            };
            _proto2.removeLabel = function removeLabel(label) {
                delete this.labels[label];
                return this;
            };
            _proto2.addPause = function addPause(position, callback, params) {
                var t = Tween.delayedCall(0, callback || _emptyFunc, params);
                t.data = "isPause";
                this._hasPause = 1;
                return _addToTimeline(this, t, _parsePosition(this, position));
            };
            _proto2.removePause = function removePause(position) {
                var child = this._first;
                position = _parsePosition(this, position);
                while (child) {
                    if (child._start === position && child.data === "isPause") _removeFromParent(child);
                    child = child._next;
                }
            };
            _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
                while (i--) _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
                return this;
            };
            _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
                var children, a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive);
                while (child) {
                    if (child instanceof Tween) {
                        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) a.push(child);
                    } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) a.push.apply(a, children);
                    child = child._next;
                }
                return a;
            };
            _proto2.tweenTo = function tweenTo(position, vars) {
                vars = vars || {};
                var initted, tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, tween = Tween.to(tl, _setDefaults({
                    ease: vars.ease || "none",
                    lazy: false,
                    immediateRender: false,
                    time: endTime,
                    overwrite: "auto",
                    duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
                    onStart: function onStart() {
                        tl.pause();
                        if (!initted) {
                            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
                            initted = 1;
                        }
                        _onStart && _onStart.apply(tween, onStartParams || []);
                    }
                }, vars));
                return immediateRender ? tween.render(0) : tween;
            };
            _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
                return this.tweenTo(toPosition, _setDefaults({
                    startAt: {
                        time: _parsePosition(this, fromPosition)
                    }
                }, vars));
            };
            _proto2.recent = function recent() {
                return this._recent;
            };
            _proto2.nextLabel = function nextLabel(afterTime) {
                if (afterTime === void 0) afterTime = this._time;
                return _getLabelInDirection(this, _parsePosition(this, afterTime));
            };
            _proto2.previousLabel = function previousLabel(beforeTime) {
                if (beforeTime === void 0) beforeTime = this._time;
                return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
            };
            _proto2.currentLabel = function currentLabel(value) {
                return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
            };
            _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
                if (ignoreBeforeTime === void 0) ignoreBeforeTime = 0;
                var p, child = this._first, labels = this.labels;
                while (child) {
                    if (child._start >= ignoreBeforeTime) {
                        child._start += amount;
                        child._end += amount;
                    }
                    child = child._next;
                }
                if (adjustLabels) for (p in labels) if (labels[p] >= ignoreBeforeTime) labels[p] += amount;
                return _uncache(this);
            };
            _proto2.invalidate = function invalidate(soft) {
                var child = this._first;
                this._lock = 0;
                while (child) {
                    child.invalidate(soft);
                    child = child._next;
                }
                return _Animation.prototype.invalidate.call(this, soft);
            };
            _proto2.clear = function clear(includeLabels) {
                if (includeLabels === void 0) includeLabels = true;
                var next, child = this._first;
                while (child) {
                    next = child._next;
                    this.remove(child);
                    child = next;
                }
                this._dp && (this._time = this._tTime = this._pTime = 0);
                includeLabels && (this.labels = {});
                return _uncache(this);
            };
            _proto2.totalDuration = function totalDuration(value) {
                var prev, start, parent, max = 0, self = this, child = self._last, prevStart = _bigNum;
                if (arguments.length) return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
                if (self._dirty) {
                    parent = self.parent;
                    while (child) {
                        prev = child._prev;
                        child._dirty && child.totalDuration();
                        start = child._start;
                        if (start > prevStart && self._sort && child._ts && !self._lock) {
                            self._lock = 1;
                            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
                        } else prevStart = start;
                        if (start < 0 && child._ts) {
                            max -= start;
                            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                                self._start += start / self._ts;
                                self._time -= start;
                                self._tTime -= start;
                            }
                            self.shiftChildren(-start, false, -Infinity);
                            prevStart = 0;
                        }
                        child._end > max && child._ts && (max = child._end);
                        child = prev;
                    }
                    _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
                    self._dirty = 0;
                }
                return self._tDur;
            };
            Timeline.updateRoot = function updateRoot(time) {
                if (_globalTimeline._ts) {
                    _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
                    _lastRenderedFrame = _ticker.frame;
                }
                if (_ticker.frame >= _nextGCFrame) {
                    _nextGCFrame += _config.autoSleep || 120;
                    var child = _globalTimeline._first;
                    if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
                        while (child && !child._ts) child = child._next;
                        child || _ticker.sleep();
                    }
                }
            };
            return Timeline;
        }(gsap_core_Animation);
        _setDefaults(Timeline.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var _overwritingTween, _forceAllPropTweens, _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
            var result, startNums, color, endNum, chunk, startNum, hasRandom, a, pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0;
            pt.b = start;
            pt.e = end;
            start += "";
            end += "";
            if (hasRandom = ~end.indexOf("random(")) end = _replaceRandom(end);
            if (stringFilter) {
                a = [ start, end ];
                stringFilter(a, target, prop);
                start = a[0];
                end = a[1];
            }
            startNums = start.match(_complexStringNumExp) || [];
            while (result = _complexStringNumExp.exec(end)) {
                endNum = result[0];
                chunk = end.substring(index, result.index);
                if (color) color = (color + 1) % 5; else if (chunk.substr(-5) === "rgba(") color = 1;
                if (endNum !== startNums[matchIndex++]) {
                    startNum = parseFloat(startNums[matchIndex - 1]) || 0;
                    pt._pt = {
                        _next: pt._pt,
                        p: chunk || matchIndex === 1 ? chunk : ",",
                        s: startNum,
                        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
                        m: color && color < 4 ? Math.round : 0
                    };
                    index = _complexStringNumExp.lastIndex;
                }
            }
            pt.c = index < end.length ? end.substring(index, end.length) : "";
            pt.fp = funcParam;
            if (_relExp.test(end) || hasRandom) pt.e = 0;
            this._pt = pt;
            return pt;
        }, _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
            _isFunction(end) && (end = end(index || 0, target, targets));
            var pt, currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc;
            if (_isString(end)) {
                if (~end.indexOf("random(")) end = _replaceRandom(end);
                if (end.charAt(1) === "=") {
                    pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
                    if (pt || pt === 0) end = pt;
                }
            }
            if (!optional || parsedStart !== end || _forceAllPropTweens) {
                if (!isNaN(parsedStart * end) && end !== "") {
                    pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
                    funcParam && (pt.fp = funcParam);
                    modifier && pt.modifier(modifier, this, target);
                    return this._pt = pt;
                }
                !currentValue && !(prop in target) && _missingPlugin(prop, end);
                return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
            }
        }, _processVars = function _processVars(vars, index, target, targets, tween) {
            _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
            if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
            var p, copy = {};
            for (p in vars) copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
            return copy;
        }, _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
            var plugin, pt, ptLookup, i;
            if (_plugins[property] && (plugin = new _plugins[property]).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
                tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
                if (tween !== _quickTween) {
                    ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
                    i = plugin._props.length;
                    while (i--) ptLookup[plugin._props[i]] = pt;
                }
            }
            return plugin;
        }, _initTween = function _initTween(tween, time, tTime) {
            var cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten, vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, onUpdateParams = vars.onUpdateParams, callbackScope = vars.callbackScope, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline;
            tl && (!keyframes || !ease) && (ease = "none");
            tween._ease = _parseEase(ease, _defaults.ease);
            tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
            if (yoyoEase && tween._yoyo && !tween._repeat) {
                yoyoEase = tween._yEase;
                tween._yEase = tween._ease;
                tween._ease = yoyoEase;
            }
            tween._from = !tl && !!vars.runBackwards;
            if (!tl || keyframes && !vars.stagger) {
                harness = targets[0] ? _getCache(targets[0]).harness : 0;
                harnessVars = harness && vars[harness.prop];
                cleanVars = _copyExcluding(vars, _reservedProps);
                if (prevStartAt) {
                    prevStartAt._zTime < 0 && prevStartAt.progress(1);
                    time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
                    prevStartAt._lazy = 0;
                }
                if (startAt) {
                    _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
                        data: "isStart",
                        overwrite: false,
                        parent,
                        immediateRender: true,
                        lazy: !prevStartAt && _isNotFalse(lazy),
                        startAt: null,
                        delay: 0,
                        onUpdate,
                        onUpdateParams,
                        callbackScope,
                        stagger: 0
                    }, startAt)));
                    tween._startAt._dp = 0;
                    tween._startAt._sat = tween;
                    time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
                    if (immediateRender) if (dur && time <= 0 && tTime <= 0) {
                        time && (tween._zTime = time);
                        return;
                    }
                } else if (runBackwards && dur) if (!prevStartAt) {
                    time && (immediateRender = false);
                    p = _setDefaults({
                        overwrite: false,
                        data: "isFromStart",
                        lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
                        immediateRender,
                        stagger: 0,
                        parent
                    }, cleanVars);
                    harnessVars && (p[harness.prop] = harnessVars);
                    _removeFromParent(tween._startAt = Tween.set(targets, p));
                    tween._startAt._dp = 0;
                    tween._startAt._sat = tween;
                    time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
                    tween._zTime = time;
                    if (!immediateRender) _initTween(tween._startAt, _tinyNum, _tinyNum); else if (!time) return;
                }
                tween._pt = tween._ptCache = 0;
                lazy = dur && _isNotFalse(lazy) || lazy && !dur;
                for (i = 0; i < targets.length; i++) {
                    target = targets[i];
                    gsData = target._gsap || _harness(targets)[i]._gsap;
                    tween._ptLookup[i] = ptLookup = {};
                    _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
                    index = fullTargets === targets ? i : fullTargets.indexOf(target);
                    if (harness && (plugin = new harness).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
                        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
                        plugin._props.forEach((function(name) {
                            ptLookup[name] = pt;
                        }));
                        plugin.priority && (hasPriority = 1);
                    }
                    if (!harness || harnessVars) for (p in cleanVars) if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) plugin.priority && (hasPriority = 1); else ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
                    tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
                    if (autoOverwrite && tween._pt) {
                        _overwritingTween = tween;
                        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
                        overwritten = !tween.parent;
                        _overwritingTween = 0;
                    }
                    tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
                }
                hasPriority && _sortPropTweensByPriority(tween);
                tween._onInit && tween._onInit(tween);
            }
            tween._onUpdate = onUpdate;
            tween._initted = (!tween._op || tween._pt) && !overwritten;
            keyframes && time <= 0 && tl.render(_bigNum, true, true);
        }, _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
            var pt, rootPT, lookup, i, ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property];
            if (!ptCache) {
                ptCache = tween._ptCache[property] = [];
                lookup = tween._ptLookup;
                i = tween._targets.length;
                while (i--) {
                    pt = lookup[i][property];
                    if (pt && pt.d && pt.d._pt) {
                        pt = pt.d._pt;
                        while (pt && pt.p !== property && pt.fp !== property) pt = pt._next;
                    }
                    if (!pt) {
                        _forceAllPropTweens = 1;
                        tween.vars[property] = "+=0";
                        _initTween(tween, time);
                        _forceAllPropTweens = 0;
                        return 1;
                    }
                    ptCache.push(pt);
                }
            }
            i = ptCache.length;
            while (i--) {
                rootPT = ptCache[i];
                pt = rootPT._pt || rootPT;
                pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
                pt.c = value - pt.s;
                rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
                rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
            }
        }, _addAliasesToVars = function _addAliasesToVars(targets, vars) {
            var copy, p, i, aliases, harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases;
            if (!propertyAliases) return vars;
            copy = _merge({}, vars);
            for (p in propertyAliases) if (p in copy) {
                aliases = propertyAliases[p].split(",");
                i = aliases.length;
                while (i--) copy[aliases[i]] = copy[p];
            }
            return copy;
        }, _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
            var p, a, ease = obj.ease || easeEach || "power1.inOut";
            if (_isArray(obj)) {
                a = allProps[prop] || (allProps[prop] = []);
                obj.forEach((function(value, i) {
                    return a.push({
                        t: i / (obj.length - 1) * 100,
                        v: value,
                        e: ease
                    });
                }));
            } else for (p in obj) {
                a = allProps[p] || (allProps[p] = []);
                p === "ease" || a.push({
                    t: parseFloat(prop),
                    v: obj[p],
                    e: ease
                });
            }
        }, _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
            return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
        }, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {};
        _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", (function(name) {
            return _staggerPropsToSkip[name] = 1;
        }));
        var Tween = function(_Animation2) {
            _inheritsLoose(Tween, _Animation2);
            function Tween(targets, vars, position, skipInherit) {
                var _this3;
                if (typeof vars === "number") {
                    position.duration = vars;
                    vars = position;
                    position = null;
                }
                _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
                var tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge, _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [ targets ] : toArray(targets);
                _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
                _this3._ptLookup = [];
                _this3._overwrite = overwrite;
                if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                    vars = _this3.vars;
                    tl = _this3.timeline = new Timeline({
                        data: "nested",
                        defaults: defaults || {},
                        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
                    });
                    tl.kill();
                    tl.parent = tl._dp = _assertThisInitialized(_this3);
                    tl._start = 0;
                    if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                        l = parsedTargets.length;
                        staggerFunc = stagger && distribute(stagger);
                        if (_isObject(stagger)) for (p in stagger) if (~_staggerTweenProps.indexOf(p)) {
                            staggerVarsToMerge || (staggerVarsToMerge = {});
                            staggerVarsToMerge[p] = stagger[p];
                        }
                        for (i = 0; i < l; i++) {
                            copy = _copyExcluding(vars, _staggerPropsToSkip);
                            copy.stagger = 0;
                            yoyoEase && (copy.yoyoEase = yoyoEase);
                            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
                            curTarget = parsedTargets[i];
                            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
                            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
                            if (!stagger && l === 1 && copy.delay) {
                                _this3._delay = delay = copy.delay;
                                _this3._start += delay;
                                copy.delay = 0;
                            }
                            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
                            tl._ease = _easeMap.none;
                        }
                        tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
                    } else if (keyframes) {
                        _inheritDefaults(_setDefaults(tl.vars.defaults, {
                            ease: "none"
                        }));
                        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
                        var a, kf, v, time = 0;
                        if (_isArray(keyframes)) {
                            keyframes.forEach((function(frame) {
                                return tl.to(parsedTargets, frame, ">");
                            }));
                            tl.duration();
                        } else {
                            copy = {};
                            for (p in keyframes) p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
                            for (p in copy) {
                                a = copy[p].sort((function(a, b) {
                                    return a.t - b.t;
                                }));
                                time = 0;
                                for (i = 0; i < a.length; i++) {
                                    kf = a[i];
                                    v = {
                                        ease: kf.e,
                                        duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                                    };
                                    v[p] = kf.v;
                                    tl.to(parsedTargets, v, time);
                                    time += v.duration;
                                }
                            }
                            tl.duration() < duration && tl.to({}, {
                                duration: duration - tl.duration()
                            });
                        }
                    }
                    duration || _this3.duration(duration = tl.duration());
                } else _this3.timeline = 0;
                if (overwrite === true && !_suppressOverwrites) {
                    _overwritingTween = _assertThisInitialized(_this3);
                    _globalTimeline.killTweensOf(parsedTargets);
                    _overwritingTween = 0;
                }
                _addToTimeline(parent, _assertThisInitialized(_this3), position);
                vars.reversed && _this3.reverse();
                vars.paused && _this3.paused(true);
                if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
                    _this3._tTime = -_tinyNum;
                    _this3.render(Math.max(0, -delay) || 0);
                }
                scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
                return _this3;
            }
            var _proto3 = Tween.prototype;
            _proto3.render = function render(totalTime, suppressEvents, force) {
                var time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase, prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime;
                if (!dur) _renderZeroDurationTween(this, totalTime, suppressEvents, force); else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
                    time = tTime;
                    timeline = this.timeline;
                    if (this._repeat) {
                        cycleDuration = dur + this._rDelay;
                        if (this._repeat < -1 && isNegative) return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
                        time = _roundPrecise(tTime % cycleDuration);
                        if (tTime === tDur) {
                            iteration = this._repeat;
                            time = dur;
                        } else {
                            iteration = ~~(tTime / cycleDuration);
                            if (iteration && iteration === tTime / cycleDuration) {
                                time = dur;
                                iteration--;
                            }
                            time > dur && (time = dur);
                        }
                        isYoyo = this._yoyo && iteration & 1;
                        if (isYoyo) {
                            yoyoEase = this._yEase;
                            time = dur - time;
                        }
                        prevIteration = _animationCycle(this._tTime, cycleDuration);
                        if (time === prevTime && !force && this._initted) {
                            this._tTime = tTime;
                            return this;
                        }
                        if (iteration !== prevIteration) {
                            timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
                            if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                                this._lock = force = 1;
                                this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
                            }
                        }
                    }
                    if (!this._initted) {
                        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
                            this._tTime = 0;
                            return this;
                        }
                        if (prevTime !== this._time) return this;
                        if (dur !== this._dur) return this.render(totalTime, suppressEvents, force);
                    }
                    this._tTime = tTime;
                    this._time = time;
                    if (!this._act && this._ts) {
                        this._act = 1;
                        this._lazy = 0;
                    }
                    this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
                    if (this._from) this.ratio = ratio = 1 - ratio;
                    if (time && !prevTime && !suppressEvents && !iteration) {
                        _callback(this, "onStart");
                        if (this._tTime !== tTime) return this;
                    }
                    pt = this._pt;
                    while (pt) {
                        pt.r(ratio, pt.d);
                        pt = pt._next;
                    }
                    timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
                    if (this._onUpdate && !suppressEvents) {
                        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
                        _callback(this, "onUpdate");
                    }
                    this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
                    if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
                        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
                        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
                            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                        }
                    }
                }
                return this;
            };
            _proto3.targets = function targets() {
                return this._targets;
            };
            _proto3.invalidate = function invalidate(soft) {
                (!soft || !this.vars.runBackwards) && (this._startAt = 0);
                this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
                this._ptLookup = [];
                this.timeline && this.timeline.invalidate(soft);
                return _Animation2.prototype.invalidate.call(this, soft);
            };
            _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
                _tickerActive || _ticker.wake();
                this._ts || this.play();
                var ratio, time = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                this._initted || _initTween(this, time);
                ratio = this._ease(time / this._dur);
                if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) return this.resetTo(property, value, start, startIsRelative);
                _alignPlayhead(this, 0);
                this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
                return this.render(0);
            };
            _proto3.kill = function kill(targets, vars) {
                if (vars === void 0) vars = "all";
                if (!targets && (!vars || vars === "all")) {
                    this._lazy = this._pt = 0;
                    return this.parent ? _interrupt(this) : this;
                }
                if (this.timeline) {
                    var tDur = this.timeline.totalDuration();
                    this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
                    this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
                    return this;
                }
                var overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i, parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt;
                if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
                    vars === "all" && (this._pt = 0);
                    return _interrupt(this);
                }
                overwrittenProps = this._op = this._op || [];
                if (vars !== "all") {
                    if (_isString(vars)) {
                        p = {};
                        _forEachName(vars, (function(name) {
                            return p[name] = 1;
                        }));
                        vars = p;
                    }
                    vars = _addAliasesToVars(parsedTargets, vars);
                }
                i = parsedTargets.length;
                while (i--) if (~killingTargets.indexOf(parsedTargets[i])) {
                    curLookup = propTweenLookup[i];
                    if (vars === "all") {
                        overwrittenProps[i] = vars;
                        props = curLookup;
                        curOverwriteProps = {};
                    } else {
                        curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
                        props = vars;
                    }
                    for (p in props) {
                        pt = curLookup && curLookup[p];
                        if (pt) {
                            if (!("kill" in pt.d) || pt.d.kill(p) === true) _removeLinkedListItem(this, pt, "_pt");
                            delete curLookup[p];
                        }
                        if (curOverwriteProps !== "all") curOverwriteProps[p] = 1;
                    }
                }
                this._initted && !this._pt && firstPT && _interrupt(this);
                return this;
            };
            Tween.to = function to(targets, vars) {
                return new Tween(targets, vars, arguments[2]);
            };
            Tween.from = function from(targets, vars) {
                return _createTweenType(1, arguments);
            };
            Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
                return new Tween(callback, 0, {
                    immediateRender: false,
                    lazy: false,
                    overwrite: false,
                    delay,
                    onComplete: callback,
                    onReverseComplete: callback,
                    onCompleteParams: params,
                    onReverseCompleteParams: params,
                    callbackScope: scope
                });
            };
            Tween.fromTo = function fromTo(targets, fromVars, toVars) {
                return _createTweenType(2, arguments);
            };
            Tween.set = function set(targets, vars) {
                vars.duration = 0;
                vars.repeatDelay || (vars.repeat = 0);
                return new Tween(targets, vars);
            };
            Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                return _globalTimeline.killTweensOf(targets, props, onlyActive);
            };
            return Tween;
        }(gsap_core_Animation);
        _setDefaults(Tween.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        });
        _forEachName("staggerTo,staggerFrom,staggerFromTo", (function(name) {
            Tween[name] = function() {
                var tl = new Timeline, params = _slice.call(arguments, 0);
                params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
                return tl[name].apply(tl, params);
            };
        }));
        var _setterPlain = function _setterPlain(target, property, value) {
            return target[property] = value;
        }, _setterFunc = function _setterFunc(target, property, value) {
            return target[property](value);
        }, _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
            return target[property](data.fp, value);
        }, _setterAttribute = function _setterAttribute(target, property, value) {
            return target.setAttribute(property, value);
        }, _getSetter = function _getSetter(target, property) {
            return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
        }, _renderPlain = function _renderPlain(ratio, data) {
            return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
        }, _renderBoolean = function _renderBoolean(ratio, data) {
            return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
        }, _renderComplexString = function _renderComplexString(ratio, data) {
            var pt = data._pt, s = "";
            if (!ratio && data.b) s = data.b; else if (ratio === 1 && data.e) s = data.e; else {
                while (pt) {
                    s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
                    pt = pt._next;
                }
                s += data.c;
            }
            data.set(data.t, data.p, s, data);
        }, _renderPropTweens = function _renderPropTweens(ratio, data) {
            var pt = data._pt;
            while (pt) {
                pt.r(ratio, pt.d);
                pt = pt._next;
            }
        }, _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
            var next, pt = this._pt;
            while (pt) {
                next = pt._next;
                pt.p === property && pt.modifier(modifier, tween, target);
                pt = next;
            }
        }, _killPropTweensOf = function _killPropTweensOf(property) {
            var hasNonDependentRemaining, next, pt = this._pt;
            while (pt) {
                next = pt._next;
                if (pt.p === property && !pt.op || pt.op === property) _removeLinkedListItem(this, pt, "_pt"); else if (!pt.dep) hasNonDependentRemaining = 1;
                pt = next;
            }
            return !hasNonDependentRemaining;
        }, _setterWithModifier = function _setterWithModifier(target, property, value, data) {
            data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
        }, _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
            var next, pt2, first, last, pt = parent._pt;
            while (pt) {
                next = pt._next;
                pt2 = first;
                while (pt2 && pt2.pr > pt.pr) pt2 = pt2._next;
                if (pt._prev = pt2 ? pt2._prev : last) pt._prev._next = pt; else first = pt;
                if (pt._next = pt2) pt2._prev = pt; else last = pt;
                pt = next;
            }
            parent._pt = first;
        };
        var PropTween = function() {
            function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
                this.t = target;
                this.s = start;
                this.c = change;
                this.p = prop;
                this.r = renderer || _renderPlain;
                this.d = data || this;
                this.set = setter || _setterPlain;
                this.pr = priority || 0;
                this._next = next;
                if (next) next._prev = this;
            }
            var _proto4 = PropTween.prototype;
            _proto4.modifier = function modifier(func, tween, target) {
                this.mSet = this.mSet || this.set;
                this.set = _setterWithModifier;
                this.m = func;
                this.mt = target;
                this.tween = tween;
            };
            return PropTween;
        }();
        _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(name) {
            return _reservedProps[name] = 1;
        }));
        _globals.TweenMax = _globals.TweenLite = Tween;
        _globals.TimelineLite = _globals.TimelineMax = Timeline;
        _globalTimeline = new Timeline({
            sortChildren: false,
            defaults: _defaults,
            autoRemoveChildren: true,
            id: "root",
            smoothChildTiming: true
        });
        _config.stringFilter = _colorStringFilter;
        var _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch(type) {
            return (_listeners[type] || _emptyArray).map((function(f) {
                return f();
            }));
        }, _onMediaChange = function _onMediaChange() {
            var time = Date.now(), matches = [];
            if (time - _lastMediaTime > 2) {
                _dispatch("matchMediaInit");
                _media.forEach((function(c) {
                    var match, p, anyMatch, toggled, queries = c.queries, conditions = c.conditions;
                    for (p in queries) {
                        match = _win.matchMedia(queries[p]).matches;
                        match && (anyMatch = 1);
                        if (match !== conditions[p]) {
                            conditions[p] = match;
                            toggled = 1;
                        }
                    }
                    if (toggled) {
                        c.revert();
                        anyMatch && matches.push(c);
                    }
                }));
                _dispatch("matchMediaRevert");
                matches.forEach((function(c) {
                    return c.onMatch(c);
                }));
                _lastMediaTime = time;
                _dispatch("matchMedia");
            }
        };
        var Context = function() {
            function Context(func, scope) {
                this.selector = scope && selector(scope);
                this.data = [];
                this._r = [];
                this.isReverted = false;
                this.id = _contextID++;
                func && this.add(func);
            }
            var _proto5 = Context.prototype;
            _proto5.add = function add(name, func, scope) {
                if (_isFunction(name)) {
                    scope = func;
                    func = name;
                    name = _isFunction;
                }
                var self = this, f = function f() {
                    var result, prev = _context, prevSelector = self.selector;
                    prev && prev !== self && prev.data.push(self);
                    scope && (self.selector = selector(scope));
                    _context = self;
                    result = func.apply(self, arguments);
                    _isFunction(result) && self._r.push(result);
                    _context = prev;
                    self.selector = prevSelector;
                    self.isReverted = false;
                    return result;
                };
                self.last = f;
                return name === _isFunction ? f(self) : name ? self[name] = f : f;
            };
            _proto5.ignore = function ignore(func) {
                var prev = _context;
                _context = null;
                func(this);
                _context = prev;
            };
            _proto5.getTweens = function getTweens() {
                var a = [];
                this.data.forEach((function(e) {
                    return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
                }));
                return a;
            };
            _proto5.clear = function clear() {
                this._r.length = this.data.length = 0;
            };
            _proto5.kill = function kill(revert, matchMedia) {
                var _this4 = this;
                if (revert) {
                    var tweens = this.getTweens();
                    this.data.forEach((function(t) {
                        if (t.data === "isFlip") {
                            t.revert();
                            t.getChildren(true, true, false).forEach((function(tween) {
                                return tweens.splice(tweens.indexOf(tween), 1);
                            }));
                        }
                    }));
                    tweens.map((function(t) {
                        return {
                            g: t.globalTime(0),
                            t
                        };
                    })).sort((function(a, b) {
                        return b.g - a.g || -1;
                    })).forEach((function(o) {
                        return o.t.revert(revert);
                    }));
                    this.data.forEach((function(e) {
                        return e instanceof Timeline ? e.data !== "nested" && e.kill() : !(e instanceof Tween) && e.revert && e.revert(revert);
                    }));
                    this._r.forEach((function(f) {
                        return f(revert, _this4);
                    }));
                    this.isReverted = true;
                } else this.data.forEach((function(e) {
                    return e.kill && e.kill();
                }));
                this.clear();
                if (matchMedia) {
                    var i = _media.length;
                    while (i--) _media[i].id === this.id && _media.splice(i, 1);
                }
            };
            _proto5.revert = function revert(config) {
                this.kill(config || {});
            };
            return Context;
        }();
        var MatchMedia = function() {
            function MatchMedia(scope) {
                this.contexts = [];
                this.scope = scope;
            }
            var _proto6 = MatchMedia.prototype;
            _proto6.add = function add(conditions, func, scope) {
                _isObject(conditions) || (conditions = {
                    matches: conditions
                });
                var mq, p, active, context = new Context(0, scope || this.scope), cond = context.conditions = {};
                _context && !context.selector && (context.selector = _context.selector);
                this.contexts.push(context);
                func = context.add("onMatch", func);
                context.queries = conditions;
                for (p in conditions) if (p === "all") active = 1; else {
                    mq = _win.matchMedia(conditions[p]);
                    if (mq) {
                        _media.indexOf(context) < 0 && _media.push(context);
                        (cond[p] = mq.matches) && (active = 1);
                        mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
                    }
                }
                active && func(context);
                return this;
            };
            _proto6.revert = function revert(config) {
                this.kill(config || {});
            };
            _proto6.kill = function kill(revert) {
                this.contexts.forEach((function(c) {
                    return c.kill(revert, true);
                }));
            };
            return MatchMedia;
        }();
        var _gsap = {
            registerPlugin: function registerPlugin() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                args.forEach((function(config) {
                    return _createPlugin(config);
                }));
            },
            timeline: function timeline(vars) {
                return new Timeline(vars);
            },
            getTweensOf: function getTweensOf(targets, onlyActive) {
                return _globalTimeline.getTweensOf(targets, onlyActive);
            },
            getProperty: function getProperty(target, property, unit, uncache) {
                _isString(target) && (target = toArray(target)[0]);
                var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
                unit === "native" && (unit = "");
                return !target ? target : !property ? function(property, unit, uncache) {
                    return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
                } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
            },
            quickSetter: function quickSetter(target, property, unit) {
                target = toArray(target);
                if (target.length > 1) {
                    var setters = target.map((function(t) {
                        return gsap.quickSetter(t, property, unit);
                    })), l = setters.length;
                    return function(value) {
                        var i = l;
                        while (i--) setters[i](value);
                    };
                }
                target = target[0] || {};
                var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
                    var p = new Plugin;
                    _quickTween._pt = 0;
                    p.init(target, unit ? value + unit : value, _quickTween, 0, [ target ]);
                    p.render(1, p);
                    _quickTween._pt && _renderPropTweens(1, _quickTween);
                } : cache.set(target, p);
                return Plugin ? setter : function(value) {
                    return setter(target, p, unit ? value + unit : value, cache, 1);
                };
            },
            quickTo: function quickTo(target, property, vars) {
                var _merge2;
                var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, 
                _merge2), vars || {})), func = function func(value, start, startIsRelative) {
                    return tween.resetTo(property, value, start, startIsRelative);
                };
                func.tween = tween;
                return func;
            },
            isTweening: function isTweening(targets) {
                return _globalTimeline.getTweensOf(targets, true).length > 0;
            },
            defaults: function defaults(value) {
                value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
                return _mergeDeep(_defaults, value || {});
            },
            config: function config(value) {
                return _mergeDeep(_config, value || {});
            },
            registerEffect: function registerEffect(_ref3) {
                var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
                (plugins || "").split(",").forEach((function(pluginName) {
                    return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
                }));
                _effects[name] = function(targets, vars, tl) {
                    return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
                };
                if (extendTimeline) Timeline.prototype[name] = function(targets, vars, position) {
                    return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
                };
            },
            registerEase: function registerEase(name, ease) {
                _easeMap[name] = _parseEase(ease);
            },
            parseEase: function parseEase(ease, defaultEase) {
                return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
            },
            getById: function getById(id) {
                return _globalTimeline.getById(id);
            },
            exportRoot: function exportRoot(vars, includeDelayedCalls) {
                if (vars === void 0) vars = {};
                var child, next, tl = new Timeline(vars);
                tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
                _globalTimeline.remove(tl);
                tl._dp = 0;
                tl._time = tl._tTime = _globalTimeline._time;
                child = _globalTimeline._first;
                while (child) {
                    next = child._next;
                    if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) _addToTimeline(tl, child, child._start - child._delay);
                    child = next;
                }
                _addToTimeline(_globalTimeline, tl, 0);
                return tl;
            },
            context: function context(func, scope) {
                return func ? new Context(func, scope) : _context;
            },
            matchMedia: function matchMedia(scope) {
                return new MatchMedia(scope);
            },
            matchMediaRefresh: function matchMediaRefresh() {
                return _media.forEach((function(c) {
                    var found, p, cond = c.conditions;
                    for (p in cond) if (cond[p]) {
                        cond[p] = false;
                        found = 1;
                    }
                    found && c.revert();
                })) || _onMediaChange();
            },
            addEventListener: function addEventListener(type, callback) {
                var a = _listeners[type] || (_listeners[type] = []);
                ~a.indexOf(callback) || a.push(callback);
            },
            removeEventListener: function removeEventListener(type, callback) {
                var a = _listeners[type], i = a && a.indexOf(callback);
                i >= 0 && a.splice(i, 1);
            },
            utils: {
                wrap,
                wrapYoyo,
                distribute,
                random,
                snap,
                normalize,
                getUnit,
                clamp,
                splitColor,
                toArray,
                selector,
                mapRange,
                pipe,
                unitize,
                interpolate: gsap_core_interpolate,
                shuffle
            },
            install: _install,
            effects: _effects,
            ticker: _ticker,
            updateRoot: Timeline.updateRoot,
            plugins: _plugins,
            globalTimeline: _globalTimeline,
            core: {
                PropTween,
                globals: _addGlobal,
                Tween,
                Timeline,
                Animation: gsap_core_Animation,
                getCache: _getCache,
                _removeLinkedListItem,
                reverting: function reverting() {
                    return _reverting;
                },
                context: function context(toAdd) {
                    if (toAdd && _context) {
                        _context.data.push(toAdd);
                        toAdd._ctx = _context;
                    }
                    return _context;
                },
                suppressOverwrites: function suppressOverwrites(value) {
                    return _suppressOverwrites = value;
                }
            }
        };
        _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", (function(name) {
            return _gsap[name] = Tween[name];
        }));
        _ticker.add(Timeline.updateRoot);
        _quickTween = _gsap.to({}, {
            duration: 0
        });
        var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
            var pt = plugin._pt;
            while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) pt = pt._next;
            return pt;
        }, _addModifiers = function _addModifiers(tween, modifiers) {
            var p, i, pt, targets = tween._targets;
            for (p in modifiers) {
                i = targets.length;
                while (i--) {
                    pt = tween._ptLookup[i][p];
                    if (pt && (pt = pt.d)) {
                        if (pt._pt) pt = _getPluginPropTween(pt, p);
                        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
                    }
                }
            }
        }, _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
            return {
                name,
                rawVars: 1,
                init: function init(target, vars, tween) {
                    tween._onInit = function(tween) {
                        var temp, p;
                        if (_isString(vars)) {
                            temp = {};
                            _forEachName(vars, (function(name) {
                                return temp[name] = 1;
                            }));
                            vars = temp;
                        }
                        if (modifier) {
                            temp = {};
                            for (p in vars) temp[p] = modifier(vars[p]);
                            vars = temp;
                        }
                        _addModifiers(tween, vars);
                    };
                }
            };
        };
        var gsap = _gsap.registerPlugin({
            name: "attr",
            init: function init(target, vars, tween, index, targets) {
                var p, pt, v;
                this.tween = tween;
                for (p in vars) {
                    v = target.getAttribute(p) || "";
                    pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
                    pt.op = p;
                    pt.b = v;
                    this._props.push(p);
                }
            },
            render: function render(ratio, data) {
                var pt = data._pt;
                while (pt) {
                    _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
                    pt = pt._next;
                }
            }
        }, {
            name: "endArray",
            init: function init(target, value) {
                var i = value.length;
                while (i--) this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
            }
        }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
        Tween.version = Timeline.version = gsap.version = "3.12.1";
        _coreReady = 1;
        _windowExists() && _wake();
        _easeMap.Power0, _easeMap.Power1, _easeMap.Power2, _easeMap.Power3, _easeMap.Power4, 
        _easeMap.Linear, _easeMap.Quad, _easeMap.Cubic, _easeMap.Quart, _easeMap.Quint, 
        _easeMap.Strong, _easeMap.Elastic, _easeMap.Back, _easeMap.SteppedEase, _easeMap.Bounce, 
        _easeMap.Sine, _easeMap.Expo, _easeMap.Circ;
        /*!
 * CSSPlugin 3.12.1
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var CSSPlugin_win, CSSPlugin_doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, CSSPlugin_reverting, _supports3D, CSSPlugin_windowExists = function _windowExists() {
            return typeof window !== "undefined";
        }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, CSSPlugin_bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        }, _renderCSSProp = function _renderCSSProp(ratio, data) {
            return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
        }, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
            return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
        }, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
            return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
        }, _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
            var value = data.s + data.c * ratio;
            data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
        }, _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
            return data.set(data.t, data.p, ratio ? data.e : data.b, data);
        }, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
            return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
        }, _setterCSSStyle = function _setterCSSStyle(target, property, value) {
            return target.style[property] = value;
        }, _setterCSSProp = function _setterCSSProp(target, property, value) {
            return target.style.setProperty(property, value);
        }, _setterTransform = function _setterTransform(target, property, value) {
            return target._gsap[property] = value;
        }, _setterScale = function _setterScale(target, property, value) {
            return target._gsap.scaleX = target._gsap.scaleY = value;
        }, _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
            var cache = target._gsap;
            cache.scaleX = cache.scaleY = value;
            cache.renderTransform(ratio, cache);
        }, _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
            var cache = target._gsap;
            cache[property] = value;
            cache.renderTransform(ratio, cache);
        }, _transformProp = "transform", _transformOriginProp = _transformProp + "Origin", _saveStyle = function _saveStyle(property, isNotCSS) {
            var _this = this;
            var target = this.target, style = target.style;
            if (property in _transformProps && style) {
                this.tfm = this.tfm || {};
                if (property !== "transform") {
                    property = _propertyAliases[property] || property;
                    ~property.indexOf(",") ? property.split(",").forEach((function(a) {
                        return _this.tfm[a] = _get(target, a);
                    })) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property);
                } else return _propertyAliases.transform.split(",").forEach((function(p) {
                    return _saveStyle.call(_this, p, isNotCSS);
                }));
                if (this.props.indexOf(_transformProp) >= 0) return;
                if (target._gsap.svg) {
                    this.svgo = target.getAttribute("data-svg-origin");
                    this.props.push(_transformOriginProp, isNotCSS, "");
                }
                property = _transformProp;
            }
            (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
        }, _removeIndependentTransforms = function _removeIndependentTransforms(style) {
            if (style.translate) {
                style.removeProperty("translate");
                style.removeProperty("scale");
                style.removeProperty("rotate");
            }
        }, _revertStyle = function _revertStyle() {
            var i, p, props = this.props, target = this.target, style = target.style, cache = target._gsap;
            for (i = 0; i < props.length; i += 3) props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
            if (this.tfm) {
                for (p in this.tfm) cache[p] = this.tfm[p];
                if (cache.svg) {
                    cache.renderTransform();
                    target.setAttribute("data-svg-origin", this.svgo || "");
                }
                i = CSSPlugin_reverting();
                if ((!i || !i.isStart) && !style[_transformProp]) {
                    _removeIndependentTransforms(style);
                    cache.uncache = 1;
                }
            }
        }, _getStyleSaver = function _getStyleSaver(target, properties) {
            var saver = {
                target,
                props: [],
                revert: _revertStyle,
                save: _saveStyle
            };
            target._gsap || gsap.core.getCache(target);
            properties && properties.split(",").forEach((function(p) {
                return saver.save(p);
            }));
            return saver;
        }, _createElement = function _createElement(type, ns) {
            var e = CSSPlugin_doc.createElementNS ? CSSPlugin_doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : CSSPlugin_doc.createElement(type);
            return e.style ? e : CSSPlugin_doc.createElement(type);
        }, _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
            var cs = getComputedStyle(target);
            return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || "";
        }, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
            var e = element || _tempDiv, s = e.style, i = 5;
            if (property in s && !preferPrefix) return property;
            property = property.charAt(0).toUpperCase() + property.substr(1);
            while (i-- && !(_prefixes[i] + property in s)) ;
            return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
        }, _initCore = function _initCore() {
            if (CSSPlugin_windowExists() && window.document) {
                CSSPlugin_win = window;
                CSSPlugin_doc = CSSPlugin_win.document;
                _docElement = CSSPlugin_doc.documentElement;
                _tempDiv = _createElement("div") || {
                    style: {}
                };
                _createElement("div");
                _transformProp = _checkPropPrefix(_transformProp);
                _transformOriginProp = _transformProp + "Origin";
                _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
                _supports3D = !!_checkPropPrefix("perspective");
                CSSPlugin_reverting = gsap.core.reverting;
                _pluginInitted = 1;
            }
        }, _getBBoxHack = function _getBBoxHack(swapIfPossible) {
            var bbox, svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText;
            _docElement.appendChild(svg);
            svg.appendChild(this);
            this.style.display = "block";
            if (swapIfPossible) try {
                bbox = this.getBBox();
                this._gsapBBox = this.getBBox;
                this.getBBox = _getBBoxHack;
            } catch (e) {} else if (this._gsapBBox) bbox = this._gsapBBox();
            if (oldParent) if (oldSibling) oldParent.insertBefore(this, oldSibling); else oldParent.appendChild(this);
            _docElement.removeChild(svg);
            this.style.cssText = oldCSS;
            return bbox;
        }, _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
            var i = attributesArray.length;
            while (i--) if (target.hasAttribute(attributesArray[i])) return target.getAttribute(attributesArray[i]);
        }, _getBBox = function _getBBox(target) {
            var bounds;
            try {
                bounds = target.getBBox();
            } catch (error) {
                bounds = _getBBoxHack.call(target, true);
            }
            bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
            return bounds && !bounds.width && !bounds.x && !bounds.y ? {
                x: +_getAttributeFallbacks(target, [ "x", "cx", "x1" ]) || 0,
                y: +_getAttributeFallbacks(target, [ "y", "cy", "y1" ]) || 0,
                width: 0,
                height: 0
            } : bounds;
        }, _isSVG = function _isSVG(e) {
            return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
        }, _removeProperty = function _removeProperty(target, property) {
            if (property) {
                var style = target.style;
                if (property in _transformProps && property !== _transformOriginProp) property = _transformProp;
                if (style.removeProperty) {
                    if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") property = "-" + property;
                    style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
                } else style.removeAttribute(property);
            }
        }, _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
            var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
            plugin._pt = pt;
            pt.b = beginning;
            pt.e = end;
            plugin._props.push(property);
            return pt;
        }, _nonConvertibleUnits = {
            deg: 1,
            rad: 1,
            turn: 1
        }, _nonStandardLayouts = {
            grid: 1,
            flex: 1
        }, _convertToUnit = function _convertToUnit(target, property, value, unit) {
            var px, parent, cache, isSVG, curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%";
            if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) return curValue;
            curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
            isSVG = target.getCTM && _isSVG(target);
            if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
                px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
                return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
            }
            style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
            parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
            if (isSVG) parent = (target.ownerSVGElement || {}).parentNode;
            if (!parent || parent === CSSPlugin_doc || !parent.appendChild) parent = CSSPlugin_doc.body;
            cache = parent._gsap;
            if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) return _round(curValue / cache.width * amount); else {
                (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
                parent === target && (style.position = "static");
                parent.appendChild(_tempDiv);
                px = _tempDiv[measureProperty];
                parent.removeChild(_tempDiv);
                style.position = "absolute";
                if (horizontal && toPercent) {
                    cache = _getCache(parent);
                    cache.time = _ticker.time;
                    cache.width = parent[measureProperty];
                }
            }
            return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
        }, _get = function _get(target, property, unit, uncache) {
            var value;
            _pluginInitted || _initCore();
            if (property in _propertyAliases && property !== "transform") {
                property = _propertyAliases[property];
                if (~property.indexOf(",")) property = property.split(",")[0];
            }
            if (_transformProps[property] && property !== "transform") {
                value = _parseTransform(target, uncache);
                value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
            } else {
                value = target.style[property];
                if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
            }
            return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
        }, _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
            if (!start || start === "none") {
                var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
                if (s && s !== start) {
                    prop = p;
                    start = s;
                } else if (prop === "borderColor") start = _getComputedProperty(target, "borderTopColor");
            }
            var a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues, pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0;
            pt.b = start;
            pt.e = end;
            start += "";
            end += "";
            if (end === "auto") {
                target.style[prop] = end;
                end = _getComputedProperty(target, prop) || end;
                target.style[prop] = start;
            }
            a = [ start, end ];
            _colorStringFilter(a);
            start = a[0];
            end = a[1];
            startValues = start.match(_numWithUnitExp) || [];
            endValues = end.match(_numWithUnitExp) || [];
            if (endValues.length) {
                while (result = _numWithUnitExp.exec(end)) {
                    endValue = result[0];
                    chunk = end.substring(index, result.index);
                    if (color) color = (color + 1) % 5; else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") color = 1;
                    if (endValue !== (startValue = startValues[matchIndex++] || "")) {
                        startNum = parseFloat(startValue) || 0;
                        startUnit = startValue.substr((startNum + "").length);
                        endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
                        endNum = parseFloat(endValue);
                        endUnit = endValue.substr((endNum + "").length);
                        index = _numWithUnitExp.lastIndex - endUnit.length;
                        if (!endUnit) {
                            endUnit = endUnit || _config.units[prop] || startUnit;
                            if (index === end.length) {
                                end += endUnit;
                                pt.e += endUnit;
                            }
                        }
                        if (startUnit !== endUnit) startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
                        pt._pt = {
                            _next: pt._pt,
                            p: chunk || matchIndex === 1 ? chunk : ",",
                            s: startNum,
                            c: endNum - startNum,
                            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
                        };
                    }
                }
                pt.c = index < end.length ? end.substring(index, end.length) : "";
            } else pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
            _relExp.test(end) && (pt.e = 0);
            this._pt = pt;
            return pt;
        }, _keywordToPercent = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        }, _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
            var split = value.split(" "), x = split[0], y = split[1] || "50%";
            if (x === "top" || x === "bottom" || y === "left" || y === "right") {
                value = x;
                x = y;
                y = value;
            }
            split[0] = _keywordToPercent[x] || x;
            split[1] = _keywordToPercent[y] || y;
            return split.join(" ");
        }, _renderClearProps = function _renderClearProps(ratio, data) {
            if (data.tween && data.tween._time === data.tween._dur) {
                var prop, clearTransforms, i, target = data.t, style = target.style, props = data.u, cache = target._gsap;
                if (props === "all" || props === true) {
                    style.cssText = "";
                    clearTransforms = 1;
                } else {
                    props = props.split(",");
                    i = props.length;
                    while (--i > -1) {
                        prop = props[i];
                        if (_transformProps[prop]) {
                            clearTransforms = 1;
                            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
                        }
                        _removeProperty(target, prop);
                    }
                }
                if (clearTransforms) {
                    _removeProperty(target, _transformProp);
                    if (cache) {
                        cache.svg && target.removeAttribute("transform");
                        _parseTransform(target, 1);
                        cache.uncache = 1;
                        _removeIndependentTransforms(style);
                    }
                }
            }
        }, _specialProps = {
            clearProps: function clearProps(plugin, target, property, endValue, tween) {
                if (tween.data !== "isFromStart") {
                    var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
                    pt.u = endValue;
                    pt.pr = -10;
                    pt.tween = tween;
                    plugin._props.push(property);
                    return 1;
                }
            }
        }, _identity2DMatrix = [ 1, 0, 0, 1, 0, 0 ], _rotationalProperties = {}, _isNullTransform = function _isNullTransform(value) {
            return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
        }, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
            var matrixString = _getComputedProperty(target, _transformProp);
            return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
        }, _getMatrix = function _getMatrix(target, force2D) {
            var parent, nextSibling, temp, addedToDOM, cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target);
            if (cache.svg && target.getAttribute("transform")) {
                temp = target.transform.baseVal.consolidate().matrix;
                matrix = [ temp.a, temp.b, temp.c, temp.d, temp.e, temp.f ];
                return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
            } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
                temp = style.display;
                style.display = "block";
                parent = target.parentNode;
                if (!parent || !target.offsetParent) {
                    addedToDOM = 1;
                    nextSibling = target.nextElementSibling;
                    _docElement.appendChild(target);
                }
                matrix = _getComputedTransformMatrixAsArray(target);
                temp ? style.display = temp : _removeProperty(target, "display");
                if (addedToDOM) nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
            }
            return force2D && matrix.length > 6 ? [ matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13] ] : matrix;
        }, _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
            var bounds, determinant, x, y, cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0;
            if (!originIsAbsolute) {
                bounds = _getBBox(target);
                xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
                yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
            } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
                x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
                y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
                xOrigin = x;
                yOrigin = y;
            }
            if (smooth || smooth !== false && cache.smooth) {
                tx = xOrigin - xOriginOld;
                ty = yOrigin - yOriginOld;
                cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
                cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
            } else cache.xOffset = cache.yOffset = 0;
            cache.xOrigin = xOrigin;
            cache.yOrigin = yOrigin;
            cache.smooth = !!smooth;
            cache.origin = origin;
            cache.originIsAbsolute = !!originIsAbsolute;
            target.style[_transformOriginProp] = "0px 0px";
            if (pluginToAddPropTweensTo) {
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
            }
            target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
        }, _parseTransform = function _parseTransform(target, uncache) {
            var cache = target._gsap || new GSCache(target);
            if ("x" in cache && !uncache && !cache.uncache) return cache;
            var x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32, style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0";
            x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
            scaleX = scaleY = 1;
            cache.svg = !!(target.getCTM && _isSVG(target));
            if (cs.translate) {
                if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
                style.scale = style.rotate = style.translate = "none";
            }
            matrix = _getMatrix(target, cache.svg);
            if (cache.svg) {
                if (cache.uncache) {
                    t2 = target.getBBox();
                    origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
                    t1 = "";
                } else t1 = !uncache && target.getAttribute("data-svg-origin");
                _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
            }
            xOrigin = cache.xOrigin || 0;
            yOrigin = cache.yOrigin || 0;
            if (matrix !== _identity2DMatrix) {
                a = matrix[0];
                b = matrix[1];
                c = matrix[2];
                d = matrix[3];
                x = a12 = matrix[4];
                y = a22 = matrix[5];
                if (matrix.length === 6) {
                    scaleX = Math.sqrt(a * a + b * b);
                    scaleY = Math.sqrt(d * d + c * c);
                    rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
                    skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
                    skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
                    if (cache.svg) {
                        x -= xOrigin - (xOrigin * a + yOrigin * c);
                        y -= yOrigin - (xOrigin * b + yOrigin * d);
                    }
                } else {
                    a32 = matrix[6];
                    a42 = matrix[7];
                    a13 = matrix[8];
                    a23 = matrix[9];
                    a33 = matrix[10];
                    a43 = matrix[11];
                    x = matrix[12];
                    y = matrix[13];
                    z = matrix[14];
                    angle = _atan2(a32, a33);
                    rotationX = angle * _RAD2DEG;
                    if (angle) {
                        cos = Math.cos(-angle);
                        sin = Math.sin(-angle);
                        t1 = a12 * cos + a13 * sin;
                        t2 = a22 * cos + a23 * sin;
                        t3 = a32 * cos + a33 * sin;
                        a13 = a12 * -sin + a13 * cos;
                        a23 = a22 * -sin + a23 * cos;
                        a33 = a32 * -sin + a33 * cos;
                        a43 = a42 * -sin + a43 * cos;
                        a12 = t1;
                        a22 = t2;
                        a32 = t3;
                    }
                    angle = _atan2(-c, a33);
                    rotationY = angle * _RAD2DEG;
                    if (angle) {
                        cos = Math.cos(-angle);
                        sin = Math.sin(-angle);
                        t1 = a * cos - a13 * sin;
                        t2 = b * cos - a23 * sin;
                        t3 = c * cos - a33 * sin;
                        a43 = d * sin + a43 * cos;
                        a = t1;
                        b = t2;
                        c = t3;
                    }
                    angle = _atan2(b, a);
                    rotation = angle * _RAD2DEG;
                    if (angle) {
                        cos = Math.cos(angle);
                        sin = Math.sin(angle);
                        t1 = a * cos + b * sin;
                        t2 = a12 * cos + a22 * sin;
                        b = b * cos - a * sin;
                        a22 = a22 * cos - a12 * sin;
                        a = t1;
                        a12 = t2;
                    }
                    if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
                        rotationX = rotation = 0;
                        rotationY = 180 - rotationY;
                    }
                    scaleX = _round(Math.sqrt(a * a + b * b + c * c));
                    scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
                    angle = _atan2(a12, a22);
                    skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
                    perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
                }
                if (cache.svg) {
                    t1 = target.getAttribute("transform");
                    cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
                    t1 && target.setAttribute("transform", t1);
                }
            }
            if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) if (invertedScaleX) {
                scaleX *= -1;
                skewX += rotation <= 0 ? 180 : -180;
                rotation += rotation <= 0 ? 180 : -180;
            } else {
                scaleY *= -1;
                skewX += skewX <= 0 ? 180 : -180;
            }
            uncache = uncache || cache.uncache;
            cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
            cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
            cache.z = z + px;
            cache.scaleX = _round(scaleX);
            cache.scaleY = _round(scaleY);
            cache.rotation = _round(rotation) + deg;
            cache.rotationX = _round(rotationX) + deg;
            cache.rotationY = _round(rotationY) + deg;
            cache.skewX = skewX + deg;
            cache.skewY = skewY + deg;
            cache.transformPerspective = perspective + px;
            if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) style[_transformOriginProp] = _firstTwoOnly(origin);
            cache.xOffset = cache.yOffset = 0;
            cache.force3D = _config.force3D;
            cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
            cache.uncache = 0;
            return cache;
        }, _firstTwoOnly = function _firstTwoOnly(value) {
            return (value = value.split(" "))[0] + " " + value[1];
        }, _addPxTranslate = function _addPxTranslate(target, start, value) {
            var unit = getUnit(start);
            return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
        }, _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
            cache.z = "0px";
            cache.rotationY = cache.rotationX = "0deg";
            cache.force3D = 0;
            _renderCSSTransforms(ratio, cache);
        }, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
            var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
            if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
                var cos, angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle);
                angle = parseFloat(rotationX) * _DEG2RAD;
                cos = Math.cos(angle);
                x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
                y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
                z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
            }
            if (transformPerspective !== _zeroPx) transforms += "perspective(" + transformPerspective + _endParenthesis;
            if (xPercent || yPercent) transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
            if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
            if (rotation !== _zeroDeg) transforms += "rotate(" + rotation + _endParenthesis;
            if (rotationY !== _zeroDeg) transforms += "rotateY(" + rotationY + _endParenthesis;
            if (rotationX !== _zeroDeg) transforms += "rotateX(" + rotationX + _endParenthesis;
            if (skewX !== _zeroDeg || skewY !== _zeroDeg) transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
            if (scaleX !== 1 || scaleY !== 1) transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
            target.style[_transformProp] = transforms || "translate(0, 0)";
        }, _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
            var a11, a21, a12, a22, temp, _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y);
            rotation = parseFloat(rotation);
            skewX = parseFloat(skewX);
            skewY = parseFloat(skewY);
            if (skewY) {
                skewY = parseFloat(skewY);
                skewX += skewY;
                rotation += skewY;
            }
            if (rotation || skewX) {
                rotation *= _DEG2RAD;
                skewX *= _DEG2RAD;
                a11 = Math.cos(rotation) * scaleX;
                a21 = Math.sin(rotation) * scaleX;
                a12 = Math.sin(rotation - skewX) * -scaleY;
                a22 = Math.cos(rotation - skewX) * scaleY;
                if (skewX) {
                    skewY *= _DEG2RAD;
                    temp = Math.tan(skewX - skewY);
                    temp = Math.sqrt(1 + temp * temp);
                    a12 *= temp;
                    a22 *= temp;
                    if (skewY) {
                        temp = Math.tan(skewY);
                        temp = Math.sqrt(1 + temp * temp);
                        a11 *= temp;
                        a21 *= temp;
                    }
                }
                a11 = _round(a11);
                a21 = _round(a21);
                a12 = _round(a12);
                a22 = _round(a22);
            } else {
                a11 = scaleX;
                a22 = scaleY;
                a21 = a12 = 0;
            }
            if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
                tx = _convertToUnit(target, "x", x, "px");
                ty = _convertToUnit(target, "y", y, "px");
            }
            if (xOrigin || yOrigin || xOffset || yOffset) {
                tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
                ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
            }
            if (xPercent || yPercent) {
                temp = target.getBBox();
                tx = _round(tx + xPercent / 100 * temp.width);
                ty = _round(ty + yPercent / 100 * temp.height);
            }
            temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
            target.setAttribute("transform", temp);
            forceCSS && (target.style[_transformProp] = temp);
        }, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
            var direction, pt, cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg";
            if (isString) {
                direction = endValue.split("_")[1];
                if (direction === "short") {
                    change %= cap;
                    if (change !== change % (cap / 2)) change += change < 0 ? cap : -cap;
                }
                if (direction === "cw" && change < 0) change = (change + cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap; else if (direction === "ccw" && change > 0) change = (change - cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;
            }
            plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
            pt.e = finalValue;
            pt.u = "deg";
            plugin._props.push(property);
            return pt;
        }, _assign = function _assign(target, source) {
            for (var p in source) target[p] = source[p];
            return target;
        }, _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
            var endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit, startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style;
            if (startCache.svg) {
                startValue = target.getAttribute("transform");
                target.setAttribute("transform", "");
                style[_transformProp] = transforms;
                endCache = _parseTransform(target, 1);
                _removeProperty(target, _transformProp);
                target.setAttribute("transform", startValue);
            } else {
                startValue = getComputedStyle(target)[_transformProp];
                style[_transformProp] = transforms;
                endCache = _parseTransform(target, 1);
                style[_transformProp] = startValue;
            }
            for (p in _transformProps) {
                startValue = startCache[p];
                endValue = endCache[p];
                if (startValue !== endValue && exclude.indexOf(p) < 0) {
                    startUnit = getUnit(startValue);
                    endUnit = getUnit(endValue);
                    startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
                    endNum = parseFloat(endValue);
                    plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
                    plugin._pt.u = endUnit || 0;
                    plugin._props.push(p);
                }
            }
            _assign(endCache, startCache);
        };
        _forEachName("padding,margin,Width,Radius", (function(name, index) {
            var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [ t, r, b, l ] : [ t + l, t + r, b + r, b + l ]).map((function(side) {
                return index < 2 ? name + side : "border" + side + name;
            }));
            _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
                var a, vars;
                if (arguments.length < 4) {
                    a = props.map((function(prop) {
                        return _get(plugin, prop, property);
                    }));
                    vars = a.join(" ");
                    return vars.split(a[0]).length === 5 ? a[0] : vars;
                }
                a = (endValue + "").split(" ");
                vars = {};
                props.forEach((function(prop, i) {
                    return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
                }));
                plugin.init(target, vars, tween);
            };
        }));
        var CSSPlugin = {
            name: "css",
            register: _initCore,
            targetTest: function targetTest(target) {
                return target.style && target.nodeType;
            },
            init: function init(target, vars, tween, index, targets) {
                var startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps, props = this._props, style = target.style, startAt = tween.vars.startAt;
                _pluginInitted || _initCore();
                this.styles = this.styles || _getStyleSaver(target);
                inlineProps = this.styles.props;
                this.tween = tween;
                for (p in vars) {
                    if (p === "autoRound") continue;
                    endValue = vars[p];
                    if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) continue;
                    type = typeof endValue;
                    specialProp = _specialProps[p];
                    if (type === "function") {
                        endValue = endValue.call(tween, index, target, targets);
                        type = typeof endValue;
                    }
                    if (type === "string" && ~endValue.indexOf("random(")) endValue = _replaceRandom(endValue);
                    if (specialProp) specialProp(this, target, p, endValue, tween) && (hasPriority = 1); else if (p.substr(0, 2) === "--") {
                        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
                        endValue += "";
                        _colorExp.lastIndex = 0;
                        if (!_colorExp.test(startValue)) {
                            startUnit = getUnit(startValue);
                            endUnit = getUnit(endValue);
                        }
                        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
                        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
                        props.push(p);
                        inlineProps.push(p, 0, style[p]);
                    } else if (type !== "undefined") {
                        if (startAt && p in startAt) {
                            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
                            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
                            getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
                            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
                        } else startValue = _get(target, p);
                        startNum = parseFloat(startValue);
                        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
                        relative && (endValue = endValue.substr(2));
                        endNum = parseFloat(endValue);
                        if (p in _propertyAliases) {
                            if (p === "autoAlpha") {
                                if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) startNum = 0;
                                inlineProps.push("visibility", 0, style.visibility);
                                _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
                            }
                            if (p !== "scale" && p !== "transform") {
                                p = _propertyAliases[p];
                                ~p.indexOf(",") && (p = p.split(",")[0]);
                            }
                        }
                        isTransformRelated = p in _transformProps;
                        if (isTransformRelated) {
                            this.styles.save(p);
                            if (!transformPropTween) {
                                cache = target._gsap;
                                cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                                smooth = vars.smoothOrigin !== false && cache.smooth;
                                transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                                transformPropTween.dep = 1;
                            }
                            if (p === "scale") {
                                this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                                this._pt.u = 0;
                                props.push("scaleY", p);
                                p += "X";
                            } else if (p === "transformOrigin") {
                                inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                                endValue = _convertKeywordsToPercentages(endValue);
                                if (cache.svg) _applySVGOrigin(target, endValue, 0, smooth, 0, this); else {
                                    endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                                    endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                                    _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                                }
                                continue;
                            } else if (p === "svgOrigin") {
                                _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                                continue;
                            } else if (p in _rotationalProperties) {
                                _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
                                continue;
                            } else if (p === "smoothOrigin") {
                                _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                                continue;
                            } else if (p === "force3D") {
                                cache[p] = endValue;
                                continue;
                            } else if (p === "transform") {
                                _addRawTransformPTs(this, endValue, target);
                                continue;
                            }
                        } else if (!(p in style)) p = _checkPropPrefix(p) || p;
                        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
                            startUnit = (startValue + "").substr((startNum + "").length);
                            endNum || (endNum = 0);
                            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
                            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
                            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                            this._pt.u = endUnit || 0;
                            if (startUnit !== endUnit && endUnit !== "%") {
                                this._pt.b = startValue;
                                this._pt.r = _renderCSSPropWithBeginning;
                            }
                        } else if (!(p in style)) {
                            if (p in target) this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets); else if (p !== "parseTransform") {
                                _missingPlugin(p, endValue);
                                continue;
                            }
                        } else _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
                        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
                        props.push(p);
                    }
                }
                hasPriority && _sortPropTweensByPriority(this);
            },
            render: function render(ratio, data) {
                if (data.tween._time || !CSSPlugin_reverting()) {
                    var pt = data._pt;
                    while (pt) {
                        pt.r(ratio, pt.d);
                        pt = pt._next;
                    }
                } else data.styles.revert();
            },
            get: _get,
            aliases: _propertyAliases,
            getSetter: function getSetter(target, property, plugin) {
                var p = _propertyAliases[property];
                p && p.indexOf(",") < 0 && (property = p);
                return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
            },
            core: {
                _removeProperty,
                _getMatrix
            }
        };
        gsap.utils.checkPrefix = _checkPropPrefix;
        gsap.core.getStyleSaver = _getStyleSaver;
        (function(positionAndScale, rotation, others, aliases) {
            var all = _forEachName(positionAndScale + "," + rotation + "," + others, (function(name) {
                _transformProps[name] = 1;
            }));
            _forEachName(rotation, (function(name) {
                _config.units[name] = "deg";
                _rotationalProperties[name] = 1;
            }));
            _propertyAliases[all[13]] = positionAndScale + "," + rotation;
            _forEachName(aliases, (function(name) {
                var split = name.split(":");
                _propertyAliases[split[1]] = all[split[0]];
            }));
        })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
        _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(name) {
            _config.units[name] = "px";
        }));
        gsap.registerPlugin(CSSPlugin);
        var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
        gsapWithCSS.core.Tween;
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
        }
        /*!
 * Observer 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/        var Observer_gsap, Observer_coreInitted, Observer_win, Observer_doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, Observer_root, _normalizer, _eventTypes, Observer_context, _getGSAP = function _getGSAP() {
            return Observer_gsap || typeof window !== "undefined" && (Observer_gsap = window.gsap) && Observer_gsap.registerPlugin && Observer_gsap;
        }, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime = Date.now, _bridge = function _bridge(name, value) {
            return value;
        }, _integrate = function _integrate() {
            var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
            scrollers.push.apply(scrollers, _scrollers);
            proxies.push.apply(proxies, _proxies);
            _scrollers = scrollers;
            _proxies = proxies;
            _bridge = function _bridge(name, value) {
                return data[name](value);
            };
        }, _getProxyProp = function _getProxyProp(element, property) {
            return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
        }, _isViewport = function _isViewport(el) {
            return !!~Observer_root.indexOf(el);
        }, _addListener = function _addListener(element, type, func, nonPassive, capture) {
            return element.addEventListener(type, func, {
                passive: !nonPassive,
                capture: !!capture
            });
        }, _removeListener = function _removeListener(element, type, func, capture) {
            return element.removeEventListener(type, func, !!capture);
        }, _scrollLeft = "scrollLeft", _scrollTop = "scrollTop", _onScroll = function _onScroll() {
            return _normalizer && _normalizer.isPressed || _scrollers.cache++;
        }, _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
            var cachingFunc = function cachingFunc(value) {
                if (value || value === 0) {
                    _startup && (Observer_win.history.scrollRestoration = "manual");
                    var isNormalizing = _normalizer && _normalizer.isPressed;
                    value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
                    f(value);
                    cachingFunc.cacheID = _scrollers.cache;
                    isNormalizing && _bridge("ss", value);
                } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
                    cachingFunc.cacheID = _scrollers.cache;
                    cachingFunc.v = f();
                }
                return cachingFunc.v + cachingFunc.offset;
            };
            cachingFunc.offset = 0;
            return f && cachingFunc;
        }, _horizontal = {
            s: _scrollLeft,
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: _scrollCacheFunc((function(value) {
                return arguments.length ? Observer_win.scrollTo(value, _vertical.sc()) : Observer_win.pageXOffset || Observer_doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
            }))
        }, _vertical = {
            s: _scrollTop,
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: _horizontal,
            sc: _scrollCacheFunc((function(value) {
                return arguments.length ? Observer_win.scrollTo(_horizontal.sc(), value) : Observer_win.pageYOffset || Observer_doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
            }))
        }, Observer_getTarget = function _getTarget(t, self) {
            return (self && self._ctx && self._ctx.selector || Observer_gsap.utils.toArray)(t)[0] || (typeof t === "string" && Observer_gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
        }, _getScrollFunc = function _getScrollFunc(element, _ref) {
            var s = _ref.s, sc = _ref.sc;
            _isViewport(element) && (element = Observer_doc.scrollingElement || _docEl);
            var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;
            !~i && (i = _scrollers.push(element) - 1);
            _scrollers[i + offset] || element.addEventListener("scroll", _onScroll);
            var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc((function(value) {
                return arguments.length ? element[s] = value : element[s];
            }))));
            func.target = element;
            prev || (func.smooth = Observer_gsap.getProperty(element, "scrollBehavior") === "smooth");
            return func;
        }, _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
            var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update(value, force) {
                var t = _getTime();
                if (force || t - t1 > min) {
                    v2 = v1;
                    v1 = value;
                    t2 = t1;
                    t1 = t;
                } else if (useDelta) v1 += value; else v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
            }, reset = function reset() {
                v2 = v1 = useDelta ? 0 : v1;
                t2 = t1 = 0;
            }, getVelocity = function getVelocity(latestValue) {
                var tOld = t2, vOld = v2, t = _getTime();
                (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
                return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;
            };
            return {
                update,
                reset,
                getVelocity
            };
        }, _getEvent = function _getEvent(e, preventDefault) {
            preventDefault && !e._gsapAllow && e.preventDefault();
            return e.changedTouches ? e.changedTouches[0] : e;
        }, _getAbsoluteMax = function _getAbsoluteMax(a) {
            var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);
            return Math.abs(max) >= Math.abs(min) ? max : min;
        }, _setScrollTrigger = function _setScrollTrigger() {
            ScrollTrigger = Observer_gsap.core.globals().ScrollTrigger;
            ScrollTrigger && ScrollTrigger.core && _integrate();
        }, Observer_initCore = function _initCore(core) {
            Observer_gsap = core || _getGSAP();
            if (Observer_gsap && typeof document !== "undefined" && document.body) {
                Observer_win = window;
                Observer_doc = document;
                _docEl = Observer_doc.documentElement;
                _body = Observer_doc.body;
                Observer_root = [ Observer_win, Observer_doc, _docEl, _body ];
                Observer_gsap.utils.clamp;
                Observer_context = Observer_gsap.core.context || function() {};
                _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
                _isTouch = Observer_Observer.isTouch = Observer_win.matchMedia && Observer_win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Observer_win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
                _eventTypes = Observer_Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
                setTimeout((function() {
                    return _startup = 0;
                }), 500);
                _setScrollTrigger();
                Observer_coreInitted = 1;
            }
            return Observer_coreInitted;
        };
        _horizontal.op = _vertical;
        _scrollers.cache = 0;
        var Observer_Observer = function() {
            function Observer(vars) {
                this.init(vars);
            }
            var _proto = Observer.prototype;
            _proto.init = function init(vars) {
                Observer_coreInitted || Observer_initCore(Observer_gsap) || console.warn("Please gsap.registerPlugin(Observer)");
                ScrollTrigger || _setScrollTrigger();
                var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
                this.target = target = Observer_getTarget(target) || _docEl;
                this.vars = vars;
                ignore && (ignore = Observer_gsap.utils.toArray(ignore));
                tolerance = tolerance || 1e-9;
                dragMinimum = dragMinimum || 0;
                wheelSpeed = wheelSpeed || 1;
                scrollSpeed = scrollSpeed || 1;
                type = type || "wheel,touch,pointer";
                debounce = debounce !== false;
                lineHeight || (lineHeight = parseFloat(Observer_win.getComputedStyle(_body).lineHeight) || 22);
                var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || Observer_doc, deltaX = [ 0, 0, 0 ], deltaY = [ 0, 0, 0 ], onClickTime = 0, clickCapture = function clickCapture() {
                    return onClickTime = _getTime();
                }, _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
                    return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
                }, onStopFunc = function onStopFunc() {
                    self._vx.reset();
                    self._vy.reset();
                    onStopDelayedCall.pause();
                    onStop && onStop(self);
                }, update = function update() {
                    var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
                    onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);
                    if (changedX) {
                        onRight && self.deltaX > 0 && onRight(self);
                        onLeft && self.deltaX < 0 && onLeft(self);
                        onChangeX && onChangeX(self);
                        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
                        prevDeltaX = self.deltaX;
                        deltaX[0] = deltaX[1] = deltaX[2] = 0;
                    }
                    if (changedY) {
                        onDown && self.deltaY > 0 && onDown(self);
                        onUp && self.deltaY < 0 && onUp(self);
                        onChangeY && onChangeY(self);
                        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
                        prevDeltaY = self.deltaY;
                        deltaY[0] = deltaY[1] = deltaY[2] = 0;
                    }
                    if (moved || dragged) {
                        onMove && onMove(self);
                        if (dragged) {
                            onDrag(self);
                            dragged = false;
                        }
                        moved = false;
                    }
                    locked && !(locked = false) && onLockAxis && onLockAxis(self);
                    if (wheeled) {
                        onWheel(self);
                        wheeled = false;
                    }
                    id = 0;
                }, onDelta = function onDelta(x, y, index) {
                    deltaX[index] += x;
                    deltaY[index] += y;
                    self._vx.update(x);
                    self._vy.update(y);
                    debounce ? id || (id = requestAnimationFrame(update)) : update();
                }, onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
                    if (lockAxis && !axis) {
                        self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
                        locked = true;
                    }
                    if (axis !== "y") {
                        deltaX[2] += x;
                        self._vx.update(x, true);
                    }
                    if (axis !== "x") {
                        deltaY[2] += y;
                        self._vy.update(y, true);
                    }
                    debounce ? id || (id = requestAnimationFrame(update)) : update();
                }, _onDrag = function _onDrag(e) {
                    if (_ignoreCheck(e, 1)) return;
                    e = _getEvent(e, preventDefault);
                    var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;
                    self.x = x;
                    self.y = y;
                    if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
                        onDrag && (dragged = true);
                        isDragging || (self.isDragging = true);
                        onTouchOrPointerDelta(dx, dy);
                        isDragging || onDragStart && onDragStart(self);
                    }
                }, _onPress = self.onPress = function(e) {
                    if (_ignoreCheck(e, 1) || e && e.button) return;
                    self.axis = axis = null;
                    onStopDelayedCall.pause();
                    self.isPressed = true;
                    e = _getEvent(e);
                    prevDeltaX = prevDeltaY = 0;
                    self.startX = self.x = e.clientX;
                    self.startY = self.y = e.clientY;
                    self._vx.reset();
                    self._vy.reset();
                    _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);
                    self.deltaX = self.deltaY = 0;
                    onPress && onPress(self);
                }, _onRelease = self.onRelease = function(e) {
                    if (_ignoreCheck(e, 1)) return;
                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
                    var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), eventData = _getEvent(e);
                    if (!wasDragging && isTrackingDrag) {
                        self._vx.reset();
                        self._vy.reset();
                        if (preventDefault && allowClicks) Observer_gsap.delayedCall(.08, (function() {
                            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) if (e.target.click) e.target.click(); else if (ownerDoc.createEvent) {
                                var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                                syntheticEvent.initMouseEvent("click", true, true, Observer_win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                                e.target.dispatchEvent(syntheticEvent);
                            }
                        }));
                    }
                    self.isDragging = self.isGesturing = self.isPressed = false;
                    onStop && !isNormalizer && onStopDelayedCall.restart(true);
                    onDragEnd && wasDragging && onDragEnd(self);
                    onRelease && onRelease(self, wasDragging);
                }, _onGestureStart = function _onGestureStart(e) {
                    return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
                }, _onGestureEnd = function _onGestureEnd() {
                    return (self.isGesturing = false) || onGestureEnd(self);
                }, onScroll = function onScroll(e) {
                    if (_ignoreCheck(e)) return;
                    var x = scrollFuncX(), y = scrollFuncY();
                    onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
                    scrollX = x;
                    scrollY = y;
                    onStop && onStopDelayedCall.restart(true);
                }, _onWheel = function _onWheel(e) {
                    if (_ignoreCheck(e)) return;
                    e = _getEvent(e, preventDefault);
                    onWheel && (wheeled = true);
                    var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? Observer_win.innerHeight : 1) * wheelSpeed;
                    onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
                    onStop && !isNormalizer && onStopDelayedCall.restart(true);
                }, _onMove = function _onMove(e) {
                    if (_ignoreCheck(e)) return;
                    var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;
                    self.x = x;
                    self.y = y;
                    moved = true;
                    (dx || dy) && onTouchOrPointerDelta(dx, dy);
                }, _onHover = function _onHover(e) {
                    self.event = e;
                    onHover(self);
                }, _onHoverEnd = function _onHoverEnd(e) {
                    self.event = e;
                    onHoverEnd(self);
                }, _onClick = function _onClick(e) {
                    return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
                };
                onStopDelayedCall = self._dc = Observer_gsap.delayedCall(onStopDelay || .25, onStopFunc).pause();
                self.deltaX = self.deltaY = 0;
                self._vx = _getVelocityProp(0, 50, true);
                self._vy = _getVelocityProp(0, 50, true);
                self.scrollX = scrollFuncX;
                self.scrollY = scrollFuncY;
                self.isDragging = self.isGesturing = self.isPressed = false;
                Observer_context(this);
                self.enable = function(e) {
                    if (!self.isEnabled) {
                        _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
                        type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
                        type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);
                        if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
                            _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);
                            _addListener(ownerDoc, _eventTypes[2], _onRelease);
                            _addListener(ownerDoc, _eventTypes[3], _onRelease);
                            allowClicks && _addListener(target, "click", clickCapture, false, true);
                            onClick && _addListener(target, "click", _onClick);
                            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
                            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
                            onHover && _addListener(target, _pointerType + "enter", _onHover);
                            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
                            onMove && _addListener(target, _pointerType + "move", _onMove);
                        }
                        self.isEnabled = true;
                        e && e.type && _onPress(e);
                        onEnable && onEnable(self);
                    }
                    return self;
                };
                self.disable = function() {
                    if (self.isEnabled) {
                        _observers.filter((function(o) {
                            return o !== self && _isViewport(o.target);
                        })).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
                        if (self.isPressed) {
                            self._vx.reset();
                            self._vy.reset();
                            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
                        }
                        _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
                        _removeListener(target, "wheel", _onWheel, capture);
                        _removeListener(target, _eventTypes[0], _onPress, capture);
                        _removeListener(ownerDoc, _eventTypes[2], _onRelease);
                        _removeListener(ownerDoc, _eventTypes[3], _onRelease);
                        _removeListener(target, "click", clickCapture, true);
                        _removeListener(target, "click", _onClick);
                        _removeListener(ownerDoc, "gesturestart", _onGestureStart);
                        _removeListener(ownerDoc, "gestureend", _onGestureEnd);
                        _removeListener(target, _pointerType + "enter", _onHover);
                        _removeListener(target, _pointerType + "leave", _onHoverEnd);
                        _removeListener(target, _pointerType + "move", _onMove);
                        self.isEnabled = self.isPressed = self.isDragging = false;
                        onDisable && onDisable(self);
                    }
                };
                self.kill = self.revert = function() {
                    self.disable();
                    var i = _observers.indexOf(self);
                    i >= 0 && _observers.splice(i, 1);
                    _normalizer === self && (_normalizer = 0);
                };
                _observers.push(self);
                isNormalizer && _isViewport(target) && (_normalizer = self);
                self.enable(event);
            };
            _createClass(Observer, [ {
                key: "velocityX",
                get: function get() {
                    return this._vx.getVelocity();
                }
            }, {
                key: "velocityY",
                get: function get() {
                    return this._vy.getVelocity();
                }
            } ]);
            return Observer;
        }();
        Observer_Observer.version = "3.12.1";
        Observer_Observer.create = function(vars) {
            return new Observer_Observer(vars);
        };
        Observer_Observer.register = Observer_initCore;
        Observer_Observer.getAll = function() {
            return _observers.slice();
        };
        Observer_Observer.getById = function(id) {
            return _observers.filter((function(o) {
                return o.vars.id === id;
            }))[0];
        };
        _getGSAP() && Observer_gsap.registerPlugin(Observer_Observer);
        /*!
 * ScrollTrigger 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var ScrollTrigger_gsap, ScrollTrigger_coreInitted, ScrollTrigger_win, ScrollTrigger_doc, ScrollTrigger_docEl, ScrollTrigger_body, ScrollTrigger_root, _resizeDelay, _toArray, ScrollTrigger_clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, ScrollTrigger_transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, ScrollTrigger_suppressOverwrites, _ignoreResize, ScrollTrigger_normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, ScrollTrigger_context, _scrollRestoration, _limitCallbacks, _rafID, _refreshingAll, _queueRefreshID, _primary, ScrollTrigger_startup = 1, ScrollTrigger_getTime = Date.now, _time1 = ScrollTrigger_getTime(), _lastScrollTime = 0, _enabled = 0, _parseClamp = function _parseClamp(value, type, self) {
            var clamp = ScrollTrigger_isString(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
            self["_" + type + "Clamp"] = clamp;
            return clamp ? value.substr(6, value.length - 7) : value;
        }, _keepClamp = function _keepClamp(value, clamp) {
            return clamp && (!ScrollTrigger_isString(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
        }, _rafBugFix = function _rafBugFix() {
            return _enabled && requestAnimationFrame(_rafBugFix);
        }, _pointerDownHandler = function _pointerDownHandler() {
            return _pointerIsDown = 1;
        }, _pointerUpHandler = function _pointerUpHandler() {
            return _pointerIsDown = 0;
        }, ScrollTrigger_passThrough = function _passThrough(v) {
            return v;
        }, ScrollTrigger_round = function _round(value) {
            return Math.round(value * 1e5) / 1e5 || 0;
        }, ScrollTrigger_windowExists = function _windowExists() {
            return typeof window !== "undefined";
        }, ScrollTrigger_getGSAP = function _getGSAP() {
            return ScrollTrigger_gsap || ScrollTrigger_windowExists() && (ScrollTrigger_gsap = window.gsap) && ScrollTrigger_gsap.registerPlugin && ScrollTrigger_gsap;
        }, ScrollTrigger_isViewport = function _isViewport(e) {
            return !!~ScrollTrigger_root.indexOf(e);
        }, _getBoundsFunc = function _getBoundsFunc(element) {
            return _getProxyProp(element, "getBoundingClientRect") || (ScrollTrigger_isViewport(element) ? function() {
                _winOffsets.width = ScrollTrigger_win.innerWidth;
                _winOffsets.height = ScrollTrigger_win.innerHeight;
                return _winOffsets;
            } : function() {
                return ScrollTrigger_getBounds(element);
            });
        }, _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
            var d = _ref.d, d2 = _ref.d2, a = _ref.a;
            return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
                return a()[d];
            } : function() {
                return (isViewport ? ScrollTrigger_win["inner" + d2] : scroller["client" + d2]) || 0;
            };
        }, _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
            return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
                return _winOffsets;
            };
        }, _maxScroll = function _maxScroll(element, _ref2) {
            var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;
            return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : ScrollTrigger_isViewport(element) ? (ScrollTrigger_docEl[s] || ScrollTrigger_body[s]) - (ScrollTrigger_win["inner" + d2] || ScrollTrigger_docEl["client" + d2] || ScrollTrigger_body["client" + d2]) : element[s] - element["offset" + d2]);
        }, _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
            for (var i = 0; i < _autoRefresh.length; i += 3) (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
        }, ScrollTrigger_isString = function _isString(value) {
            return typeof value === "string";
        }, ScrollTrigger_isFunction = function _isFunction(value) {
            return typeof value === "function";
        }, ScrollTrigger_isNumber = function _isNumber(value) {
            return typeof value === "number";
        }, ScrollTrigger_isObject = function _isObject(value) {
            return typeof value === "object";
        }, _endAnimation = function _endAnimation(animation, reversed, pause) {
            return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
        }, ScrollTrigger_callback = function _callback(self, func) {
            if (self.enabled) {
                var result = func(self);
                result && result.totalTime && (self.callbackAnimation = result);
            }
        }, _abs = Math.abs, _left = "left", _top = "top", _right = "right", _bottom = "bottom", _width = "width", _height = "height", _Right = "Right", _Left = "Left", _Top = "Top", _Bottom = "Bottom", _padding = "padding", _margin = "margin", _Width = "Width", _Height = "Height", _px = "px", _getComputedStyle = function _getComputedStyle(element) {
            return ScrollTrigger_win.getComputedStyle(element);
        }, _makePositionable = function _makePositionable(element) {
            var position = _getComputedStyle(element).position;
            element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
        }, ScrollTrigger_setDefaults = function _setDefaults(obj, defaults) {
            for (var p in defaults) p in obj || (obj[p] = defaults[p]);
            return obj;
        }, ScrollTrigger_getBounds = function _getBounds(element, withoutTransforms) {
            var tween = withoutTransforms && _getComputedStyle(element)[ScrollTrigger_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && ScrollTrigger_gsap.to(element, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1), bounds = element.getBoundingClientRect();
            tween && tween.progress(0).kill();
            return bounds;
        }, _getSize = function _getSize(element, _ref3) {
            var d2 = _ref3.d2;
            return element["offset" + d2] || element["client" + d2] || 0;
        }, _getLabelRatioArray = function _getLabelRatioArray(timeline) {
            var p, a = [], labels = timeline.labels, duration = timeline.duration();
            for (p in labels) a.push(labels[p] / duration);
            return a;
        }, _getClosestLabel = function _getClosestLabel(animation) {
            return function(value) {
                return ScrollTrigger_gsap.utils.snap(_getLabelRatioArray(animation), value);
            };
        }, _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
            var snap = ScrollTrigger_gsap.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort((function(a, b) {
                return a - b;
            }));
            return a ? function(value, direction, threshold) {
                if (threshold === void 0) threshold = .001;
                var i;
                if (!direction) return snap(value);
                if (direction > 0) {
                    value -= threshold;
                    for (i = 0; i < a.length; i++) if (a[i] >= value) return a[i];
                    return a[i - 1];
                } else {
                    i = a.length;
                    value += threshold;
                    while (i--) if (a[i] <= value) return a[i];
                }
                return a[0];
            } : function(value, direction, threshold) {
                if (threshold === void 0) threshold = .001;
                var snapped = snap(value);
                return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
            };
        }, _getLabelAtDirection = function _getLabelAtDirection(timeline) {
            return function(value, st) {
                return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
            };
        }, _multiListener = function _multiListener(func, element, types, callback) {
            return types.split(",").forEach((function(type) {
                return func(element, type, callback);
            }));
        }, ScrollTrigger_addListener = function _addListener(element, type, func, nonPassive, capture) {
            return element.addEventListener(type, func, {
                passive: !nonPassive,
                capture: !!capture
            });
        }, ScrollTrigger_removeListener = function _removeListener(element, type, func, capture) {
            return element.removeEventListener(type, func, !!capture);
        }, _wheelListener = function _wheelListener(func, el, scrollFunc) {
            scrollFunc = scrollFunc && scrollFunc.wheelHandler;
            if (scrollFunc) {
                func(el, "wheel", scrollFunc);
                func(el, "touchmove", scrollFunc);
            }
        }, _markerDefaults = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        }, ScrollTrigger_defaults = {
            toggleActions: "play",
            anticipatePin: 0
        }, _keywords = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        }, _offsetToPx = function _offsetToPx(value, size) {
            if (ScrollTrigger_isString(value)) {
                var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
                if (~eqIndex) {
                    value.indexOf("%") > eqIndex && (relative *= size / 100);
                    value = value.substr(0, eqIndex - 1);
                }
                value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
            }
            return value;
        }, _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
            var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;
            var e = ScrollTrigger_doc.createElement("div"), useFixedPosition = ScrollTrigger_isViewport(container) || _getProxyProp(container, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent = useFixedPosition ? ScrollTrigger_body : container, isStart = type.indexOf("start") !== -1, color = isStart ? startColor : endColor, css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
            (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
            matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
            e._isStart = isStart;
            e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
            e.style.cssText = css;
            e.innerText = name || name === 0 ? type + "-" + name : type;
            parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
            e._offset = e["offset" + direction.op.d2];
            _positionMarker(e, 0, direction, isStart);
            return e;
        }, _positionMarker = function _positionMarker(marker, start, direction, flipped) {
            var vars = {
                display: "block"
            }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
            marker._isFlipped = flipped;
            vars[direction.a + "Percent"] = flipped ? -100 : 0;
            vars[direction.a] = flipped ? "1px" : 0;
            vars["border" + side + _Width] = 1;
            vars["border" + oppositeSide + _Width] = 0;
            vars[direction.p] = start + "px";
            ScrollTrigger_gsap.set(marker, vars);
        }, _triggers = [], _ids = {}, _sync = function _sync() {
            return ScrollTrigger_getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
        }, ScrollTrigger_onScroll = function _onScroll() {
            if (!ScrollTrigger_normalizer || !ScrollTrigger_normalizer.isPressed || ScrollTrigger_normalizer.startX > ScrollTrigger_body.clientWidth) {
                _scrollers.cache++;
                if (ScrollTrigger_normalizer) _rafID || (_rafID = requestAnimationFrame(_updateAll)); else _updateAll();
                _lastScrollTime || ScrollTrigger_dispatch("scrollStart");
                _lastScrollTime = ScrollTrigger_getTime();
            }
        }, _setBaseDimensions = function _setBaseDimensions() {
            _baseScreenWidth = ScrollTrigger_win.innerWidth;
            _baseScreenHeight = ScrollTrigger_win.innerHeight;
        }, _onResize = function _onResize() {
            _scrollers.cache++;
            !_refreshing && !_ignoreResize && !ScrollTrigger_doc.fullscreenElement && !ScrollTrigger_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== ScrollTrigger_win.innerWidth || Math.abs(ScrollTrigger_win.innerHeight - _baseScreenHeight) > ScrollTrigger_win.innerHeight * .25) && _resizeDelay.restart(true);
        }, ScrollTrigger_listeners = {}, ScrollTrigger_emptyArray = [], _softRefresh = function _softRefresh() {
            return ScrollTrigger_removeListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
        }, ScrollTrigger_dispatch = function _dispatch(type) {
            return ScrollTrigger_listeners[type] && ScrollTrigger_listeners[type].map((function(f) {
                return f();
            })) || ScrollTrigger_emptyArray;
        }, _savedStyles = [], _revertRecorded = function _revertRecorded(media) {
            for (var i = 0; i < _savedStyles.length; i += 5) if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
                _savedStyles[i].style.cssText = _savedStyles[i + 1];
                _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
                _savedStyles[i + 3].uncache = 1;
            }
        }, _revertAll = function _revertAll(kill, media) {
            var trigger;
            for (_i = 0; _i < _triggers.length; _i++) {
                trigger = _triggers[_i];
                if (trigger && (!media || trigger._ctx === media)) if (kill) trigger.kill(1); else trigger.revert(true, true);
            }
            media && _revertRecorded(media);
            media || ScrollTrigger_dispatch("revert");
        }, _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
            _scrollers.cache++;
            (force || !_refreshingAll) && _scrollers.forEach((function(obj) {
                return ScrollTrigger_isFunction(obj) && obj.cacheID++ && (obj.rec = 0);
            }));
            ScrollTrigger_isString(scrollRestoration) && (ScrollTrigger_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);
        }, _refreshID = 0, _queueRefreshAll = function _queueRefreshAll() {
            if (_queueRefreshID !== _refreshID) {
                var id = _queueRefreshID = _refreshID;
                requestAnimationFrame((function() {
                    return id === _refreshID && _refreshAll(true);
                }));
            }
        }, _refreshAll = function _refreshAll(force, skipRevert) {
            if (_lastScrollTime && !force) {
                ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh);
                return;
            }
            _refreshingAll = ScrollTrigger_ScrollTrigger.isRefreshing = true;
            _scrollers.forEach((function(obj) {
                return ScrollTrigger_isFunction(obj) && ++obj.cacheID && (obj.rec = obj());
            }));
            var refreshInits = ScrollTrigger_dispatch("refreshInit");
            _sort && ScrollTrigger_ScrollTrigger.sort();
            skipRevert || _revertAll();
            _scrollers.forEach((function(obj) {
                if (ScrollTrigger_isFunction(obj)) {
                    obj.smooth && (obj.target.style.scrollBehavior = "auto");
                    obj(0);
                }
            }));
            _triggers.slice(0).forEach((function(t) {
                return t.refresh();
            }));
            _triggers.forEach((function(t, i) {
                if (t._subPinOffset && t.pin) {
                    var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight", original = t.pin[prop];
                    t.revert(true, 1);
                    t.adjustPinSpacing(t.pin[prop] - original);
                    t.refresh();
                }
            }));
            _triggers.forEach((function(t) {
                var max = _maxScroll(t.scroller, t._dir);
                (t.vars.end === "max" || t._endClamp && t.end > max) && t.setPositions(t.start, Math.max(t.start + 1, max), true);
            }));
            refreshInits.forEach((function(result) {
                return result && result.render && result.render(-1);
            }));
            _scrollers.forEach((function(obj) {
                if (ScrollTrigger_isFunction(obj)) {
                    obj.smooth && requestAnimationFrame((function() {
                        return obj.target.style.scrollBehavior = "smooth";
                    }));
                    obj.rec && obj(obj.rec);
                }
            }));
            _clearScrollMemory(_scrollRestoration, 1);
            _resizeDelay.pause();
            _refreshID++;
            _refreshingAll = 2;
            _updateAll(2);
            _triggers.forEach((function(t) {
                return ScrollTrigger_isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);
            }));
            _refreshingAll = ScrollTrigger_ScrollTrigger.isRefreshing = false;
            ScrollTrigger_dispatch("refresh");
        }, _lastScroll = 0, _direction = 1, _updateAll = function _updateAll(force) {
            if (!_refreshingAll || force === 2) {
                ScrollTrigger_ScrollTrigger.isUpdating = true;
                _primary && _primary.update(0);
                var l = _triggers.length, time = ScrollTrigger_getTime(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();
                _direction = _lastScroll > scroll ? -1 : 1;
                _refreshingAll || (_lastScroll = scroll);
                if (recordVelocity) {
                    if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
                        _lastScrollTime = 0;
                        ScrollTrigger_dispatch("scrollEnd");
                    }
                    _time2 = _time1;
                    _time1 = time;
                }
                if (_direction < 0) {
                    _i = l;
                    while (_i-- > 0) _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                    _direction = 1;
                } else for (_i = 0; _i < l; _i++) _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                ScrollTrigger_ScrollTrigger.isUpdating = false;
            }
            _rafID = 0;
        }, _propNamesToCopy = [ _left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order" ], _stateProps = _propNamesToCopy.concat([ _width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left ]), _swapPinOut = function _swapPinOut(pin, spacer, state) {
            _setState(state);
            var cache = pin._gsap;
            if (cache.spacerIsNative) _setState(cache.spacerState); else if (pin._gsap.swappedIn) {
                var parent = spacer.parentNode;
                if (parent) {
                    parent.insertBefore(pin, spacer);
                    parent.removeChild(spacer);
                }
            }
            pin._gsap.swappedIn = false;
        }, _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
            if (!pin._gsap.swappedIn) {
                var p, i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style;
                while (i--) {
                    p = _propNamesToCopy[i];
                    spacerStyle[p] = cs[p];
                }
                spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
                cs.display === "inline" && (spacerStyle.display = "inline-block");
                pinStyle[_bottom] = pinStyle[_right] = "auto";
                spacerStyle.flexBasis = cs.flexBasis || "auto";
                spacerStyle.overflow = "visible";
                spacerStyle.boxSizing = "border-box";
                spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
                spacerStyle[_height] = _getSize(pin, _vertical) + _px;
                spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
                _setState(spacerState);
                pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
                pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
                pinStyle[_padding] = cs[_padding];
                if (pin.parentNode !== spacer) {
                    pin.parentNode.insertBefore(spacer, pin);
                    spacer.appendChild(pin);
                }
                pin._gsap.swappedIn = true;
            }
        }, ScrollTrigger_capsExp = /([A-Z])/g, _setState = function _setState(state) {
            if (state) {
                var p, value, style = state.t.style, l = state.length, i = 0;
                (state.t._gsap || ScrollTrigger_gsap.core.getCache(state.t)).uncache = 1;
                for (;i < l; i += 2) {
                    value = state[i + 1];
                    p = state[i];
                    if (value) style[p] = value; else if (style[p]) style.removeProperty(p.replace(ScrollTrigger_capsExp, "-$1").toLowerCase());
                }
            }
        }, _getState = function _getState(element) {
            var l = _stateProps.length, style = element.style, state = [], i = 0;
            for (;i < l; i++) state.push(_stateProps[i], style[_stateProps[i]]);
            state.t = element;
            return state;
        }, _copyState = function _copyState(state, override, omitOffsets) {
            var p, result = [], l = state.length, i = omitOffsets ? 8 : 0;
            for (;i < l; i += 2) {
                p = state[i];
                result.push(p, p in override ? override[p] : state[i + 1]);
            }
            result.t = state.t;
            return result;
        }, _winOffsets = {
            left: 0,
            top: 0
        }, ScrollTrigger_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
            ScrollTrigger_isFunction(value) && (value = value(self));
            if (ScrollTrigger_isString(value) && value.substr(0, 3) === "max") value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
            var p1, p2, element, time = containerAnimation ? containerAnimation.time() : 0;
            containerAnimation && containerAnimation.seek(0);
            isNaN(value) || (value = +value);
            if (!ScrollTrigger_isNumber(value)) {
                ScrollTrigger_isFunction(trigger) && (trigger = trigger(self));
                var bounds, localOffset, globalOffset, display, offsets = (value || "0").split(" ");
                element = Observer_getTarget(trigger, self) || ScrollTrigger_body;
                bounds = ScrollTrigger_getBounds(element) || {};
                if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
                    display = element.style.display;
                    element.style.display = "block";
                    bounds = ScrollTrigger_getBounds(element);
                    display ? element.style.display = display : element.style.removeProperty("display");
                }
                localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
                globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
                value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
                markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
                scrollerSize -= scrollerSize - globalOffset;
            } else {
                containerAnimation && (value = ScrollTrigger_gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
                markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
            }
            if (clampZeroProp) {
                self[clampZeroProp] = value || -.001;
                value < 0 && (value = 0);
            }
            if (marker) {
                var position = value + scrollerSize, isStart = marker._isStart;
                p1 = "scroll" + direction.d2;
                _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(ScrollTrigger_body[p1], ScrollTrigger_docEl[p1]) : marker.parentNode[p1]) <= position + 1);
                if (useFixedPosition) {
                    scrollerBounds = ScrollTrigger_getBounds(markerScroller);
                    useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
                }
            }
            if (containerAnimation && element) {
                p1 = ScrollTrigger_getBounds(element);
                containerAnimation.seek(scrollerMax);
                p2 = ScrollTrigger_getBounds(element);
                containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
                value = value / containerAnimation._caScrollDist * scrollerMax;
            }
            containerAnimation && containerAnimation.seek(time);
            return containerAnimation ? value : Math.round(value);
        }, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function _reparent(element, parent, top, left) {
            if (element.parentNode !== parent) {
                var p, cs, style = element.style;
                if (parent === ScrollTrigger_body) {
                    element._stOrig = style.cssText;
                    cs = _getComputedStyle(element);
                    for (p in cs) if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") style[p] = cs[p];
                    style.top = top;
                    style.left = left;
                } else style.cssText = element._stOrig;
                ScrollTrigger_gsap.core.getCache(element).uncache = 1;
                parent.appendChild(element);
            }
        }, _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {
            var last1 = initialValue, last2 = last1;
            return function(value) {
                var current = Math.round(getValueFunc());
                if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
                    value = current;
                    onInterrupt && onInterrupt();
                }
                last2 = last1;
                last1 = value;
                return value;
            };
        }, _shiftMarker = function _shiftMarker(marker, direction, value) {
            var vars = {};
            vars[direction.p] = "+=" + value;
            ScrollTrigger_gsap.set(marker, vars);
        }, _getTweenCreator = function _getTweenCreator(scroller, direction) {
            var getScroll = _getScrollFunc(scroller, direction), prop = "_scroll" + direction.p2, getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
                var tween = getTween.tween, onComplete = vars.onComplete, modifiers = {};
                initialValue = initialValue || getScroll();
                var checkForInterruption = _interruptionTracker(getScroll, initialValue, (function() {
                    tween.kill();
                    getTween.tween = 0;
                }));
                change2 = change1 && change2 || 0;
                change1 = change1 || scrollTo - initialValue;
                tween && tween.kill();
                vars[prop] = scrollTo;
                vars.modifiers = modifiers;
                modifiers[prop] = function() {
                    return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
                };
                vars.onUpdate = function() {
                    _scrollers.cache++;
                    _updateAll();
                };
                vars.onComplete = function() {
                    getTween.tween = 0;
                    onComplete && onComplete.call(tween);
                };
                tween = getTween.tween = ScrollTrigger_gsap.to(scroller, vars);
                return tween;
            };
            scroller[prop] = getScroll;
            getScroll.wheelHandler = function() {
                return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
            };
            ScrollTrigger_addListener(scroller, "wheel", getScroll.wheelHandler);
            ScrollTrigger_ScrollTrigger.isTouch && ScrollTrigger_addListener(scroller, "touchmove", getScroll.wheelHandler);
            return getTween;
        };
        var ScrollTrigger_ScrollTrigger = function() {
            function ScrollTrigger(vars, animation) {
                ScrollTrigger_coreInitted || ScrollTrigger.register(ScrollTrigger_gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
                ScrollTrigger_context(this);
                this.init(vars, animation);
            }
            var _proto = ScrollTrigger.prototype;
            _proto.init = function init(vars, animation) {
                this.progress = this.start = 0;
                this.vars && this.kill(true, true);
                if (!_enabled) {
                    this.update = this.refresh = this.kill = ScrollTrigger_passThrough;
                    return;
                }
                vars = ScrollTrigger_setDefaults(ScrollTrigger_isString(vars) || ScrollTrigger_isNumber(vars) || vars.nodeType ? {
                    trigger: vars
                } : vars, ScrollTrigger_defaults);
                var tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn, _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = Observer_getTarget(vars.scroller || ScrollTrigger_win), scrollerCache = ScrollTrigger_gsap.core.getCache(scroller), isViewport = ScrollTrigger_isViewport(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [ vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack ], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : ScrollTrigger_defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {
                    return vars.onRefreshInit(self);
                }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = _getScrollFunc(scroller, direction);
                self._startClamp = self._endClamp = false;
                self._dir = direction;
                anticipatePin *= 45;
                self.scroller = scroller;
                self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
                scroll1 = scrollFunc();
                self.vars = vars;
                animation = animation || vars.animation;
                if ("refreshPriority" in vars) {
                    _sort = 1;
                    vars.refreshPriority === -9999 && (_primary = self);
                }
                scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
                    top: _getTweenCreator(scroller, _vertical),
                    left: _getTweenCreator(scroller, _horizontal)
                };
                self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
                self.scrubDuration = function(value) {
                    scrubSmooth = ScrollTrigger_isNumber(value) && value;
                    if (!scrubSmooth) {
                        scrubTween && scrubTween.progress(1).kill();
                        scrubTween = 0;
                    } else scrubTween ? scrubTween.duration(value) : scrubTween = ScrollTrigger_gsap.to(animation, {
                        ease: "expo",
                        totalProgress: "+=0",
                        duration: scrubSmooth,
                        paused: true,
                        onComplete: function onComplete() {
                            return onScrubComplete && onScrubComplete(self);
                        }
                    });
                };
                if (animation) {
                    animation.vars.lazy = false;
                    animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
                    self.animation = animation.pause();
                    animation.scrollTrigger = self;
                    self.scrubDuration(scrub);
                    snap1 = 0;
                    id || (id = animation.vars.id);
                }
                if (snap) {
                    if (!ScrollTrigger_isObject(snap) || snap.push) snap = {
                        snapTo: snap
                    };
                    "scrollBehavior" in ScrollTrigger_body.style && ScrollTrigger_gsap.set(isViewport ? [ ScrollTrigger_body, ScrollTrigger_docEl ] : scroller, {
                        scrollBehavior: "auto"
                    });
                    _scrollers.forEach((function(o) {
                        return ScrollTrigger_isFunction(o) && o.target === (isViewport ? ScrollTrigger_doc.scrollingElement || ScrollTrigger_docEl : scroller) && (o.smooth = false);
                    }));
                    snapFunc = ScrollTrigger_isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function(value, st) {
                        return _snapDirectional(snap.snapTo)(value, ScrollTrigger_getTime() - lastRefresh < 500 ? 0 : st.direction);
                    } : ScrollTrigger_gsap.utils.snap(snap.snapTo);
                    snapDurClamp = snap.duration || {
                        min: .1,
                        max: 2
                    };
                    snapDurClamp = ScrollTrigger_isObject(snapDurClamp) ? ScrollTrigger_clamp(snapDurClamp.min, snapDurClamp.max) : ScrollTrigger_clamp(snapDurClamp, snapDurClamp);
                    snapDelayedCall = ScrollTrigger_gsap.delayedCall(snap.delay || scrubSmooth / 2 || .1, (function() {
                        var scroll = scrollFunc(), refreshedRecently = ScrollTrigger_getTime() - lastRefresh < 500, tween = tweenTo.tween;
                        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
                            var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (ScrollTrigger_getTime() - _time2) * 1e3 || 0, change1 = ScrollTrigger_gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / .185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue = ScrollTrigger_clamp(0, 1, snapFunc(naturalEnd, self)), endScroll = Math.round(start + endValue * change), _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;
                            if (scroll <= end && scroll >= start && endScroll !== scroll) {
                                if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) return;
                                if (snap.inertia === false) change1 = endValue - progress;
                                tweenTo(endScroll, {
                                    duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * .185 / velocity / .05 || 0)),
                                    ease: snap.ease || "power3",
                                    data: _abs(endScroll - scroll),
                                    onInterrupt: function onInterrupt() {
                                        return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                                    },
                                    onComplete: function onComplete() {
                                        self.update();
                                        lastSnap = scrollFunc();
                                        snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                                        onSnapComplete && onSnapComplete(self);
                                        _onComplete && _onComplete(self);
                                    }
                                }, scroll, change1 * change, endScroll - scroll - change1 * change);
                                onStart && onStart(self, tweenTo.tween);
                            }
                        } else if (self.isActive && lastSnap !== scroll) snapDelayedCall.restart(true);
                    })).pause();
                }
                id && (_ids[id] = self);
                trigger = self.trigger = Observer_getTarget(trigger || pin !== true && pin);
                customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
                customRevertReturn && (customRevertReturn = customRevertReturn(self));
                pin = pin === true ? trigger : Observer_getTarget(pin);
                ScrollTrigger_isString(toggleClass) && (toggleClass = {
                    targets: trigger,
                    className: toggleClass
                });
                if (pin) {
                    pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
                    self.pin = pin;
                    pinCache = ScrollTrigger_gsap.core.getCache(pin);
                    if (!pinCache.spacer) {
                        if (pinSpacer) {
                            pinSpacer = Observer_getTarget(pinSpacer);
                            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
                            pinCache.spacerIsNative = !!pinSpacer;
                            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
                        }
                        pinCache.spacer = spacer = pinSpacer || ScrollTrigger_doc.createElement("div");
                        spacer.classList.add("pin-spacer");
                        id && spacer.classList.add("pin-spacer-" + id);
                        pinCache.pinState = pinOriginalState = _getState(pin);
                    } else pinOriginalState = pinCache.pinState;
                    vars.force3D !== false && ScrollTrigger_gsap.set(pin, {
                        force3D: true
                    });
                    self.spacer = spacer = pinCache.spacer;
                    cs = _getComputedStyle(pin);
                    spacingStart = cs[pinSpacing + direction.os2];
                    pinGetter = ScrollTrigger_gsap.getProperty(pin);
                    pinSetter = ScrollTrigger_gsap.quickSetter(pin, direction.a, _px);
                    _swapPinIn(pin, spacer, cs);
                    pinState = _getState(pin);
                }
                if (markers) {
                    markerVars = ScrollTrigger_isObject(markers) ? ScrollTrigger_setDefaults(markers, _markerDefaults) : _markerDefaults;
                    markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
                    markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
                    offset = markerStartTrigger["offset" + direction.op.d2];
                    var content = Observer_getTarget(_getProxyProp(scroller, "content") || scroller);
                    markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
                    markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
                    containerAnimation && (caMarkerSetter = ScrollTrigger_gsap.quickSetter([ markerStart, markerEnd ], direction.a, _px));
                    if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
                        _makePositionable(isViewport ? ScrollTrigger_body : scroller);
                        ScrollTrigger_gsap.set([ markerStartTrigger, markerEndTrigger ], {
                            force3D: true
                        });
                        markerStartSetter = ScrollTrigger_gsap.quickSetter(markerStartTrigger, direction.a, _px);
                        markerEndSetter = ScrollTrigger_gsap.quickSetter(markerEndTrigger, direction.a, _px);
                    }
                }
                if (containerAnimation) {
                    var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
                    containerAnimation.eventCallback("onUpdate", (function() {
                        self.update(0, 0, 1);
                        oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
                    }));
                }
                self.previous = function() {
                    return _triggers[_triggers.indexOf(self) - 1];
                };
                self.next = function() {
                    return _triggers[_triggers.indexOf(self) + 1];
                };
                self.revert = function(revert, temp) {
                    if (!temp) return self.kill(true);
                    var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;
                    if (r !== self.isReverted) {
                        if (r) {
                            prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
                            prevProgress = self.progress;
                            prevAnimProgress = animation && animation.progress();
                        }
                        markerStart && [ markerStart, markerEnd, markerStartTrigger, markerEndTrigger ].forEach((function(m) {
                            return m.style.display = r ? "none" : "block";
                        }));
                        if (r) {
                            _refreshing = self;
                            self.update(r);
                        }
                        if (pin && (!pinReparent || !self.isActive)) if (r) _swapPinOut(pin, spacer, pinOriginalState); else _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
                        r || self.update(r);
                        _refreshing = prevRefreshing;
                        self.isReverted = r;
                    }
                };
                self.refresh = function(soft, force, position, pinOffset) {
                    if ((_refreshing || !self.enabled) && !force) return;
                    if (pin && soft && _lastScrollTime) {
                        ScrollTrigger_addListener(ScrollTrigger, "scrollEnd", _softRefresh);
                        return;
                    }
                    !_refreshingAll && onRefreshInit && onRefreshInit(self);
                    _refreshing = self;
                    if (tweenTo.tween) {
                        tweenTo.tween.kill();
                        tweenTo.tween = 0;
                    }
                    scrubTween && scrubTween.pause();
                    invalidateOnRefresh && animation && animation.revert({
                        kill: false
                    }).invalidate();
                    self.isReverted || self.revert(true, true);
                    self._subPinOffset = false;
                    var cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset, size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= .01, offset = 0, otherPinOffset = pinOffset || 0, parsedEnd = ScrollTrigger_isObject(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = ScrollTrigger_isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && Observer_getTarget(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex;
                    if (markers && ScrollTrigger_isObject(position)) {
                        markerStartOffset = ScrollTrigger_gsap.getProperty(markerStartTrigger, direction.p);
                        markerEndOffset = ScrollTrigger_gsap.getProperty(markerEndTrigger, direction.p);
                    }
                    while (i--) {
                        curTrigger = _triggers[i];
                        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self);
                        curPin = curTrigger.pin;
                        if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
                            revertedPins || (revertedPins = []);
                            revertedPins.unshift(curTrigger);
                            curTrigger.revert(true, true);
                        }
                        if (curTrigger !== _triggers[i]) {
                            triggerIndex--;
                            i--;
                        }
                    }
                    ScrollTrigger_isFunction(parsedStart) && (parsedStart = parsedStart(self));
                    parsedStart = _parseClamp(parsedStart, "start", self);
                    start = ScrollTrigger_parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && "_startClamp") || (pin ? -.001 : 0);
                    ScrollTrigger_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
                    if (ScrollTrigger_isString(parsedEnd) && !parsedEnd.indexOf("+=")) if (~parsedEnd.indexOf(" ")) parsedEnd = (ScrollTrigger_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd; else {
                        offset = _offsetToPx(parsedEnd.substr(2), size);
                        parsedEnd = ScrollTrigger_isString(parsedStart) ? parsedStart : (containerAnimation ? ScrollTrigger_gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset;
                        parsedEndTrigger = trigger;
                    }
                    parsedEnd = _parseClamp(parsedEnd, "end", self);
                    end = Math.max(start, ScrollTrigger_parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && "_endClamp")) || -.001;
                    offset = 0;
                    i = triggerIndex;
                    while (i--) {
                        curTrigger = _triggers[i];
                        curPin = curTrigger.pin;
                        if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
                            cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);
                            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) offset += cs * (1 - curTrigger.progress);
                            curPin === pin && (otherPinOffset += cs);
                        }
                    }
                    start += offset;
                    end += offset;
                    self._startClamp && (self._startClamp += offset);
                    if (self._endClamp && !_refreshingAll) {
                        self._endClamp = end || -.001;
                        end = Math.min(end, _maxScroll(scroller, direction));
                    }
                    change = end - start || (start -= .01) && .001;
                    if (isFirstRefresh) prevProgress = ScrollTrigger_gsap.utils.clamp(0, 1, ScrollTrigger_gsap.utils.normalize(start, end, prevScroll));
                    self._pinPush = otherPinOffset;
                    if (markerStart && offset) {
                        cs = {};
                        cs[direction.a] = "+=" + offset;
                        pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
                        ScrollTrigger_gsap.set([ markerStart, markerEnd ], cs);
                    }
                    if (pin) {
                        cs = _getComputedStyle(pin);
                        isVertical = direction === _vertical;
                        scroll = scrollFunc();
                        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
                        if (!max && end > 1) {
                            forcedOverflow = (isViewport ? ScrollTrigger_doc.scrollingElement || ScrollTrigger_docEl : scroller).style;
                            forcedOverflow = {
                                style: forcedOverflow,
                                value: forcedOverflow["overflow" + direction.a.toUpperCase()]
                            };
                            if (isViewport && _getComputedStyle(ScrollTrigger_body)["overflow" + direction.a.toUpperCase()] !== "scroll") forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
                        }
                        _swapPinIn(pin, spacer, cs);
                        pinState = _getState(pin);
                        bounds = ScrollTrigger_getBounds(pin, true);
                        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
                        if (pinSpacing) {
                            spacerState = [ pinSpacing + direction.os2, change + otherPinOffset + _px ];
                            spacerState.t = spacer;
                            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
                            i && spacerState.push(direction.d, i + _px);
                            _setState(spacerState);
                            if (pinnedContainer) _triggers.forEach((function(t) {
                                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) t._subPinOffset = true;
                            }));
                            useFixedPosition && scrollFunc(prevScroll);
                        }
                        if (useFixedPosition) {
                            override = {
                                top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                                left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                                boxSizing: "border-box",
                                position: "fixed"
                            };
                            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
                            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
                            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
                            override[_padding] = cs[_padding];
                            override[_padding + _Top] = cs[_padding + _Top];
                            override[_padding + _Right] = cs[_padding + _Right];
                            override[_padding + _Bottom] = cs[_padding + _Bottom];
                            override[_padding + _Left] = cs[_padding + _Left];
                            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
                            _refreshingAll && scrollFunc(0);
                        }
                        if (animation) {
                            initted = animation._initted;
                            ScrollTrigger_suppressOverwrites(1);
                            animation.render(animation.duration(), true, true);
                            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
                            pinMoves = Math.abs(change - pinChange) > 1;
                            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
                            animation.render(0, true, true);
                            initted || animation.invalidate(true);
                            animation.parent || animation.totalTime(animation.totalTime());
                            ScrollTrigger_suppressOverwrites(0);
                        } else pinChange = change;
                        forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
                    } else if (trigger && scrollFunc() && !containerAnimation) {
                        bounds = trigger.parentNode;
                        while (bounds && bounds !== ScrollTrigger_body) {
                            if (bounds._pinOffset) {
                                start -= bounds._pinOffset;
                                end -= bounds._pinOffset;
                            }
                            bounds = bounds.parentNode;
                        }
                    }
                    revertedPins && revertedPins.forEach((function(t) {
                        return t.revert(false, true);
                    }));
                    self.start = start;
                    self.end = end;
                    scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
                    if (!containerAnimation && !_refreshingAll) {
                        scroll1 < prevScroll && scrollFunc(prevScroll);
                        self.scroll.rec = 0;
                    }
                    self.revert(false, true);
                    lastRefresh = ScrollTrigger_getTime();
                    if (snapDelayedCall) {
                        lastSnap = -1;
                        self.isActive && scrollFunc(start + change * prevProgress);
                        snapDelayedCall.restart(true);
                    }
                    _refreshing = 0;
                    animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true);
                    if (isFirstRefresh || prevProgress !== self.progress || containerAnimation) {
                        animation && !isToggle && animation.totalProgress(containerAnimation && start < -.001 && !prevProgress ? ScrollTrigger_gsap.utils.normalize(start, end, 0) : prevProgress, true);
                        self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
                    }
                    pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
                    scrubTween && scrubTween.invalidate();
                    if (!isNaN(markerStartOffset)) {
                        markerStartOffset -= ScrollTrigger_gsap.getProperty(markerStartTrigger, direction.p);
                        markerEndOffset -= ScrollTrigger_gsap.getProperty(markerEndTrigger, direction.p);
                        _shiftMarker(markerStartTrigger, direction, markerStartOffset);
                        _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));
                        _shiftMarker(markerEndTrigger, direction, markerEndOffset);
                        _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
                    }
                    isFirstRefresh && !_refreshingAll && self.update();
                    if (onRefresh && !_refreshingAll && !executingOnRefresh) {
                        executingOnRefresh = true;
                        onRefresh(self);
                        executingOnRefresh = false;
                    }
                };
                self.getVelocity = function() {
                    return (scrollFunc() - scroll2) / (ScrollTrigger_getTime() - _time2) * 1e3 || 0;
                };
                self.endAnimation = function() {
                    _endAnimation(self.callbackAnimation);
                    if (animation) scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
                };
                self.labelToScroll = function(label) {
                    return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
                };
                self.getTrailing = function(name) {
                    var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
                    return (ScrollTrigger_isString(name) ? a.filter((function(t) {
                        return t.vars.preventOverlaps === name;
                    })) : a).filter((function(t) {
                        return self.direction > 0 ? t.end <= start : t.start >= end;
                    }));
                };
                self.update = function(reset, recordVelocity, forceFake) {
                    if (containerAnimation && !forceFake && !reset) return;
                    var isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction, scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress = self.progress;
                    if (recordVelocity) {
                        scroll2 = scroll1;
                        scroll1 = containerAnimation ? scrollFunc() : scroll;
                        if (snap) {
                            snap2 = snap1;
                            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
                        }
                    }
                    anticipatePin && !clipped && pin && !_refreshing && !ScrollTrigger_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (ScrollTrigger_getTime() - _time2) * anticipatePin && (clipped = 1e-4);
                    if (clipped !== prevProgress && self.enabled) {
                        isActive = self.isActive = !!clipped && clipped < 1;
                        wasActive = !!prevProgress && prevProgress < 1;
                        toggled = isActive !== wasActive;
                        stateChanged = toggled || !!clipped !== !!prevProgress;
                        self.direction = clipped > prevProgress ? 1 : -1;
                        self.progress = clipped;
                        if (stateChanged && !_refreshing) {
                            toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3;
                            if (isToggle) {
                                action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
                                isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
                            }
                        }
                        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (ScrollTrigger_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach((function(t) {
                            return t.endAnimation();
                        })));
                        if (!isToggle) if (scrubTween && !_refreshing && !ScrollTrigger_startup) {
                            scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
                            if (scrubTween.resetTo) scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur); else {
                                scrubTween.vars.totalProgress = clipped;
                                scrubTween.invalidate().restart();
                            }
                        } else if (animation) animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
                        if (pin) {
                            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
                            if (!useFixedPosition) pinSetter(ScrollTrigger_round(pinStart + pinChange * clipped)); else if (stateChanged) {
                                isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
                                if (pinReparent) if (!reset && (isActive || isAtMax)) {
                                    var bounds = ScrollTrigger_getBounds(pin, true), _offset = scroll - start;
                                    _reparent(pin, ScrollTrigger_body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                                } else _reparent(pin, spacer);
                                _setState(isActive || isAtMax ? pinActiveState : pinState);
                                pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
                            }
                        }
                        snap && !tweenTo.tween && !_refreshing && !ScrollTrigger_startup && snapDelayedCall.restart(true);
                        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach((function(el) {
                            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
                        }));
                        onUpdate && !isToggle && !reset && onUpdate(self);
                        if (stateChanged && !_refreshing) {
                            if (isToggle) {
                                if (isTakingAction) if (action === "complete") animation.pause().totalProgress(1); else if (action === "reset") animation.restart(true).pause(); else if (action === "restart") animation.restart(true); else animation[action]();
                                onUpdate && onUpdate(self);
                            }
                            if (toggled || !_limitCallbacks) {
                                onToggle && toggled && ScrollTrigger_callback(self, onToggle);
                                callbacks[toggleState] && ScrollTrigger_callback(self, callbacks[toggleState]);
                                once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);
                                if (!toggled) {
                                    toggleState = clipped === 1 ? 1 : 3;
                                    callbacks[toggleState] && ScrollTrigger_callback(self, callbacks[toggleState]);
                                }
                            }
                            if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (ScrollTrigger_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
                                _endAnimation(self.callbackAnimation);
                                scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
                            }
                        } else if (isToggle && onUpdate && !_refreshing) onUpdate(self);
                    }
                    if (markerEndSetter) {
                        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
                        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
                        markerEndSetter(n);
                    }
                    caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
                };
                self.enable = function(reset, refresh) {
                    if (!self.enabled) {
                        self.enabled = true;
                        ScrollTrigger_addListener(scroller, "resize", _onResize);
                        ScrollTrigger_addListener(isViewport ? ScrollTrigger_doc : scroller, "scroll", ScrollTrigger_onScroll);
                        onRefreshInit && ScrollTrigger_addListener(ScrollTrigger, "refreshInit", onRefreshInit);
                        if (reset !== false) {
                            self.progress = prevProgress = 0;
                            scroll1 = scroll2 = lastSnap = scrollFunc();
                        }
                        refresh !== false && self.refresh();
                    }
                };
                self.getTween = function(snap) {
                    return snap && tweenTo ? tweenTo.tween : scrubTween;
                };
                self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
                    if (containerAnimation) {
                        var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;
                        newStart = st.start + _change * newStart / duration;
                        newEnd = st.start + _change * newEnd / duration;
                    }
                    self.refresh(false, false, {
                        start: _keepClamp(newStart, keepClamp && !!self._startClamp),
                        end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
                    }, pinOffset);
                    self.update();
                };
                self.adjustPinSpacing = function(amount) {
                    if (spacerState && amount) {
                        var i = spacerState.indexOf(direction.d) + 1;
                        spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
                        spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
                        _setState(spacerState);
                    }
                };
                self.disable = function(reset, allowAnimation) {
                    if (self.enabled) {
                        reset !== false && self.revert(true, true);
                        self.enabled = self.isActive = false;
                        allowAnimation || scrubTween && scrubTween.pause();
                        prevScroll = 0;
                        pinCache && (pinCache.uncache = 1);
                        onRefreshInit && ScrollTrigger_removeListener(ScrollTrigger, "refreshInit", onRefreshInit);
                        if (snapDelayedCall) {
                            snapDelayedCall.pause();
                            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
                        }
                        if (!isViewport) {
                            var i = _triggers.length;
                            while (i--) if (_triggers[i].scroller === scroller && _triggers[i] !== self) return;
                            ScrollTrigger_removeListener(scroller, "resize", _onResize);
                            ScrollTrigger_removeListener(scroller, "scroll", ScrollTrigger_onScroll);
                        }
                    }
                };
                self.kill = function(revert, allowAnimation) {
                    self.disable(revert, allowAnimation);
                    scrubTween && !allowAnimation && scrubTween.kill();
                    id && delete _ids[id];
                    var i = _triggers.indexOf(self);
                    i >= 0 && _triggers.splice(i, 1);
                    i === _i && _direction > 0 && _i--;
                    i = 0;
                    _triggers.forEach((function(t) {
                        return t.scroller === self.scroller && (i = 1);
                    }));
                    i || _refreshingAll || (self.scroll.rec = 0);
                    if (animation) {
                        animation.scrollTrigger = null;
                        revert && animation.revert({
                            kill: false
                        });
                        allowAnimation || animation.kill();
                    }
                    markerStart && [ markerStart, markerEnd, markerStartTrigger, markerEndTrigger ].forEach((function(m) {
                        return m.parentNode && m.parentNode.removeChild(m);
                    }));
                    _primary === self && (_primary = 0);
                    if (pin) {
                        pinCache && (pinCache.uncache = 1);
                        i = 0;
                        _triggers.forEach((function(t) {
                            return t.pin === pin && i++;
                        }));
                        i || (pinCache.spacer = 0);
                    }
                    vars.onKill && vars.onKill(self);
                };
                _triggers.push(self);
                self.enable(false, false);
                customRevertReturn && customRevertReturn(self);
                if (animation && animation.add && !change) {
                    var updateFunc = self.update;
                    self.update = function() {
                        self.update = updateFunc;
                        start || end || self.refresh();
                    };
                    ScrollTrigger_gsap.delayedCall(.01, self.update);
                    change = .01;
                    start = end = 0;
                } else self.refresh();
                pin && _queueRefreshAll();
            };
            ScrollTrigger.register = function register(core) {
                if (!ScrollTrigger_coreInitted) {
                    ScrollTrigger_gsap = core || ScrollTrigger_getGSAP();
                    ScrollTrigger_windowExists() && window.document && ScrollTrigger.enable();
                    ScrollTrigger_coreInitted = _enabled;
                }
                return ScrollTrigger_coreInitted;
            };
            ScrollTrigger.defaults = function defaults(config) {
                if (config) for (var p in config) ScrollTrigger_defaults[p] = config[p];
                return ScrollTrigger_defaults;
            };
            ScrollTrigger.disable = function disable(reset, kill) {
                _enabled = 0;
                _triggers.forEach((function(trigger) {
                    return trigger[kill ? "kill" : "disable"](reset);
                }));
                ScrollTrigger_removeListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll);
                ScrollTrigger_removeListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll);
                clearInterval(_syncInterval);
                ScrollTrigger_removeListener(ScrollTrigger_doc, "touchcancel", ScrollTrigger_passThrough);
                ScrollTrigger_removeListener(ScrollTrigger_body, "touchstart", ScrollTrigger_passThrough);
                _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
                _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);
                _resizeDelay.kill();
                _iterateAutoRefresh(ScrollTrigger_removeListener);
                for (var i = 0; i < _scrollers.length; i += 3) {
                    _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);
                    _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
                }
            };
            ScrollTrigger.enable = function enable() {
                ScrollTrigger_win = window;
                ScrollTrigger_doc = document;
                ScrollTrigger_docEl = ScrollTrigger_doc.documentElement;
                ScrollTrigger_body = ScrollTrigger_doc.body;
                if (ScrollTrigger_gsap) {
                    _toArray = ScrollTrigger_gsap.utils.toArray;
                    ScrollTrigger_clamp = ScrollTrigger_gsap.utils.clamp;
                    ScrollTrigger_context = ScrollTrigger_gsap.core.context || ScrollTrigger_passThrough;
                    ScrollTrigger_suppressOverwrites = ScrollTrigger_gsap.core.suppressOverwrites || ScrollTrigger_passThrough;
                    _scrollRestoration = ScrollTrigger_win.history.scrollRestoration || "auto";
                    _lastScroll = ScrollTrigger_win.pageYOffset;
                    ScrollTrigger_gsap.core.globals("ScrollTrigger", ScrollTrigger);
                    if (ScrollTrigger_body) {
                        _enabled = 1;
                        _rafBugFix();
                        Observer_Observer.register(ScrollTrigger_gsap);
                        ScrollTrigger.isTouch = Observer_Observer.isTouch;
                        _fixIOSBug = Observer_Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
                        ScrollTrigger_addListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll);
                        ScrollTrigger_root = [ ScrollTrigger_win, ScrollTrigger_doc, ScrollTrigger_docEl, ScrollTrigger_body ];
                        if (ScrollTrigger_gsap.matchMedia) {
                            ScrollTrigger.matchMedia = function(vars) {
                                var p, mm = ScrollTrigger_gsap.matchMedia();
                                for (p in vars) mm.add(p, vars[p]);
                                return mm;
                            };
                            ScrollTrigger_gsap.addEventListener("matchMediaInit", (function() {
                                return _revertAll();
                            }));
                            ScrollTrigger_gsap.addEventListener("matchMediaRevert", (function() {
                                return _revertRecorded();
                            }));
                            ScrollTrigger_gsap.addEventListener("matchMedia", (function() {
                                _refreshAll(0, 1);
                                ScrollTrigger_dispatch("matchMedia");
                            }));
                            ScrollTrigger_gsap.matchMedia("(orientation: portrait)", (function() {
                                _setBaseDimensions();
                                return _setBaseDimensions;
                            }));
                        } else console.warn("Requires GSAP 3.11.0 or later");
                        _setBaseDimensions();
                        ScrollTrigger_addListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll);
                        var bounds, i, bodyStyle = ScrollTrigger_body.style, border = bodyStyle.borderTopStyle, AnimationProto = ScrollTrigger_gsap.core.Animation.prototype;
                        AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
                            value: function value() {
                                return this.time(-.01, true);
                            }
                        });
                        bodyStyle.borderTopStyle = "solid";
                        bounds = ScrollTrigger_getBounds(ScrollTrigger_body);
                        _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
                        _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
                        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
                        _syncInterval = setInterval(_sync, 250);
                        ScrollTrigger_gsap.delayedCall(.5, (function() {
                            return ScrollTrigger_startup = 0;
                        }));
                        ScrollTrigger_addListener(ScrollTrigger_doc, "touchcancel", ScrollTrigger_passThrough);
                        ScrollTrigger_addListener(ScrollTrigger_body, "touchstart", ScrollTrigger_passThrough);
                        _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
                        _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);
                        ScrollTrigger_transformProp = ScrollTrigger_gsap.utils.checkPrefix("transform");
                        _stateProps.push(ScrollTrigger_transformProp);
                        ScrollTrigger_coreInitted = ScrollTrigger_getTime();
                        _resizeDelay = ScrollTrigger_gsap.delayedCall(.2, _refreshAll).pause();
                        _autoRefresh = [ ScrollTrigger_doc, "visibilitychange", function() {
                            var w = ScrollTrigger_win.innerWidth, h = ScrollTrigger_win.innerHeight;
                            if (ScrollTrigger_doc.hidden) {
                                _prevWidth = w;
                                _prevHeight = h;
                            } else if (_prevWidth !== w || _prevHeight !== h) _onResize();
                        }, ScrollTrigger_doc, "DOMContentLoaded", _refreshAll, ScrollTrigger_win, "load", _refreshAll, ScrollTrigger_win, "resize", _onResize ];
                        _iterateAutoRefresh(ScrollTrigger_addListener);
                        _triggers.forEach((function(trigger) {
                            return trigger.enable(0, 1);
                        }));
                        for (i = 0; i < _scrollers.length; i += 3) {
                            _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);
                            _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
                        }
                    }
                }
            };
            ScrollTrigger.config = function config(vars) {
                "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
                var ms = vars.syncInterval;
                ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
                "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);
                if ("autoRefreshEvents" in vars) {
                    _iterateAutoRefresh(ScrollTrigger_removeListener) || _iterateAutoRefresh(ScrollTrigger_addListener, vars.autoRefreshEvents || "none");
                    _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
                }
            };
            ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
                var t = Observer_getTarget(target), i = _scrollers.indexOf(t), isViewport = ScrollTrigger_isViewport(t);
                if (~i) _scrollers.splice(i, isViewport ? 6 : 2);
                if (vars) isViewport ? _proxies.unshift(ScrollTrigger_win, vars, ScrollTrigger_body, vars, ScrollTrigger_docEl, vars) : _proxies.unshift(t, vars);
            };
            ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
                _triggers.forEach((function(t) {
                    return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
                }));
            };
            ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
                var bounds = (ScrollTrigger_isString(element) ? Observer_getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;
                return horizontal ? bounds.right - offset > 0 && bounds.left + offset < ScrollTrigger_win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < ScrollTrigger_win.innerHeight;
            };
            ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
                ScrollTrigger_isString(element) && (element = Observer_getTarget(element));
                var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
                return horizontal ? (bounds.left + offset) / ScrollTrigger_win.innerWidth : (bounds.top + offset) / ScrollTrigger_win.innerHeight;
            };
            ScrollTrigger.killAll = function killAll(allowListeners) {
                _triggers.slice(0).forEach((function(t) {
                    return t.vars.id !== "ScrollSmoother" && t.kill();
                }));
                if (allowListeners !== true) {
                    var listeners = ScrollTrigger_listeners.killAll || [];
                    ScrollTrigger_listeners = {};
                    listeners.forEach((function(f) {
                        return f();
                    }));
                }
            };
            return ScrollTrigger;
        }();
        ScrollTrigger_ScrollTrigger.version = "3.12.1";
        ScrollTrigger_ScrollTrigger.saveStyles = function(targets) {
            return targets ? _toArray(targets).forEach((function(target) {
                if (target && target.style) {
                    var i = _savedStyles.indexOf(target);
                    i >= 0 && _savedStyles.splice(i, 5);
                    _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), ScrollTrigger_gsap.core.getCache(target), ScrollTrigger_context());
                }
            })) : _savedStyles;
        };
        ScrollTrigger_ScrollTrigger.revert = function(soft, media) {
            return _revertAll(!soft, media);
        };
        ScrollTrigger_ScrollTrigger.create = function(vars, animation) {
            return new ScrollTrigger_ScrollTrigger(vars, animation);
        };
        ScrollTrigger_ScrollTrigger.refresh = function(safe) {
            return safe ? _onResize() : (ScrollTrigger_coreInitted || ScrollTrigger_ScrollTrigger.register()) && _refreshAll(true);
        };
        ScrollTrigger_ScrollTrigger.update = function(force) {
            return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
        };
        ScrollTrigger_ScrollTrigger.clearScrollMemory = _clearScrollMemory;
        ScrollTrigger_ScrollTrigger.maxScroll = function(element, horizontal) {
            return _maxScroll(element, horizontal ? _horizontal : _vertical);
        };
        ScrollTrigger_ScrollTrigger.getScrollFunc = function(element, horizontal) {
            return _getScrollFunc(Observer_getTarget(element), horizontal ? _horizontal : _vertical);
        };
        ScrollTrigger_ScrollTrigger.getById = function(id) {
            return _ids[id];
        };
        ScrollTrigger_ScrollTrigger.getAll = function() {
            return _triggers.filter((function(t) {
                return t.vars.id !== "ScrollSmoother";
            }));
        };
        ScrollTrigger_ScrollTrigger.isScrolling = function() {
            return !!_lastScrollTime;
        };
        ScrollTrigger_ScrollTrigger.snapDirectional = _snapDirectional;
        ScrollTrigger_ScrollTrigger.addEventListener = function(type, callback) {
            var a = ScrollTrigger_listeners[type] || (ScrollTrigger_listeners[type] = []);
            ~a.indexOf(callback) || a.push(callback);
        };
        ScrollTrigger_ScrollTrigger.removeEventListener = function(type, callback) {
            var a = ScrollTrigger_listeners[type], i = a && a.indexOf(callback);
            i >= 0 && a.splice(i, 1);
        };
        ScrollTrigger_ScrollTrigger.batch = function(targets, vars) {
            var p, result = [], varsCopy = {}, interval = vars.interval || .016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback(type, callback) {
                var elements = [], triggers = [], delay = ScrollTrigger_gsap.delayedCall(interval, (function() {
                    callback(elements, triggers);
                    elements = [];
                    triggers = [];
                })).pause();
                return function(self) {
                    elements.length || delay.restart(true);
                    elements.push(self.trigger);
                    triggers.push(self);
                    batchMax <= elements.length && delay.progress(1);
                };
            };
            for (p in vars) varsCopy[p] = p.substr(0, 2) === "on" && ScrollTrigger_isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
            if (ScrollTrigger_isFunction(batchMax)) {
                batchMax = batchMax();
                ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "refresh", (function() {
                    return batchMax = vars.batchMax();
                }));
            }
            _toArray(targets).forEach((function(target) {
                var config = {};
                for (p in varsCopy) config[p] = varsCopy[p];
                config.trigger = target;
                result.push(ScrollTrigger_ScrollTrigger.create(config));
            }));
            return result;
        };
        var _inputIsFocused, _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
            current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
            return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
        }, _allowNativePanning = function _allowNativePanning(target, direction) {
            if (direction === true) target.style.removeProperty("touch-action"); else target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer_Observer.isTouch ? " pinch-zoom" : "") : "none";
            target === ScrollTrigger_docEl && _allowNativePanning(ScrollTrigger_body, direction);
        }, _overflow = {
            auto: 1,
            scroll: 1
        }, _nestedScroll = function _nestedScroll(_ref5) {
            var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;
            var cs, node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || ScrollTrigger_gsap.core.getCache(node), time = ScrollTrigger_getTime();
            if (!cache._isScrollT || time - cache._isScrollT > 2e3) {
                while (node && node !== ScrollTrigger_body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) node = node.parentNode;
                cache._isScroll = node && node !== target && !ScrollTrigger_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
                cache._isScrollT = time;
            }
            if (cache._isScroll || axis === "x") {
                event.stopPropagation();
                event._gsapAllow = true;
            }
        }, _inputObserver = function _inputObserver(target, type, inputs, nested) {
            return Observer_Observer.create({
                target,
                capture: true,
                debounce: false,
                lockAxis: true,
                type,
                onWheel: nested = nested && _nestedScroll,
                onPress: nested,
                onDrag: nested,
                onScroll: nested,
                onEnable: function onEnable() {
                    return inputs && ScrollTrigger_addListener(ScrollTrigger_doc, Observer_Observer.eventTypes[0], _captureInputs, false, true);
                },
                onDisable: function onDisable() {
                    return ScrollTrigger_removeListener(ScrollTrigger_doc, Observer_Observer.eventTypes[0], _captureInputs, true);
                }
            });
        }, _inputExp = /(input|label|select|textarea)/i, _captureInputs = function _captureInputs(e) {
            var isInput = _inputExp.test(e.target.tagName);
            if (isInput || _inputIsFocused) {
                e._gsapAllow = true;
                _inputIsFocused = isInput;
            }
        }, _getScrollNormalizer = function _getScrollNormalizer(vars) {
            ScrollTrigger_isObject(vars) || (vars = {});
            vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
            vars.type || (vars.type = "wheel,touch");
            vars.debounce = !!vars.debounce;
            vars.id = vars.id || "normalizer";
            var self, maxY, lastRefreshID, skipTouchMove, tween, startScrollX, startScrollY, onStopDelayedCall, _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, target = Observer_getTarget(vars.target) || ScrollTrigger_docEl, smoother = ScrollTrigger_gsap.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && Observer_getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale = 1, initialScale = (Observer_Observer.isTouch && ScrollTrigger_win.visualViewport ? ScrollTrigger_win.visualViewport.scale * ScrollTrigger_win.visualViewport.width : ScrollTrigger_win.outerWidth) / ScrollTrigger_win.innerWidth, wheelRefresh = 0, resolveMomentumDuration = ScrollTrigger_isFunction(momentum) ? function() {
                return momentum(self);
            } : function() {
                return momentum || 2.8;
            }, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove() {
                return skipTouchMove = false;
            }, scrollClampX = ScrollTrigger_passThrough, scrollClampY = ScrollTrigger_passThrough, updateClamps = function updateClamps() {
                maxY = _maxScroll(target, _vertical);
                scrollClampY = ScrollTrigger_clamp(_fixIOSBug ? 1 : 0, maxY);
                normalizeScrollX && (scrollClampX = ScrollTrigger_clamp(0, _maxScroll(target, _horizontal)));
                lastRefreshID = _refreshID;
            }, removeContentOffset = function removeContentOffset() {
                content._gsap.y = ScrollTrigger_round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
                content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
                scrollFuncY.offset = scrollFuncY.cacheID = 0;
            }, ignoreDrag = function ignoreDrag() {
                if (skipTouchMove) {
                    requestAnimationFrame(resumeTouchMove);
                    var offset = ScrollTrigger_round(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);
                    if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
                        scrollFuncY.offset = scroll - scrollFuncY.v;
                        var y = ScrollTrigger_round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
                        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
                        content._gsap.y = y + "px";
                        scrollFuncY.cacheID = _scrollers.cache;
                        _updateAll();
                    }
                    return true;
                }
                scrollFuncY.offset && removeContentOffset();
                skipTouchMove = true;
            }, onResize = function onResize() {
                updateClamps();
                if (tween.isActive() && tween.vars.scrollY > maxY) scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
            };
            content && ScrollTrigger_gsap.set(content, {
                y: "+=0"
            });
            vars.ignoreCheck = function(e) {
                return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
            };
            vars.onPress = function() {
                skipTouchMove = false;
                var prevScale = scale;
                scale = ScrollTrigger_round((ScrollTrigger_win.visualViewport && ScrollTrigger_win.visualViewport.scale || 1) / initialScale);
                tween.pause();
                prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
                startScrollX = scrollFuncX();
                startScrollY = scrollFuncY();
                updateClamps();
                lastRefreshID = _refreshID;
            };
            vars.onRelease = vars.onGestureStart = function(self, wasDragging) {
                scrollFuncY.offset && removeContentOffset();
                if (!wasDragging) onStopDelayedCall.restart(true); else {
                    _scrollers.cache++;
                    var currentScroll, endScroll, dur = resolveMomentumDuration();
                    if (normalizeScrollX) {
                        currentScroll = scrollFuncX();
                        endScroll = currentScroll + dur * .05 * -self.velocityX / .227;
                        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
                        tween.vars.scrollX = scrollClampX(endScroll);
                    }
                    currentScroll = scrollFuncY();
                    endScroll = currentScroll + dur * .05 * -self.velocityY / .227;
                    dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
                    tween.vars.scrollY = scrollClampY(endScroll);
                    tween.invalidate().duration(dur).play(.01);
                    if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) ScrollTrigger_gsap.to({}, {
                        onUpdate: onResize,
                        duration: dur
                    });
                }
                onRelease && onRelease(self);
            };
            vars.onWheel = function() {
                tween._ts && tween.pause();
                if (ScrollTrigger_getTime() - wheelRefresh > 1e3) {
                    lastRefreshID = 0;
                    wheelRefresh = ScrollTrigger_getTime();
                }
            };
            vars.onChange = function(self, dx, dy, xArray, yArray) {
                _refreshID !== lastRefreshID && updateClamps();
                dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1]));
                if (dy) {
                    scrollFuncY.offset && removeContentOffset();
                    var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);
                    isTouch && y !== yClamped && (startScrollY += yClamped - y);
                    scrollFuncY(yClamped);
                }
                (dy || dx) && _updateAll();
            };
            vars.onEnable = function() {
                _allowNativePanning(target, normalizeScrollX ? false : "x");
                ScrollTrigger_ScrollTrigger.addEventListener("refresh", onResize);
                ScrollTrigger_addListener(ScrollTrigger_win, "resize", onResize);
                if (scrollFuncY.smooth) {
                    scrollFuncY.target.style.scrollBehavior = "auto";
                    scrollFuncY.smooth = scrollFuncX.smooth = false;
                }
                inputObserver.enable();
            };
            vars.onDisable = function() {
                _allowNativePanning(target, true);
                ScrollTrigger_removeListener(ScrollTrigger_win, "resize", onResize);
                ScrollTrigger_ScrollTrigger.removeEventListener("refresh", onResize);
                inputObserver.kill();
            };
            vars.lockAxis = vars.lockAxis !== false;
            self = new Observer_Observer(vars);
            self.iOS = _fixIOSBug;
            _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
            _fixIOSBug && ScrollTrigger_gsap.ticker.add(ScrollTrigger_passThrough);
            onStopDelayedCall = self._dc;
            tween = ScrollTrigger_gsap.to(self, {
                ease: "power4",
                paused: true,
                scrollX: normalizeScrollX ? "+=0.1" : "+=0",
                scrollY: "+=0.1",
                modifiers: {
                    scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), (function() {
                        return tween.pause();
                    }))
                },
                onUpdate: _updateAll,
                onComplete: onStopDelayedCall.vars.onComplete
            });
            return self;
        };
        ScrollTrigger_ScrollTrigger.sort = function(func) {
            return _triggers.sort(func || function(a, b) {
                return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
            });
        };
        ScrollTrigger_ScrollTrigger.observe = function(vars) {
            return new Observer_Observer(vars);
        };
        ScrollTrigger_ScrollTrigger.normalizeScroll = function(vars) {
            if (typeof vars === "undefined") return ScrollTrigger_normalizer;
            if (vars === true && ScrollTrigger_normalizer) return ScrollTrigger_normalizer.enable();
            if (vars === false) return ScrollTrigger_normalizer && ScrollTrigger_normalizer.kill();
            var normalizer = vars instanceof Observer_Observer ? vars : _getScrollNormalizer(vars);
            ScrollTrigger_normalizer && ScrollTrigger_normalizer.target === normalizer.target && ScrollTrigger_normalizer.kill();
            ScrollTrigger_isViewport(normalizer.target) && (ScrollTrigger_normalizer = normalizer);
            return normalizer;
        };
        ScrollTrigger_ScrollTrigger.core = {
            _getVelocityProp,
            _inputObserver,
            _scrollers,
            _proxies,
            bridge: {
                ss: function ss() {
                    _lastScrollTime || ScrollTrigger_dispatch("scrollStart");
                    _lastScrollTime = ScrollTrigger_getTime();
                },
                ref: function ref() {
                    return _refreshing;
                }
            }
        };
        ScrollTrigger_getGSAP() && ScrollTrigger_gsap.registerPlugin(ScrollTrigger_ScrollTrigger);
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function locomotive_scroll_esm_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function locomotive_scroll_esm_createClass(Constructor, protoProps, staticProps) {
            if (protoProps) locomotive_scroll_esm_defineProperties(Constructor.prototype, protoProps);
            if (staticProps) locomotive_scroll_esm_defineProperties(Constructor, staticProps);
            return Constructor;
        }
        function _defineProperty(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
            }); else obj[key] = value;
            return obj;
        }
        function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                }));
                keys.push.apply(keys, symbols);
            }
            return keys;
        }
        function _objectSpread2(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) ownKeys(Object(source), true).forEach((function(key) {
                    _defineProperty(target, key, source[key]);
                })); else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); else ownKeys(Object(source)).forEach((function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                }));
            }
            return target;
        }
        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            };
            return _getPrototypeOf(o);
        }
        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
            };
            return _setPrototypeOf(o, p);
        }
        function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if (typeof Proxy === "function") return true;
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
                return true;
            } catch (e) {
                return false;
            }
        }
        function locomotive_scroll_esm_assertThisInitialized(self) {
            if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _possibleConstructorReturn(self, call) {
            if (call && (typeof call === "object" || typeof call === "function")) return call;
            return locomotive_scroll_esm_assertThisInitialized(self);
        }
        function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
                var result, Super = _getPrototypeOf(Derived);
                if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                } else result = Super.apply(this, arguments);
                return _possibleConstructorReturn(this, result);
            };
        }
        function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = _getPrototypeOf(object);
                if (object === null) break;
            }
            return object;
        }
        function locomotive_scroll_esm_get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) locomotive_scroll_esm_get = Reflect.get; else locomotive_scroll_esm_get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);
                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);
                if (desc.get) return desc.get.call(receiver);
                return desc.value;
            };
            return locomotive_scroll_esm_get(target, property, receiver || target);
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _iterableToArray(iter) {
            if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
        }
        function _iterableToArrayLimit(arr, i) {
            if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
            return arr2;
        }
        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var locomotive_scroll_esm_defaults = {
            el: document,
            name: "scroll",
            offset: [ 0, 0 ],
            repeat: false,
            smooth: false,
            initPosition: {
                x: 0,
                y: 0
            },
            direction: "vertical",
            gestureDirection: "vertical",
            reloadOnContextChange: false,
            lerp: .1,
            class: "is-inview",
            scrollbarContainer: false,
            scrollbarClass: "c-scrollbar",
            scrollingClass: "has-scroll-scrolling",
            draggingClass: "has-scroll-dragging",
            smoothClass: "has-scroll-smooth",
            initClass: "has-scroll-init",
            getSpeed: false,
            getDirection: false,
            scrollFromAnywhere: false,
            multiplier: 1,
            firefoxMultiplier: 50,
            touchMultiplier: 2,
            resetNativeScroll: true,
            tablet: {
                smooth: false,
                direction: "vertical",
                gestureDirection: "vertical",
                breakpoint: 1024
            },
            smartphone: {
                smooth: false,
                direction: "vertical",
                gestureDirection: "vertical"
            }
        };
        var _default = function() {
            function _default() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                _classCallCheck(this, _default);
                Object.assign(this, locomotive_scroll_esm_defaults, options);
                this.smartphone = locomotive_scroll_esm_defaults.smartphone;
                if (options.smartphone) Object.assign(this.smartphone, options.smartphone);
                this.tablet = locomotive_scroll_esm_defaults.tablet;
                if (options.tablet) Object.assign(this.tablet, options.tablet);
                this.namespace = "locomotive";
                this.html = document.documentElement;
                this.windowHeight = window.innerHeight;
                this.windowWidth = window.innerWidth;
                this.windowMiddle = {
                    x: this.windowWidth / 2,
                    y: this.windowHeight / 2
                };
                this.els = {};
                this.currentElements = {};
                this.listeners = {};
                this.hasScrollTicking = false;
                this.hasCallEventSet = false;
                this.checkScroll = this.checkScroll.bind(this);
                this.checkResize = this.checkResize.bind(this);
                this.checkEvent = this.checkEvent.bind(this);
                this.instance = {
                    scroll: {
                        x: 0,
                        y: 0
                    },
                    limit: {
                        x: this.html.offsetWidth,
                        y: this.html.offsetHeight
                    },
                    currentElements: this.currentElements
                };
                if (this.isMobile) if (this.isTablet) this.context = "tablet"; else this.context = "smartphone"; else this.context = "desktop";
                if (this.isMobile) this.direction = this[this.context].direction;
                if (this.direction === "horizontal") this.directionAxis = "x"; else this.directionAxis = "y";
                if (this.getDirection) this.instance.direction = null;
                if (this.getDirection) this.instance.speed = 0;
                this.html.classList.add(this.initClass);
                window.addEventListener("resize", this.checkResize, false);
            }
            locomotive_scroll_esm_createClass(_default, [ {
                key: "init",
                value: function init() {
                    this.initEvents();
                }
            }, {
                key: "checkScroll",
                value: function checkScroll() {
                    this.dispatchScroll();
                }
            }, {
                key: "checkResize",
                value: function checkResize() {
                    var _this = this;
                    if (!this.resizeTick) {
                        this.resizeTick = true;
                        requestAnimationFrame((function() {
                            _this.resize();
                            _this.resizeTick = false;
                        }));
                    }
                }
            }, {
                key: "resize",
                value: function resize() {}
            }, {
                key: "checkContext",
                value: function checkContext() {
                    if (!this.reloadOnContextChange) return;
                    this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint;
                    this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
                    var oldContext = this.context;
                    if (this.isMobile) if (this.isTablet) this.context = "tablet"; else this.context = "smartphone"; else this.context = "desktop";
                    if (oldContext != this.context) {
                        var oldSmooth = oldContext == "desktop" ? this.smooth : this[oldContext].smooth;
                        var newSmooth = this.context == "desktop" ? this.smooth : this[this.context].smooth;
                        if (oldSmooth != newSmooth) window.location.reload();
                    }
                }
            }, {
                key: "initEvents",
                value: function initEvents() {
                    var _this2 = this;
                    this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]"));
                    this.setScrollTo = this.setScrollTo.bind(this);
                    this.scrollToEls.forEach((function(el) {
                        el.addEventListener("click", _this2.setScrollTo, false);
                    }));
                }
            }, {
                key: "setScrollTo",
                value: function setScrollTo(event) {
                    event.preventDefault();
                    this.scrollTo(event.currentTarget.getAttribute("data-".concat(this.name, "-href")) || event.currentTarget.getAttribute("href"), {
                        offset: event.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
                    });
                }
            }, {
                key: "addElements",
                value: function addElements() {}
            }, {
                key: "detectElements",
                value: function detectElements(hasCallEventSet) {
                    var _this3 = this;
                    var scrollTop = this.instance.scroll.y;
                    var scrollBottom = scrollTop + this.windowHeight;
                    var scrollLeft = this.instance.scroll.x;
                    var scrollRight = scrollLeft + this.windowWidth;
                    Object.entries(this.els).forEach((function(_ref) {
                        var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], el = _ref2[1];
                        if (el && (!el.inView || hasCallEventSet)) if (_this3.direction === "horizontal") {
                            if (scrollRight >= el.left && scrollLeft < el.right) _this3.setInView(el, i);
                        } else if (scrollBottom >= el.top && scrollTop < el.bottom) _this3.setInView(el, i);
                        if (el && el.inView) if (_this3.direction === "horizontal") {
                            var width = el.right - el.left;
                            el.progress = (_this3.instance.scroll.x - (el.left - _this3.windowWidth)) / (width + _this3.windowWidth);
                            if (scrollRight < el.left || scrollLeft > el.right) _this3.setOutOfView(el, i);
                        } else {
                            var height = el.bottom - el.top;
                            el.progress = (_this3.instance.scroll.y - (el.top - _this3.windowHeight)) / (height + _this3.windowHeight);
                            if (scrollBottom < el.top || scrollTop > el.bottom) _this3.setOutOfView(el, i);
                        }
                    }));
                    this.hasScrollTicking = false;
                }
            }, {
                key: "setInView",
                value: function setInView(current, i) {
                    this.els[i].inView = true;
                    current.el.classList.add(current["class"]);
                    this.currentElements[i] = current;
                    if (current.call && this.hasCallEventSet) {
                        this.dispatchCall(current, "enter");
                        if (!current.repeat) this.els[i].call = false;
                    }
                }
            }, {
                key: "setOutOfView",
                value: function setOutOfView(current, i) {
                    var _this4 = this;
                    this.els[i].inView = false;
                    Object.keys(this.currentElements).forEach((function(el) {
                        el === i && delete _this4.currentElements[el];
                    }));
                    if (current.call && this.hasCallEventSet) this.dispatchCall(current, "exit");
                    if (current.repeat) current.el.classList.remove(current["class"]);
                }
            }, {
                key: "dispatchCall",
                value: function dispatchCall(current, way) {
                    this.callWay = way;
                    this.callValue = current.call.split(",").map((function(item) {
                        return item.trim();
                    }));
                    this.callObj = current;
                    if (this.callValue.length == 1) this.callValue = this.callValue[0];
                    var callEvent = new Event(this.namespace + "call");
                    this.el.dispatchEvent(callEvent);
                }
            }, {
                key: "dispatchScroll",
                value: function dispatchScroll() {
                    var scrollEvent = new Event(this.namespace + "scroll");
                    this.el.dispatchEvent(scrollEvent);
                }
            }, {
                key: "setEvents",
                value: function setEvents(event, func) {
                    if (!this.listeners[event]) this.listeners[event] = [];
                    var list = this.listeners[event];
                    list.push(func);
                    if (list.length === 1) this.el.addEventListener(this.namespace + event, this.checkEvent, false);
                    if (event === "call") {
                        this.hasCallEventSet = true;
                        this.detectElements(true);
                    }
                }
            }, {
                key: "unsetEvents",
                value: function unsetEvents(event, func) {
                    if (!this.listeners[event]) return;
                    var list = this.listeners[event];
                    var index = list.indexOf(func);
                    if (index < 0) return;
                    list.splice(index, 1);
                    if (list.index === 0) this.el.removeEventListener(this.namespace + event, this.checkEvent, false);
                }
            }, {
                key: "checkEvent",
                value: function checkEvent(event) {
                    var _this5 = this;
                    var name = event.type.replace(this.namespace, "");
                    var list = this.listeners[name];
                    if (!list || list.length === 0) return;
                    list.forEach((function(func) {
                        switch (name) {
                          case "scroll":
                            return func(_this5.instance);

                          case "call":
                            return func(_this5.callValue, _this5.callWay, _this5.callObj);

                          default:
                            return func();
                        }
                    }));
                }
            }, {
                key: "startScroll",
                value: function startScroll() {}
            }, {
                key: "stopScroll",
                value: function stopScroll() {}
            }, {
                key: "setScroll",
                value: function setScroll(x, y) {
                    this.instance.scroll = {
                        x: 0,
                        y: 0
                    };
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    var _this6 = this;
                    window.removeEventListener("resize", this.checkResize, false);
                    Object.keys(this.listeners).forEach((function(event) {
                        _this6.el.removeEventListener(_this6.namespace + event, _this6.checkEvent, false);
                    }));
                    this.listeners = {};
                    this.scrollToEls.forEach((function(el) {
                        el.removeEventListener("click", _this6.setScrollTo, false);
                    }));
                    this.html.classList.remove(this.initClass);
                }
            } ]);
            return _default;
        }();
        var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : {};
        function createCommonjsModule(fn, module) {
            return module = {
                exports: {}
            }, fn(module, module.exports), module.exports;
        }
        var smoothscroll = createCommonjsModule((function(module, exports) {
            (function() {
                function polyfill() {
                    var w = window;
                    var d = document;
                    if ("scrollBehavior" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) return;
                    var Element = w.HTMLElement || w.Element;
                    var SCROLL_TIME = 468;
                    var original = {
                        scroll: w.scroll || w.scrollTo,
                        scrollBy: w.scrollBy,
                        elementScroll: Element.prototype.scroll || scrollElement,
                        scrollIntoView: Element.prototype.scrollIntoView
                    };
                    var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;
                    function isMicrosoftBrowser(userAgent) {
                        var userAgentPatterns = [ "MSIE ", "Trident/", "Edge/" ];
                        return new RegExp(userAgentPatterns.join("|")).test(userAgent);
                    }
                    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;
                    function scrollElement(x, y) {
                        this.scrollLeft = x;
                        this.scrollTop = y;
                    }
                    function ease(k) {
                        return .5 * (1 - Math.cos(Math.PI * k));
                    }
                    function shouldBailOut(firstArg) {
                        if (firstArg === null || typeof firstArg !== "object" || firstArg.behavior === void 0 || firstArg.behavior === "auto" || firstArg.behavior === "instant") return true;
                        if (typeof firstArg === "object" && firstArg.behavior === "smooth") return false;
                        throw new TypeError("behavior member of ScrollOptions " + firstArg.behavior + " is not a valid value for enumeration ScrollBehavior.");
                    }
                    function hasScrollableSpace(el, axis) {
                        if (axis === "Y") return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;
                        if (axis === "X") return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;
                    }
                    function canOverflow(el, axis) {
                        var overflowValue = w.getComputedStyle(el, null)["overflow" + axis];
                        return overflowValue === "auto" || overflowValue === "scroll";
                    }
                    function isScrollable(el) {
                        var isScrollableY = hasScrollableSpace(el, "Y") && canOverflow(el, "Y");
                        var isScrollableX = hasScrollableSpace(el, "X") && canOverflow(el, "X");
                        return isScrollableY || isScrollableX;
                    }
                    function findScrollableParent(el) {
                        while (el !== d.body && isScrollable(el) === false) el = el.parentNode || el.host;
                        return el;
                    }
                    function step(context) {
                        var time = now();
                        var value;
                        var currentX;
                        var currentY;
                        var elapsed = (time - context.startTime) / SCROLL_TIME;
                        elapsed = elapsed > 1 ? 1 : elapsed;
                        value = ease(elapsed);
                        currentX = context.startX + (context.x - context.startX) * value;
                        currentY = context.startY + (context.y - context.startY) * value;
                        context.method.call(context.scrollable, currentX, currentY);
                        if (currentX !== context.x || currentY !== context.y) w.requestAnimationFrame(step.bind(w, context));
                    }
                    function smoothScroll(el, x, y) {
                        var scrollable;
                        var startX;
                        var startY;
                        var method;
                        var startTime = now();
                        if (el === d.body) {
                            scrollable = w;
                            startX = w.scrollX || w.pageXOffset;
                            startY = w.scrollY || w.pageYOffset;
                            method = original.scroll;
                        } else {
                            scrollable = el;
                            startX = el.scrollLeft;
                            startY = el.scrollTop;
                            method = scrollElement;
                        }
                        step({
                            scrollable,
                            method,
                            startTime,
                            startX,
                            startY,
                            x,
                            y
                        });
                    }
                    w.scroll = w.scrollTo = function() {
                        if (arguments[0] === void 0) return;
                        if (shouldBailOut(arguments[0]) === true) {
                            original.scroll.call(w, arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : w.scrollX || w.pageXOffset, arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset);
                            return;
                        }
                        smoothScroll.call(w, d.body, arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset);
                    };
                    w.scrollBy = function() {
                        if (arguments[0] === void 0) return;
                        if (shouldBailOut(arguments[0])) {
                            original.scrollBy.call(w, arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : 0, arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0);
                            return;
                        }
                        smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));
                    };
                    Element.prototype.scroll = Element.prototype.scrollTo = function() {
                        if (arguments[0] === void 0) return;
                        if (shouldBailOut(arguments[0]) === true) {
                            if (typeof arguments[0] === "number" && arguments[1] === void 0) throw new SyntaxError("Value could not be converted");
                            original.elementScroll.call(this, arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== "object" ? ~~arguments[0] : this.scrollLeft, arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop);
                            return;
                        }
                        var left = arguments[0].left;
                        var top = arguments[0].top;
                        smoothScroll.call(this, this, typeof left === "undefined" ? this.scrollLeft : ~~left, typeof top === "undefined" ? this.scrollTop : ~~top);
                    };
                    Element.prototype.scrollBy = function() {
                        if (arguments[0] === void 0) return;
                        if (shouldBailOut(arguments[0]) === true) {
                            original.elementScroll.call(this, arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);
                            return;
                        }
                        this.scroll({
                            left: ~~arguments[0].left + this.scrollLeft,
                            top: ~~arguments[0].top + this.scrollTop,
                            behavior: arguments[0].behavior
                        });
                    };
                    Element.prototype.scrollIntoView = function() {
                        if (shouldBailOut(arguments[0]) === true) {
                            original.scrollIntoView.call(this, arguments[0] === void 0 ? true : arguments[0]);
                            return;
                        }
                        var scrollableParent = findScrollableParent(this);
                        var parentRects = scrollableParent.getBoundingClientRect();
                        var clientRects = this.getBoundingClientRect();
                        if (scrollableParent !== d.body) {
                            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);
                            if (w.getComputedStyle(scrollableParent).position !== "fixed") w.scrollBy({
                                left: parentRects.left,
                                top: parentRects.top,
                                behavior: "smooth"
                            });
                        } else w.scrollBy({
                            left: clientRects.left,
                            top: clientRects.top,
                            behavior: "smooth"
                        });
                    };
                }
                module.exports = {
                    polyfill
                };
            })();
        }));
        smoothscroll.polyfill;
        var _default$1 = function(_Core) {
            _inherits(_default, _Core);
            var _super = _createSuper(_default);
            function _default() {
                var _this;
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                _classCallCheck(this, _default);
                _this = _super.call(this, options);
                if (_this.resetNativeScroll) {
                    if (history.scrollRestoration) history.scrollRestoration = "manual";
                    window.scrollTo(0, 0);
                }
                window.addEventListener("scroll", _this.checkScroll, false);
                if (window.smoothscrollPolyfill === void 0) {
                    window.smoothscrollPolyfill = smoothscroll;
                    window.smoothscrollPolyfill.polyfill();
                }
                return _this;
            }
            locomotive_scroll_esm_createClass(_default, [ {
                key: "init",
                value: function init() {
                    this.instance.scroll.y = window.pageYOffset;
                    this.addElements();
                    this.detectElements();
                    locomotive_scroll_esm_get(_getPrototypeOf(_default.prototype), "init", this).call(this);
                }
            }, {
                key: "checkScroll",
                value: function checkScroll() {
                    var _this2 = this;
                    locomotive_scroll_esm_get(_getPrototypeOf(_default.prototype), "checkScroll", this).call(this);
                    if (this.getDirection) this.addDirection();
                    if (this.getSpeed) {
                        this.addSpeed();
                        this.speedTs = Date.now();
                    }
                    this.instance.scroll.y = window.pageYOffset;
                    if (Object.entries(this.els).length) if (!this.hasScrollTicking) {
                        requestAnimationFrame((function() {
                            _this2.detectElements();
                        }));
                        this.hasScrollTicking = true;
                    }
                }
            }, {
                key: "addDirection",
                value: function addDirection() {
                    if (window.pageYOffset > this.instance.scroll.y) {
                        if (this.instance.direction !== "down") this.instance.direction = "down";
                    } else if (window.pageYOffset < this.instance.scroll.y) if (this.instance.direction !== "up") this.instance.direction = "up";
                }
            }, {
                key: "addSpeed",
                value: function addSpeed() {
                    if (window.pageYOffset != this.instance.scroll.y) this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs); else this.instance.speed = 0;
                }
            }, {
                key: "resize",
                value: function resize() {
                    if (Object.entries(this.els).length) {
                        this.windowHeight = window.innerHeight;
                        this.updateElements();
                    }
                }
            }, {
                key: "addElements",
                value: function addElements() {
                    var _this3 = this;
                    this.els = {};
                    var els = this.el.querySelectorAll("[data-" + this.name + "]");
                    els.forEach((function(el, index) {
                        el.getBoundingClientRect();
                        var cl = el.dataset[_this3.name + "Class"] || _this3["class"];
                        var id = typeof el.dataset[_this3.name + "Id"] === "string" ? el.dataset[_this3.name + "Id"] : index;
                        var top;
                        var left;
                        var offset = typeof el.dataset[_this3.name + "Offset"] === "string" ? el.dataset[_this3.name + "Offset"].split(",") : _this3.offset;
                        var repeat = el.dataset[_this3.name + "Repeat"];
                        var call = el.dataset[_this3.name + "Call"];
                        var target = el.dataset[_this3.name + "Target"];
                        var targetEl;
                        if (target !== void 0) targetEl = document.querySelector("".concat(target)); else targetEl = el;
                        var targetElBCR = targetEl.getBoundingClientRect();
                        top = targetElBCR.top + _this3.instance.scroll.y;
                        left = targetElBCR.left + _this3.instance.scroll.x;
                        var bottom = top + targetEl.offsetHeight;
                        var right = left + targetEl.offsetWidth;
                        if (repeat == "false") repeat = false; else if (repeat != void 0) repeat = true; else repeat = _this3.repeat;
                        var relativeOffset = _this3.getRelativeOffset(offset);
                        top += relativeOffset[0];
                        bottom -= relativeOffset[1];
                        var mappedEl = {
                            el,
                            targetEl,
                            id,
                            class: cl,
                            top,
                            bottom,
                            left,
                            right,
                            offset,
                            progress: 0,
                            repeat,
                            inView: false,
                            call
                        };
                        _this3.els[id] = mappedEl;
                        if (el.classList.contains(cl)) _this3.setInView(_this3.els[id], id);
                    }));
                }
            }, {
                key: "updateElements",
                value: function updateElements() {
                    var _this4 = this;
                    Object.entries(this.els).forEach((function(_ref) {
                        var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], el = _ref2[1];
                        var top = el.targetEl.getBoundingClientRect().top + _this4.instance.scroll.y;
                        var bottom = top + el.targetEl.offsetHeight;
                        var relativeOffset = _this4.getRelativeOffset(el.offset);
                        _this4.els[i].top = top + relativeOffset[0];
                        _this4.els[i].bottom = bottom - relativeOffset[1];
                    }));
                    this.hasScrollTicking = false;
                }
            }, {
                key: "getRelativeOffset",
                value: function getRelativeOffset(offset) {
                    var relativeOffset = [ 0, 0 ];
                    if (offset) for (var i = 0; i < offset.length; i++) if (typeof offset[i] == "string") if (offset[i].includes("%")) relativeOffset[i] = parseInt(offset[i].replace("%", "") * this.windowHeight / 100); else relativeOffset[i] = parseInt(offset[i]); else relativeOffset[i] = offset[i];
                    return relativeOffset;
                }
            }, {
                key: "scrollTo",
                value: function scrollTo(target) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var offset = parseInt(options.offset) || 0;
                    var callback = options.callback ? options.callback : false;
                    if (typeof target === "string") if (target === "top") target = this.html; else if (target === "bottom") target = this.html.offsetHeight - window.innerHeight; else {
                        target = document.querySelector(target);
                        if (!target) return;
                    } else if (typeof target === "number") target = parseInt(target); else if (target && target.tagName) ; else {
                        console.warn("`target` parameter is not valid");
                        return;
                    }
                    if (typeof target !== "number") offset = target.getBoundingClientRect().top + offset + this.instance.scroll.y; else offset = target + offset;
                    var isTargetReached = function isTargetReached() {
                        return parseInt(window.pageYOffset) === parseInt(offset);
                    };
                    if (callback) if (isTargetReached()) {
                        callback();
                        return;
                    } else {
                        var onScroll = function onScroll() {
                            if (isTargetReached()) {
                                window.removeEventListener("scroll", onScroll);
                                callback();
                            }
                        };
                        window.addEventListener("scroll", onScroll);
                    }
                    window.scrollTo({
                        top: offset,
                        behavior: options.duration === 0 ? "auto" : "smooth"
                    });
                }
            }, {
                key: "update",
                value: function update() {
                    this.addElements();
                    this.detectElements();
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    locomotive_scroll_esm_get(_getPrototypeOf(_default.prototype), "destroy", this).call(this);
                    window.removeEventListener("scroll", this.checkScroll, false);
                }
            } ]);
            return _default;
        }(_default);
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var locomotive_scroll_esm_hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (val === null || val === void 0) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) return false;
                var test1 = new String("abc");
                test1[5] = "de";
                if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
                var test2 = {};
                for (var i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                var order2 = Object.getOwnPropertyNames(test2).map((function(n) {
                    return test2[n];
                }));
                if (order2.join("") !== "0123456789") return false;
                var test3 = {};
                "abcdefghijklmnopqrst".split("").forEach((function(letter) {
                    test3[letter] = letter;
                }));
                if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
                return true;
            } catch (err) {
                return false;
            }
        }
        var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) if (locomotive_scroll_esm_hasOwnProperty.call(from, key)) to[key] = from[key];
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
                }
            }
            return to;
        };
        function E() {}
        E.prototype = {
            on: function(name, callback, ctx) {
                var e = this.e || (this.e = {});
                (e[name] || (e[name] = [])).push({
                    fn: callback,
                    ctx
                });
                return this;
            },
            once: function(name, callback, ctx) {
                var self = this;
                function listener() {
                    self.off(name, listener);
                    callback.apply(ctx, arguments);
                }
                listener._ = callback;
                return this.on(name, listener, ctx);
            },
            emit: function(name) {
                var data = [].slice.call(arguments, 1);
                var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                var i = 0;
                var len = evtArr.length;
                for (i; i < len; i++) evtArr[i].fn.apply(evtArr[i].ctx, data);
                return this;
            },
            off: function(name, callback) {
                var e = this.e || (this.e = {});
                var evts = e[name];
                var liveEvents = [];
                if (evts && callback) for (var i = 0, len = evts.length; i < len; i++) if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
                liveEvents.length ? e[name] = liveEvents : delete e[name];
                return this;
            }
        };
        var tinyEmitter = E;
        var lethargy = createCommonjsModule((function(module, exports) {
            (function() {
                var root;
                root = exports !== null ? exports : this;
                root.Lethargy = function() {
                    function Lethargy(stability, sensitivity, tolerance, delay) {
                        this.stability = stability != null ? Math.abs(stability) : 8;
                        this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;
                        this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;
                        this.delay = delay != null ? delay : 150;
                        this.lastUpDeltas = function() {
                            var i, ref, results;
                            results = [];
                            for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) results.push(null);
                            return results;
                        }.call(this);
                        this.lastDownDeltas = function() {
                            var i, ref, results;
                            results = [];
                            for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) results.push(null);
                            return results;
                        }.call(this);
                        this.deltasTimestamp = function() {
                            var i, ref, results;
                            results = [];
                            for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) results.push(null);
                            return results;
                        }.call(this);
                    }
                    Lethargy.prototype.check = function(e) {
                        var lastDelta;
                        e = e.originalEvent || e;
                        if (e.wheelDelta != null) lastDelta = e.wheelDelta; else if (e.deltaY != null) lastDelta = e.deltaY * -40; else if (e.detail != null || e.detail === 0) lastDelta = e.detail * -40;
                        this.deltasTimestamp.push(Date.now());
                        this.deltasTimestamp.shift();
                        if (lastDelta > 0) {
                            this.lastUpDeltas.push(lastDelta);
                            this.lastUpDeltas.shift();
                            return this.isInertia(1);
                        } else {
                            this.lastDownDeltas.push(lastDelta);
                            this.lastDownDeltas.shift();
                            return this.isInertia(-1);
                        }
                    };
                    Lethargy.prototype.isInertia = function(direction) {
                        var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;
                        lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;
                        if (lastDeltas[0] === null) return direction;
                        if (this.deltasTimestamp[this.stability * 2 - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[this.stability * 2 - 1]) return false;
                        lastDeltasOld = lastDeltas.slice(0, this.stability);
                        lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);
                        oldSum = lastDeltasOld.reduce((function(t, s) {
                            return t + s;
                        }));
                        newSum = lastDeltasNew.reduce((function(t, s) {
                            return t + s;
                        }));
                        oldAverage = oldSum / lastDeltasOld.length;
                        newAverage = newSum / lastDeltasNew.length;
                        if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && this.sensitivity < Math.abs(newAverage)) return direction; else return false;
                    };
                    Lethargy.prototype.showLastUpDeltas = function() {
                        return this.lastUpDeltas;
                    };
                    Lethargy.prototype.showLastDownDeltas = function() {
                        return this.lastDownDeltas;
                    };
                    return Lethargy;
                }();
            }).call(commonjsGlobal);
        }));
        var locomotive_scroll_esm_support = function getSupport() {
            return {
                hasWheelEvent: "onwheel" in document,
                hasMouseWheelEvent: "onmousewheel" in document,
                hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
                hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                hasPointer: !!window.navigator.msPointerEnabled,
                hasKeyDown: "onkeydown" in document,
                isFirefox: navigator.userAgent.indexOf("Firefox") > -1
            };
        }();
        var locomotive_scroll_esm_toString = Object.prototype.toString, hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        var bindallStandalone = function(object) {
            if (!object) return console.warn("bindAll requires at least one argument.");
            var functions = Array.prototype.slice.call(arguments, 1);
            if (functions.length === 0) for (var method in object) if (hasOwnProperty$1.call(object, method)) if (typeof object[method] == "function" && locomotive_scroll_esm_toString.call(object[method]) == "[object Function]") functions.push(method);
            for (var i = 0; i < functions.length; i++) {
                var f = functions[i];
                object[f] = bind(object[f], object);
            }
        };
        function bind(func, context) {
            return function() {
                return func.apply(context, arguments);
            };
        }
        var Lethargy = lethargy.Lethargy;
        var EVT_ID = "virtualscroll";
        var src = VirtualScroll;
        var keyCodes = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SPACE: 32
        };
        function VirtualScroll(options) {
            bindallStandalone(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown");
            this.el = window;
            if (options && options.el) {
                this.el = options.el;
                delete options.el;
            }
            this.options = objectAssign({
                mouseMultiplier: 1,
                touchMultiplier: 2,
                firefoxMultiplier: 15,
                keyStep: 120,
                preventTouch: false,
                unpreventTouchClass: "vs-touchmove-allowed",
                limitInertia: false,
                useKeyboard: true,
                useTouch: true
            }, options);
            if (this.options.limitInertia) this._lethargy = new Lethargy;
            this._emitter = new tinyEmitter;
            this._event = {
                y: 0,
                x: 0,
                deltaX: 0,
                deltaY: 0
            };
            this.touchStartX = null;
            this.touchStartY = null;
            this.bodyTouchAction = null;
            if (this.options.passive !== void 0) this.listenerOptions = {
                passive: this.options.passive
            };
        }
        VirtualScroll.prototype._notify = function(e) {
            var evt = this._event;
            evt.x += evt.deltaX;
            evt.y += evt.deltaY;
            this._emitter.emit(EVT_ID, {
                x: evt.x,
                y: evt.y,
                deltaX: evt.deltaX,
                deltaY: evt.deltaY,
                originalEvent: e
            });
        };
        VirtualScroll.prototype._onWheel = function(e) {
            var options = this.options;
            if (this._lethargy && this._lethargy.check(e) === false) return;
            var evt = this._event;
            evt.deltaX = e.wheelDeltaX || e.deltaX * -1;
            evt.deltaY = e.wheelDeltaY || e.deltaY * -1;
            if (locomotive_scroll_esm_support.isFirefox && e.deltaMode == 1) {
                evt.deltaX *= options.firefoxMultiplier;
                evt.deltaY *= options.firefoxMultiplier;
            }
            evt.deltaX *= options.mouseMultiplier;
            evt.deltaY *= options.mouseMultiplier;
            this._notify(e);
        };
        VirtualScroll.prototype._onMouseWheel = function(e) {
            if (this.options.limitInertia && this._lethargy.check(e) === false) return;
            var evt = this._event;
            evt.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0;
            evt.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta;
            this._notify(e);
        };
        VirtualScroll.prototype._onTouchStart = function(e) {
            var t = e.targetTouches ? e.targetTouches[0] : e;
            this.touchStartX = t.pageX;
            this.touchStartY = t.pageY;
        };
        VirtualScroll.prototype._onTouchMove = function(e) {
            var options = this.options;
            if (options.preventTouch && !e.target.classList.contains(options.unpreventTouchClass)) e.preventDefault();
            var evt = this._event;
            var t = e.targetTouches ? e.targetTouches[0] : e;
            evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;
            evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;
            this.touchStartX = t.pageX;
            this.touchStartY = t.pageY;
            this._notify(e);
        };
        VirtualScroll.prototype._onKeyDown = function(e) {
            var evt = this._event;
            evt.deltaX = evt.deltaY = 0;
            var windowHeight = window.innerHeight - 40;
            switch (e.keyCode) {
              case keyCodes.LEFT:
              case keyCodes.UP:
                evt.deltaY = this.options.keyStep;
                break;

              case keyCodes.RIGHT:
              case keyCodes.DOWN:
                evt.deltaY = -this.options.keyStep;
                break;

              case e.shiftKey:
                evt.deltaY = windowHeight;
                break;

              case keyCodes.SPACE:
                evt.deltaY = -windowHeight;
                break;

              default:
                return;
            }
            this._notify(e);
        };
        VirtualScroll.prototype._bind = function() {
            if (locomotive_scroll_esm_support.hasWheelEvent) this.el.addEventListener("wheel", this._onWheel, this.listenerOptions);
            if (locomotive_scroll_esm_support.hasMouseWheelEvent) this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions);
            if (locomotive_scroll_esm_support.hasTouch && this.options.useTouch) {
                this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions);
                this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions);
            }
            if (locomotive_scroll_esm_support.hasPointer && locomotive_scroll_esm_support.hasTouchWin) {
                this.bodyTouchAction = document.body.style.msTouchAction;
                document.body.style.msTouchAction = "none";
                this.el.addEventListener("MSPointerDown", this._onTouchStart, true);
                this.el.addEventListener("MSPointerMove", this._onTouchMove, true);
            }
            if (locomotive_scroll_esm_support.hasKeyDown && this.options.useKeyboard) document.addEventListener("keydown", this._onKeyDown);
        };
        VirtualScroll.prototype._unbind = function() {
            if (locomotive_scroll_esm_support.hasWheelEvent) this.el.removeEventListener("wheel", this._onWheel);
            if (locomotive_scroll_esm_support.hasMouseWheelEvent) this.el.removeEventListener("mousewheel", this._onMouseWheel);
            if (locomotive_scroll_esm_support.hasTouch) {
                this.el.removeEventListener("touchstart", this._onTouchStart);
                this.el.removeEventListener("touchmove", this._onTouchMove);
            }
            if (locomotive_scroll_esm_support.hasPointer && locomotive_scroll_esm_support.hasTouchWin) {
                document.body.style.msTouchAction = this.bodyTouchAction;
                this.el.removeEventListener("MSPointerDown", this._onTouchStart, true);
                this.el.removeEventListener("MSPointerMove", this._onTouchMove, true);
            }
            if (locomotive_scroll_esm_support.hasKeyDown && this.options.useKeyboard) document.removeEventListener("keydown", this._onKeyDown);
        };
        VirtualScroll.prototype.on = function(cb, ctx) {
            this._emitter.on(EVT_ID, cb, ctx);
            var events = this._emitter.e;
            if (events && events[EVT_ID] && events[EVT_ID].length === 1) this._bind();
        };
        VirtualScroll.prototype.off = function(cb, ctx) {
            this._emitter.off(EVT_ID, cb, ctx);
            var events = this._emitter.e;
            if (!events[EVT_ID] || events[EVT_ID].length <= 0) this._unbind();
        };
        VirtualScroll.prototype.reset = function() {
            var evt = this._event;
            evt.x = 0;
            evt.y = 0;
        };
        VirtualScroll.prototype.destroy = function() {
            this._emitter.off();
            this._unbind();
        };
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }
        function locomotive_scroll_esm_getTranslate(el) {
            var translate = {};
            if (!window.getComputedStyle) return;
            var style = getComputedStyle(el);
            var transform = style.transform || style.webkitTransform || style.mozTransform;
            var mat = transform.match(/^matrix3d\((.+)\)$/);
            if (mat) {
                translate.x = mat ? parseFloat(mat[1].split(", ")[12]) : 0;
                translate.y = mat ? parseFloat(mat[1].split(", ")[13]) : 0;
            } else {
                mat = transform.match(/^matrix\((.+)\)$/);
                translate.x = mat ? parseFloat(mat[1].split(", ")[4]) : 0;
                translate.y = mat ? parseFloat(mat[1].split(", ")[5]) : 0;
            }
            return translate;
        }
        function getParents(elem) {
            var parents = [];
            for (;elem && elem !== document; elem = elem.parentNode) parents.push(elem);
            return parents;
        }
        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = .001;
        var SUBDIVISION_PRECISION = 1e-7;
        var SUBDIVISION_MAX_ITERATIONS = 10;
        var kSplineTableSize = 11;
        var kSampleStepSize = 1 / (kSplineTableSize - 1);
        var float32ArraySupported = typeof Float32Array === "function";
        function A(aA1, aA2) {
            return 1 - 3 * aA2 + 3 * aA1;
        }
        function B(aA1, aA2) {
            return 3 * aA2 - 6 * aA1;
        }
        function C(aA1) {
            return 3 * aA1;
        }
        function calcBezier(aT, aA1, aA2) {
            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        }
        function getSlope(aT, aA1, aA2) {
            return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
        }
        function binarySubdivide(aX, aA, aB, mX1, mX2) {
            var currentX, currentT, i = 0;
            do {
                currentT = aA + (aB - aA) / 2;
                currentX = calcBezier(currentT, mX1, mX2) - aX;
                if (currentX > 0) aB = currentT; else aA = currentT;
            } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
            return currentT;
        }
        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }
        function LinearEasing(x) {
            return x;
        }
        var src$1 = function bezier(mX1, mY1, mX2, mY2) {
            if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) throw new Error("bezier x values must be in [0, 1] range");
            if (mX1 === mY1 && mX2 === mY2) return LinearEasing;
            var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
            for (var i = 0; i < kSplineTableSize; ++i) sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            function getTForX(aX) {
                var intervalStart = 0;
                var currentSample = 1;
                var lastSample = kSplineTableSize - 1;
                for (;currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
                --currentSample;
                var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
                var guessForT = intervalStart + dist * kSampleStepSize;
                var initialSlope = getSlope(guessForT, mX1, mX2);
                if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2); else if (initialSlope === 0) return guessForT; else return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
            return function BezierEasing(x) {
                if (x === 0) return 0;
                if (x === 1) return 1;
                return calcBezier(getTForX(x), mY1, mY2);
            };
        };
        var keyCodes$1 = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SPACE: 32,
            TAB: 9,
            PAGEUP: 33,
            PAGEDOWN: 34,
            HOME: 36,
            END: 35
        };
        var _default$2 = function(_Core) {
            _inherits(_default, _Core);
            var _super = _createSuper(_default);
            function _default() {
                var _this;
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                _classCallCheck(this, _default);
                if (history.scrollRestoration) history.scrollRestoration = "manual";
                window.scrollTo(0, 0);
                _this = _super.call(this, options);
                if (_this.inertia) _this.lerp = _this.inertia * .1;
                _this.isScrolling = false;
                _this.isDraggingScrollbar = false;
                _this.isTicking = false;
                _this.hasScrollTicking = false;
                _this.parallaxElements = {};
                _this.stop = false;
                _this.scrollbarContainer = options.scrollbarContainer;
                _this.checkKey = _this.checkKey.bind(locomotive_scroll_esm_assertThisInitialized(_this));
                window.addEventListener("keydown", _this.checkKey, false);
                return _this;
            }
            locomotive_scroll_esm_createClass(_default, [ {
                key: "init",
                value: function init() {
                    var _this2 = this;
                    this.html.classList.add(this.smoothClass);
                    this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction);
                    this.instance = _objectSpread2({
                        delta: {
                            x: this.initPosition.x,
                            y: this.initPosition.y
                        },
                        scroll: {
                            x: this.initPosition.x,
                            y: this.initPosition.y
                        }
                    }, this.instance);
                    this.vs = new src({
                        el: this.scrollFromAnywhere ? document : this.el,
                        mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : .4,
                        firefoxMultiplier: this.firefoxMultiplier,
                        touchMultiplier: this.touchMultiplier,
                        useKeyboard: false,
                        passive: true
                    });
                    this.vs.on((function(e) {
                        if (_this2.stop) return;
                        if (!_this2.isDraggingScrollbar) requestAnimationFrame((function() {
                            _this2.updateDelta(e);
                            if (!_this2.isScrolling) _this2.startScrolling();
                        }));
                    }));
                    this.setScrollLimit();
                    this.initScrollBar();
                    this.addSections();
                    this.addElements();
                    this.checkScroll(true);
                    this.transformElements(true, true);
                    locomotive_scroll_esm_get(_getPrototypeOf(_default.prototype), "init", this).call(this);
                }
            }, {
                key: "setScrollLimit",
                value: function setScrollLimit() {
                    this.instance.limit.y = this.el.offsetHeight - this.windowHeight;
                    if (this.direction === "horizontal") {
                        var totalWidth = 0;
                        var nodes = this.el.children;
                        for (var i = 0; i < nodes.length; i++) totalWidth += nodes[i].offsetWidth;
                        this.instance.limit.x = totalWidth - this.windowWidth;
                    }
                }
            }, {
                key: "startScrolling",
                value: function startScrolling() {
                    this.startScrollTs = Date.now();
                    this.isScrolling = true;
                    this.checkScroll();
                    this.html.classList.add(this.scrollingClass);
                }
            }, {
                key: "stopScrolling",
                value: function stopScrolling() {
                    cancelAnimationFrame(this.checkScrollRaf);
                    this.startScrollTs = void 0;
                    if (this.scrollToRaf) {
                        cancelAnimationFrame(this.scrollToRaf);
                        this.scrollToRaf = null;
                    }
                    this.isScrolling = false;
                    this.instance.scroll.y = Math.round(this.instance.scroll.y);
                    this.html.classList.remove(this.scrollingClass);
                }
            }, {
                key: "checkKey",
                value: function checkKey(e) {
                    var _this3 = this;
                    if (this.stop) {
                        if (e.keyCode == keyCodes$1.TAB) requestAnimationFrame((function() {
                            _this3.html.scrollTop = 0;
                            document.body.scrollTop = 0;
                            _this3.html.scrollLeft = 0;
                            document.body.scrollLeft = 0;
                        }));
                        return;
                    }
                    switch (e.keyCode) {
                      case keyCodes$1.TAB:
                        requestAnimationFrame((function() {
                            _this3.html.scrollTop = 0;
                            document.body.scrollTop = 0;
                            _this3.html.scrollLeft = 0;
                            document.body.scrollLeft = 0;
                            _this3.scrollTo(document.activeElement, {
                                offset: -window.innerHeight / 2
                            });
                        }));
                        break;

                      case keyCodes$1.UP:
                        if (this.isActiveElementScrollSensitive()) this.instance.delta[this.directionAxis] -= 240;
                        break;

                      case keyCodes$1.DOWN:
                        if (this.isActiveElementScrollSensitive()) this.instance.delta[this.directionAxis] += 240;
                        break;

                      case keyCodes$1.PAGEUP:
                        this.instance.delta[this.directionAxis] -= window.innerHeight;
                        break;

                      case keyCodes$1.PAGEDOWN:
                        this.instance.delta[this.directionAxis] += window.innerHeight;
                        break;

                      case keyCodes$1.HOME:
                        this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
                        break;

                      case keyCodes$1.END:
                        this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
                        break;

                      case keyCodes$1.SPACE:
                        if (this.isActiveElementScrollSensitive()) if (e.shiftKey) this.instance.delta[this.directionAxis] -= window.innerHeight; else this.instance.delta[this.directionAxis] += window.innerHeight;
                        break;

                      default:
                        return;
                    }
                    if (this.instance.delta[this.directionAxis] < 0) this.instance.delta[this.directionAxis] = 0;
                    if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis]) this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
                    this.stopScrolling();
                    this.isScrolling = true;
                    this.checkScroll();
                    this.html.classList.add(this.scrollingClass);
                }
            }, {
                key: "isActiveElementScrollSensitive",
                value: function isActiveElementScrollSensitive() {
                    return !(document.activeElement instanceof HTMLInputElement) && !(document.activeElement instanceof HTMLTextAreaElement) && !(document.activeElement instanceof HTMLButtonElement) && !(document.activeElement instanceof HTMLSelectElement);
                }
            }, {
                key: "checkScroll",
                value: function checkScroll() {
                    var _this4 = this;
                    var forced = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (forced || this.isScrolling || this.isDraggingScrollbar) {
                        if (!this.hasScrollTicking) {
                            this.checkScrollRaf = requestAnimationFrame((function() {
                                return _this4.checkScroll();
                            }));
                            this.hasScrollTicking = true;
                        }
                        this.updateScroll();
                        var distance = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]);
                        var timeSinceStart = Date.now() - this.startScrollTs;
                        if (!this.animatingScroll && timeSinceStart > 100 && (distance < .5 && this.instance.delta[this.directionAxis] != 0 || distance < .5 && this.instance.delta[this.directionAxis] == 0)) this.stopScrolling();
                        Object.entries(this.sections).forEach((function(_ref) {
                            var _ref2 = _slicedToArray(_ref, 2), section = (_ref2[0], _ref2[1]);
                            if (section.persistent || _this4.instance.scroll[_this4.directionAxis] > section.offset[_this4.directionAxis] && _this4.instance.scroll[_this4.directionAxis] < section.limit[_this4.directionAxis]) {
                                if (_this4.direction === "horizontal") _this4.transform(section.el, -_this4.instance.scroll[_this4.directionAxis], 0); else _this4.transform(section.el, 0, -_this4.instance.scroll[_this4.directionAxis]);
                                if (!section.inView) {
                                    section.inView = true;
                                    section.el.style.opacity = 1;
                                    section.el.style.pointerEvents = "all";
                                    section.el.setAttribute("data-".concat(_this4.name, "-section-inview"), "");
                                }
                            } else {
                                if (section.inView || forced) {
                                    section.inView = false;
                                    section.el.style.opacity = 0;
                                    section.el.style.pointerEvents = "none";
                                    section.el.removeAttribute("data-".concat(_this4.name, "-section-inview"));
                                }
                                _this4.transform(section.el, 0, 0);
                            }
                        }));
                        if (this.getDirection) this.addDirection();
                        if (this.getSpeed) {
                            this.addSpeed();
                            this.speedTs = Date.now();
                        }
                        this.detectElements();
                        this.transformElements();
                        if (this.hasScrollbar) {
                            var scrollBarTranslation = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
                            if (this.direction === "horizontal") this.transform(this.scrollbarThumb, scrollBarTranslation, 0); else this.transform(this.scrollbarThumb, 0, scrollBarTranslation);
                        }
                        locomotive_scroll_esm_get(_getPrototypeOf(_default.prototype), "checkScroll", this).call(this);
                        this.hasScrollTicking = false;
                    }
                }
            }, {
                key: "resize",
                value: function resize() {
                    this.windowHeight = window.innerHeight;
                    this.windowWidth = window.innerWidth;
                    this.checkContext();
                    this.windowMiddle = {
                        x: this.windowWidth / 2,
                        y: this.windowHeight / 2
                    };
                    this.update();
                }
            }, {
                key: "updateDelta",
                value: function updateDelta(e) {
                    var delta;
                    var gestureDirection = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
                    if (gestureDirection === "both") delta = e.deltaX + e.deltaY; else if (gestureDirection === "vertical") delta = e.deltaY; else if (gestureDirection === "horizontal") delta = e.deltaX; else delta = e.deltaY;
                    this.instance.delta[this.directionAxis] -= delta * this.multiplier;
                    if (this.instance.delta[this.directionAxis] < 0) this.instance.delta[this.directionAxis] = 0;
                    if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis]) this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
                }
            }, {
                key: "updateScroll",
                value: function updateScroll(e) {
                    if (this.isScrolling || this.isDraggingScrollbar) this.instance.scroll[this.directionAxis] = lerp(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp); else if (this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis]) this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]); else if (this.instance.scroll.y < 0) this.setScroll(this.instance.scroll[this.directionAxis], 0); else this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis]);
                }
            }, {
                key: "addDirection",
                value: function addDirection() {
                    if (this.instance.delta.y > this.instance.scroll.y) {
                        if (this.instance.direction !== "down") this.instance.direction = "down";
                    } else if (this.instance.delta.y < this.instance.scroll.y) if (this.instance.direction !== "up") this.instance.direction = "up";
                    if (this.instance.delta.x > this.instance.scroll.x) {
                        if (this.instance.direction !== "right") this.instance.direction = "right";
                    } else if (this.instance.delta.x < this.instance.scroll.x) if (this.instance.direction !== "left") this.instance.direction = "left";
                }
            }, {
                key: "addSpeed",
                value: function addSpeed() {
                    if (this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis]) this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs); else this.instance.speed = 0;
                }
            }, {
                key: "initScrollBar",
                value: function initScrollBar() {
                    this.scrollbar = document.createElement("span");
                    this.scrollbarThumb = document.createElement("span");
                    this.scrollbar.classList.add("".concat(this.scrollbarClass));
                    this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb"));
                    this.scrollbar.append(this.scrollbarThumb);
                    if (this.scrollbarContainer) this.scrollbarContainer.append(this.scrollbar); else document.body.append(this.scrollbar);
                    this.getScrollBar = this.getScrollBar.bind(this);
                    this.releaseScrollBar = this.releaseScrollBar.bind(this);
                    this.moveScrollBar = this.moveScrollBar.bind(this);
                    this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar);
                    window.addEventListener("mouseup", this.releaseScrollBar);
                    window.addEventListener("mousemove", this.moveScrollBar);
                    this.hasScrollbar = false;
                    if (this.direction == "horizontal") {
                        if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return;
                    } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                    this.hasScrollbar = true;
                    this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
                    this.scrollbarHeight = this.scrollbarBCR.height;
                    this.scrollbarWidth = this.scrollbarBCR.width;
                    if (this.direction === "horizontal") this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px"); else this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
                    this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
                    this.scrollBarLimit = {
                        x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                        y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                    };
                }
            }, {
                key: "reinitScrollBar",
                value: function reinitScrollBar() {
                    this.hasScrollbar = false;
                    if (this.direction == "horizontal") {
                        if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return;
                    } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                    this.hasScrollbar = true;
                    this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
                    this.scrollbarHeight = this.scrollbarBCR.height;
                    this.scrollbarWidth = this.scrollbarBCR.width;
                    if (this.direction === "horizontal") this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px"); else this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
                    this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
                    this.scrollBarLimit = {
                        x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                        y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                    };
                }
            }, {
                key: "destroyScrollBar",
                value: function destroyScrollBar() {
                    this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar);
                    window.removeEventListener("mouseup", this.releaseScrollBar);
                    window.removeEventListener("mousemove", this.moveScrollBar);
                    this.scrollbar.remove();
                }
            }, {
                key: "getScrollBar",
                value: function getScrollBar(e) {
                    this.isDraggingScrollbar = true;
                    this.checkScroll();
                    this.html.classList.remove(this.scrollingClass);
                    this.html.classList.add(this.draggingClass);
                }
            }, {
                key: "releaseScrollBar",
                value: function releaseScrollBar(e) {
                    this.isDraggingScrollbar = false;
                    if (this.isScrolling) this.html.classList.add(this.scrollingClass);
                    this.html.classList.remove(this.draggingClass);
                }
            }, {
                key: "moveScrollBar",
                value: function moveScrollBar(e) {
                    var _this5 = this;
                    if (this.isDraggingScrollbar) requestAnimationFrame((function() {
                        var x = (e.clientX - _this5.scrollbarBCR.left) * 100 / _this5.scrollbarWidth * _this5.instance.limit.x / 100;
                        var y = (e.clientY - _this5.scrollbarBCR.top) * 100 / _this5.scrollbarHeight * _this5.instance.limit.y / 100;
                        if (y > 0 && y < _this5.instance.limit.y) _this5.instance.delta.y = y;
                        if (x > 0 && x < _this5.instance.limit.x) _this5.instance.delta.x = x;
                    }));
                }
            }, {
                key: "addElements",
                value: function addElements() {
                    var _this6 = this;
                    this.els = {};
                    this.parallaxElements = {};
                    var els = this.el.querySelectorAll("[data-".concat(this.name, "]"));
                    els.forEach((function(el, index) {
                        var targetParents = getParents(el);
                        var section = Object.entries(_this6.sections).map((function(_ref3) {
                            var _ref4 = _slicedToArray(_ref3, 2), section = (_ref4[0], _ref4[1]);
                            return section;
                        })).find((function(section) {
                            return targetParents.includes(section.el);
                        }));
                        var cl = el.dataset[_this6.name + "Class"] || _this6["class"];
                        var id = typeof el.dataset[_this6.name + "Id"] === "string" ? el.dataset[_this6.name + "Id"] : "el" + index;
                        var top;
                        var left;
                        var repeat = el.dataset[_this6.name + "Repeat"];
                        var call = el.dataset[_this6.name + "Call"];
                        var position = el.dataset[_this6.name + "Position"];
                        var delay = el.dataset[_this6.name + "Delay"];
                        var direction = el.dataset[_this6.name + "Direction"];
                        var sticky = typeof el.dataset[_this6.name + "Sticky"] === "string";
                        var speed = el.dataset[_this6.name + "Speed"] ? parseFloat(el.dataset[_this6.name + "Speed"]) / 10 : false;
                        var offset = typeof el.dataset[_this6.name + "Offset"] === "string" ? el.dataset[_this6.name + "Offset"].split(",") : _this6.offset;
                        var target = el.dataset[_this6.name + "Target"];
                        var targetEl;
                        if (target !== void 0) targetEl = document.querySelector("".concat(target)); else targetEl = el;
                        var targetElBCR = targetEl.getBoundingClientRect();
                        if (section === null) {
                            top = targetElBCR.top + _this6.instance.scroll.y - locomotive_scroll_esm_getTranslate(targetEl).y;
                            left = targetElBCR.left + _this6.instance.scroll.x - locomotive_scroll_esm_getTranslate(targetEl).x;
                        } else if (!section.inView) {
                            top = targetElBCR.top - locomotive_scroll_esm_getTranslate(section.el).y - locomotive_scroll_esm_getTranslate(targetEl).y;
                            left = targetElBCR.left - locomotive_scroll_esm_getTranslate(section.el).x - locomotive_scroll_esm_getTranslate(targetEl).x;
                        } else {
                            top = targetElBCR.top + _this6.instance.scroll.y - locomotive_scroll_esm_getTranslate(targetEl).y;
                            left = targetElBCR.left + _this6.instance.scroll.x - locomotive_scroll_esm_getTranslate(targetEl).x;
                        }
                        var bottom = top + targetEl.offsetHeight;
                        var right = left + targetEl.offsetWidth;
                        var middle = {
                            x: (right - left) / 2 + left,
                            y: (bottom - top) / 2 + top
                        };
                        if (sticky) {
                            var elBCR = el.getBoundingClientRect();
                            var elTop = elBCR.top;
                            var elLeft = elBCR.left;
                            var elDistance = {
                                x: elLeft - left,
                                y: elTop - top
                            };
                            top += window.innerHeight;
                            left += window.innerWidth;
                            bottom = elTop + targetEl.offsetHeight - el.offsetHeight - elDistance[_this6.directionAxis];
                            right = elLeft + targetEl.offsetWidth - el.offsetWidth - elDistance[_this6.directionAxis];
                            middle = {
                                x: (right - left) / 2 + left,
                                y: (bottom - top) / 2 + top
                            };
                        }
                        if (repeat == "false") repeat = false; else if (repeat != void 0) repeat = true; else repeat = _this6.repeat;
                        var relativeOffset = [ 0, 0 ];
                        if (offset) if (_this6.direction === "horizontal") {
                            for (var i = 0; i < offset.length; i++) if (typeof offset[i] == "string") if (offset[i].includes("%")) relativeOffset[i] = parseInt(offset[i].replace("%", "") * _this6.windowWidth / 100); else relativeOffset[i] = parseInt(offset[i]); else relativeOffset[i] = offset[i];
                            left += relativeOffset[0];
                            right -= relativeOffset[1];
                        } else {
                            for (i = 0; i < offset.length; i++) if (typeof offset[i] == "string") if (offset[i].includes("%")) relativeOffset[i] = parseInt(offset[i].replace("%", "") * _this6.windowHeight / 100); else relativeOffset[i] = parseInt(offset[i]); else relativeOffset[i] = offset[i];
                            top += relativeOffset[0];
                            bottom -= relativeOffset[1];
                        }
                        var mappedEl = {
                            el,
                            id,
                            class: cl,
                            section,
                            top,
                            middle,
                            bottom,
                            left,
                            right,
                            offset,
                            progress: 0,
                            repeat,
                            inView: false,
                            call,
                            speed,
                            delay,
                            position,
                            target: targetEl,
                            direction,
                            sticky
                        };
                        _this6.els[id] = mappedEl;
                        if (el.classList.contains(cl)) _this6.setInView(_this6.els[id], id);
                        if (speed !== false || sticky) _this6.parallaxElements[id] = mappedEl;
                    }));
                }
            }, {
                key: "addSections",
                value: function addSections() {
                    var _this7 = this;
                    this.sections = {};
                    var sections = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
                    if (sections.length === 0) sections = [ this.el ];
                    sections.forEach((function(section, index) {
                        var id = typeof section.dataset[_this7.name + "Id"] === "string" ? section.dataset[_this7.name + "Id"] : "section" + index;
                        var sectionBCR = section.getBoundingClientRect();
                        var offset = {
                            x: sectionBCR.left - window.innerWidth * 1.5 - locomotive_scroll_esm_getTranslate(section).x,
                            y: sectionBCR.top - window.innerHeight * 1.5 - locomotive_scroll_esm_getTranslate(section).y
                        };
                        var limit = {
                            x: offset.x + sectionBCR.width + window.innerWidth * 2,
                            y: offset.y + sectionBCR.height + window.innerHeight * 2
                        };
                        var persistent = typeof section.dataset[_this7.name + "Persistent"] === "string";
                        section.setAttribute("data-scroll-section-id", id);
                        var mappedSection = {
                            el: section,
                            offset,
                            limit,
                            inView: false,
                            persistent,
                            id
                        };
                        _this7.sections[id] = mappedSection;
                    }));
                }
            }, {
                key: "transform",
                value: function transform(element, x, y, delay) {
                    var transform;
                    if (!delay) transform = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(x, ",").concat(y, ",0,1)"); else {
                        var start = locomotive_scroll_esm_getTranslate(element);
                        var lerpX = lerp(start.x, x, delay);
                        var lerpY = lerp(start.y, y, delay);
                        transform = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(lerpX, ",").concat(lerpY, ",0,1)");
                    }
                    element.style.webkitTransform = transform;
                    element.style.msTransform = transform;
                    element.style.transform = transform;
                }
            }, {
                key: "transformElements",
                value: function transformElements(isForced) {
                    var _this8 = this;
                    var setAllElements = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    var scrollRight = this.instance.scroll.x + this.windowWidth;
                    var scrollBottom = this.instance.scroll.y + this.windowHeight;
                    var scrollMiddle = {
                        x: this.instance.scroll.x + this.windowMiddle.x,
                        y: this.instance.scroll.y + this.windowMiddle.y
                    };
                    Object.entries(this.parallaxElements).forEach((function(_ref5) {
                        var _ref6 = _slicedToArray(_ref5, 2), current = (_ref6[0], _ref6[1]);
                        var transformDistance = false;
                        if (isForced) transformDistance = 0;
                        if (current.inView || setAllElements) switch (current.position) {
                          case "top":
                            transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                            break;

                          case "elementTop":
                            transformDistance = (scrollBottom - current.top) * -current.speed;
                            break;

                          case "bottom":
                            transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollBottom + _this8.windowHeight) * current.speed;
                            break;

                          case "left":
                            transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                            break;

                          case "elementLeft":
                            transformDistance = (scrollRight - current.left) * -current.speed;
                            break;

                          case "right":
                            transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollRight + _this8.windowHeight) * current.speed;
                            break;

                          default:
                            transformDistance = (scrollMiddle[_this8.directionAxis] - current.middle[_this8.directionAxis]) * -current.speed;
                            break;
                        }
                        if (current.sticky) if (current.inView) if (_this8.direction === "horizontal") transformDistance = _this8.instance.scroll.x - current.left + window.innerWidth; else transformDistance = _this8.instance.scroll.y - current.top + window.innerHeight; else if (_this8.direction === "horizontal") if (_this8.instance.scroll.x < current.left - window.innerWidth && _this8.instance.scroll.x < current.left - window.innerWidth / 2) transformDistance = 0; else if (_this8.instance.scroll.x > current.right && _this8.instance.scroll.x > current.right + 100) transformDistance = current.right - current.left + window.innerWidth; else transformDistance = false; else if (_this8.instance.scroll.y < current.top - window.innerHeight && _this8.instance.scroll.y < current.top - window.innerHeight / 2) transformDistance = 0; else if (_this8.instance.scroll.y > current.bottom && _this8.instance.scroll.y > current.bottom + 100) transformDistance = current.bottom - current.top + window.innerHeight; else transformDistance = false;
                        if (transformDistance !== false) if (current.direction === "horizontal" || _this8.direction === "horizontal" && current.direction !== "vertical") _this8.transform(current.el, transformDistance, 0, isForced ? false : current.delay); else _this8.transform(current.el, 0, transformDistance, isForced ? false : current.delay);
                    }));
                }
            }, {
                key: "scrollTo",
                value: function scrollTo(target) {
                    var _this9 = this;
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var offset = parseInt(options.offset) || 0;
                    var duration = !isNaN(parseInt(options.duration)) ? parseInt(options.duration) : 1e3;
                    var easing = options.easing || [ .25, 0, .35, 1 ];
                    var disableLerp = options.disableLerp ? true : false;
                    var callback = options.callback ? options.callback : false;
                    easing = src$1.apply(void 0, _toConsumableArray(easing));
                    if (typeof target === "string") if (target === "top") target = 0; else if (target === "bottom") target = this.instance.limit.y; else if (target === "left") target = 0; else if (target === "right") target = this.instance.limit.x; else {
                        target = document.querySelector(target);
                        if (!target) return;
                    } else if (typeof target === "number") target = parseInt(target); else if (target && target.tagName) ; else {
                        console.warn("`target` parameter is not valid");
                        return;
                    }
                    if (typeof target !== "number") {
                        var targetInScope = getParents(target).includes(this.el);
                        if (!targetInScope) return;
                        var targetBCR = target.getBoundingClientRect();
                        var offsetTop = targetBCR.top;
                        var offsetLeft = targetBCR.left;
                        var targetParents = getParents(target);
                        var parentSection = targetParents.find((function(candidate) {
                            return Object.entries(_this9.sections).map((function(_ref7) {
                                var _ref8 = _slicedToArray(_ref7, 2), section = (_ref8[0], _ref8[1]);
                                return section;
                            })).find((function(section) {
                                return section.el == candidate;
                            }));
                        }));
                        var parentSectionOffset = 0;
                        if (parentSection) parentSectionOffset = locomotive_scroll_esm_getTranslate(parentSection)[this.directionAxis]; else parentSectionOffset = -this.instance.scroll[this.directionAxis];
                        if (this.direction === "horizontal") offset = offsetLeft + offset - parentSectionOffset; else offset = offsetTop + offset - parentSectionOffset;
                    } else offset = target + offset;
                    var scrollStart = parseFloat(this.instance.delta[this.directionAxis]);
                    var scrollTarget = Math.max(0, Math.min(offset, this.instance.limit[this.directionAxis]));
                    var scrollDiff = scrollTarget - scrollStart;
                    var render = function render(p) {
                        if (disableLerp) if (_this9.direction === "horizontal") _this9.setScroll(scrollStart + scrollDiff * p, _this9.instance.delta.y); else _this9.setScroll(_this9.instance.delta.x, scrollStart + scrollDiff * p); else _this9.instance.delta[_this9.directionAxis] = scrollStart + scrollDiff * p;
                    };
                    this.animatingScroll = true;
                    this.stopScrolling();
                    this.startScrolling();
                    var start = Date.now();
                    var loop = function loop() {
                        var p = (Date.now() - start) / duration;
                        if (p > 1) {
                            render(1);
                            _this9.animatingScroll = false;
                            if (duration == 0) _this9.update();
                            if (callback) callback();
                        } else {
                            _this9.scrollToRaf = requestAnimationFrame(loop);
                            render(easing(p));
                        }
                    };
                    loop();
                }
            }, {
                key: "update",
                value: function update() {
                    this.setScrollLimit();
                    this.addSections();
                    this.addElements();
                    this.detectElements();
                    this.updateScroll();
                    this.transformElements(true);
                    this.reinitScrollBar();
                    this.checkScroll(true);
                }
            }, {
                key: "startScroll",
                value: function startScroll() {
                    this.stop = false;
                }
            }, {
                key: "stopScroll",
                value: function stopScroll() {
                    this.stop = true;
                }
            }, {
                key: "setScroll",
                value: function setScroll(x, y) {
                    this.instance = _objectSpread2(_objectSpread2({}, this.instance), {}, {
                        scroll: {
                            x,
                            y
                        },
                        delta: {
                            x,
                            y
                        },
                        speed: 0
                    });
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    locomotive_scroll_esm_get(_getPrototypeOf(_default.prototype), "destroy", this).call(this);
                    this.stopScrolling();
                    this.html.classList.remove(this.smoothClass);
                    this.vs.destroy();
                    this.destroyScrollBar();
                    window.removeEventListener("keydown", this.checkKey, false);
                }
            } ]);
            return _default;
        }(_default);
        var Smooth = function() {
            function Smooth() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                _classCallCheck(this, Smooth);
                this.options = options;
                Object.assign(this, locomotive_scroll_esm_defaults, options);
                this.smartphone = locomotive_scroll_esm_defaults.smartphone;
                if (options.smartphone) Object.assign(this.smartphone, options.smartphone);
                this.tablet = locomotive_scroll_esm_defaults.tablet;
                if (options.tablet) Object.assign(this.tablet, options.tablet);
                if (!this.smooth && this.direction == "horizontal") console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible");
                if (!this.tablet.smooth && this.tablet.direction == "horizontal") console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (tablet)");
                if (!this.smartphone.smooth && this.smartphone.direction == "horizontal") console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (smartphone)");
                this.init();
            }
            locomotive_scroll_esm_createClass(Smooth, [ {
                key: "init",
                value: function init() {
                    this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint;
                    this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint;
                    if (this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet) this.scroll = new _default$2(this.options); else this.scroll = new _default$1(this.options);
                    this.scroll.init();
                    if (window.location.hash) {
                        var id = window.location.hash.slice(1, window.location.hash.length);
                        var target = document.getElementById(id);
                        if (target) this.scroll.scrollTo(target);
                    }
                }
            }, {
                key: "update",
                value: function update() {
                    this.scroll.update();
                }
            }, {
                key: "start",
                value: function start() {
                    this.scroll.startScroll();
                }
            }, {
                key: "stop",
                value: function stop() {
                    this.scroll.stopScroll();
                }
            }, {
                key: "scrollTo",
                value: function scrollTo(target, options) {
                    this.scroll.scrollTo(target, options);
                }
            }, {
                key: "setScroll",
                value: function setScroll(x, y) {
                    this.scroll.setScroll(x, y);
                }
            }, {
                key: "on",
                value: function on(event, func) {
                    this.scroll.setEvents(event, func);
                }
            }, {
                key: "off",
                value: function off(event, func) {
                    this.scroll.unsetEvents(event, func);
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    this.scroll.destroy();
                }
            } ]);
            return Smooth;
        }();
        null && function() {
            function Native() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                _classCallCheck(this, Native);
                this.options = options;
                Object.assign(this, locomotive_scroll_esm_defaults, options);
                this.smartphone = locomotive_scroll_esm_defaults.smartphone;
                if (options.smartphone) Object.assign(this.smartphone, options.smartphone);
                this.tablet = locomotive_scroll_esm_defaults.tablet;
                if (options.tablet) Object.assign(this.tablet, options.tablet);
                this.init();
            }
            locomotive_scroll_esm_createClass(Native, [ {
                key: "init",
                value: function init() {
                    this.scroll = new _default$1(this.options);
                    this.scroll.init();
                    if (window.location.hash) {
                        var id = window.location.hash.slice(1, window.location.hash.length);
                        var target = document.getElementById(id);
                        if (target) this.scroll.scrollTo(target);
                    }
                }
            }, {
                key: "update",
                value: function update() {
                    this.scroll.update();
                }
            }, {
                key: "start",
                value: function start() {
                    this.scroll.startScroll();
                }
            }, {
                key: "stop",
                value: function stop() {
                    this.scroll.stopScroll();
                }
            }, {
                key: "scrollTo",
                value: function scrollTo(target, options) {
                    this.scroll.scrollTo(target, options);
                }
            }, {
                key: "setScroll",
                value: function setScroll(x, y) {
                    this.scroll.setScroll(x, y);
                }
            }, {
                key: "on",
                value: function on(event, func) {
                    this.scroll.setEvents(event, func);
                }
            }, {
                key: "off",
                value: function off(event, func) {
                    this.scroll.unsetEvents(event, func);
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    this.scroll.destroy();
                }
            } ]);
        }();
        const locomotive_scroll_esm = Smooth;
        gsapWithCSS.registerPlugin(ScrollTrigger_ScrollTrigger);
        const smoothScrolling = new locomotive_scroll_esm({
            el: document.querySelector("[data-scroll-container]"),
            smooth: true
        });
        smoothScrolling.on("scroll", ScrollTrigger_ScrollTrigger.update);
        ScrollTrigger_ScrollTrigger.scrollerProxy("[data-scroll-container]", {
            scrollTop(value) {
                return arguments.length ? smoothScrolling.scrollTo(value, 0, 0) : smoothScrolling.scroll.instance.scroll.y;
            },
            getBoundingClientRect() {
                return {
                    top: 0,
                    left: 0,
                    width: window.innerWidth,
                    height: window.innerHeight
                };
            },
            pinType: document.querySelector("[data-scroll-container]").style.transform ? "transform" : "fixed"
        });
        init();
        ScrollTrigger_ScrollTrigger.addEventListener("refresh", (() => smoothScrolling.update()));
        ScrollTrigger_ScrollTrigger.refresh();
        function init() {
            gsapWithCSS.from(".header", {
                y: 100,
                opacity: 0,
                duration: 1
            });
            const t1 = gsapWithCSS.to(".main-block__left", {
                x: -260,
                y: -100,
                scale: .6,
                opacity: 0
            });
            const t2 = gsapWithCSS.to(".main-block__right", {
                x: 260,
                y: 100,
                scale: .6,
                opacity: 0
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".main-block",
                start: "top top",
                scroller: "[data-scroll-container]",
                animation: t1,
                scrub: 1
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".main-block",
                start: "top top",
                scroller: "[data-scroll-container]",
                animation: t2,
                scrub: 1
            });
            const t3 = gsapWithCSS.from(".about__title", {
                x: -260,
                scale: .6,
                opacity: 0
            });
            const t4 = gsapWithCSS.from(".about__image", {
                x: -260,
                scale: .6,
                opacity: 0
            });
            const t5 = gsapWithCSS.from(".about__content", {
                x: 260,
                scale: .6,
                opacity: 0
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".about",
                start: "top 80%",
                end: "top 30%",
                scroller: "[data-scroll-container]",
                animation: t3,
                scrub: 1
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".about",
                end: "top 30%",
                scroller: "[data-scroll-container]",
                animation: t4,
                scrub: 1
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".about",
                end: "top 30%",
                scroller: "[data-scroll-container]",
                animation: t5,
                scrub: 1
            });
            const t6 = gsapWithCSS.from(".tournaments__title", {
                x: -260,
                scale: .6,
                opacity: 0
            });
            const t7 = gsapWithCSS.from(".tournaments__content", {
                x: 260,
                scale: .6,
                opacity: 0
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".tournaments",
                end: "top 30%",
                scroller: "[data-scroll-container]",
                animation: t6,
                scrub: 1
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".tournaments",
                end: "top 30%",
                scroller: "[data-scroll-container]",
                animation: t7,
                scrub: 1
            });
            const t8 = gsapWithCSS.from(".shop__content", {
                xPercent: 100,
                opacity: 0
            });
            const t9 = gsapWithCSS.from(".news__content", {
                xPercent: -100,
                opacity: 0
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".shop",
                end: "top 30%",
                scroller: "[data-scroll-container]",
                animation: t8,
                scrub: 1
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".news",
                end: "top 30%",
                scroller: "[data-scroll-container]",
                animation: t9,
                scrub: 1
            });
            const t10 = gsapWithCSS.from(".channel", {
                scale: .6,
                opacity: .6
            });
            ScrollTrigger_ScrollTrigger.create({
                trigger: ".channel",
                start: "top 80%",
                end: "center 120%",
                scroller: "[data-scroll-container]",
                animation: t10,
                scrub: 1
            });
        }
        class DynamicAdapt {
            constructor(type) {
                this.type = type;
            }
            init() {
                this.оbjects = [];
                this.daClassname = "_dynamic_adapt_";
                this.nodes = [ ...document.querySelectorAll("[data-da]") ];
                this.nodes.forEach((node => {
                    const data = node.dataset.da.trim();
                    const dataArray = data.split(",");
                    const оbject = {};
                    оbject.element = node;
                    оbject.parent = node.parentNode;
                    оbject.destination = document.querySelector(`${dataArray[0].trim()}`);
                    оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767";
                    оbject.place = dataArray[2] ? dataArray[2].trim() : "last";
                    оbject.index = this.indexInParent(оbject.parent, оbject.element);
                    this.оbjects.push(оbject);
                }));
                this.arraySort(this.оbjects);
                this.mediaQueries = this.оbjects.map((({breakpoint}) => `(${this.type}-width: ${breakpoint}px),${breakpoint}`)).filter(((item, index, self) => self.indexOf(item) === index));
                this.mediaQueries.forEach((media => {
                    const mediaSplit = media.split(",");
                    const matchMedia = window.matchMedia(mediaSplit[0]);
                    const mediaBreakpoint = mediaSplit[1];
                    const оbjectsFilter = this.оbjects.filter((({breakpoint}) => breakpoint === mediaBreakpoint));
                    matchMedia.addEventListener("change", (() => {
                        this.mediaHandler(matchMedia, оbjectsFilter);
                    }));
                    this.mediaHandler(matchMedia, оbjectsFilter);
                }));
            }
            mediaHandler(matchMedia, оbjects) {
                if (matchMedia.matches) оbjects.forEach((оbject => {
                    this.moveTo(оbject.place, оbject.element, оbject.destination);
                })); else оbjects.forEach((({parent, element, index}) => {
                    if (element.classList.contains(this.daClassname)) this.moveBack(parent, element, index);
                }));
            }
            moveTo(place, element, destination) {
                if (element.hasAttribute("data-adapt-style-reset")) element.style.cssText = "";
                element.classList.add(this.daClassname);
                if (place === "last" || place >= destination.children.length) {
                    destination.append(element);
                    return;
                }
                if (place === "first") {
                    destination.prepend(element);
                    return;
                }
                destination.children[place].before(element);
            }
            moveBack(parent, element, index) {
                element.classList.remove(this.daClassname);
                if (parent.children[index] !== void 0) parent.children[index].before(element); else parent.append(element);
            }
            indexInParent(parent, element) {
                return [ ...parent.children ].indexOf(element);
            }
            arraySort(arr) {
                if (this.type === "min") arr.sort(((a, b) => {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if (a.place === "first" || b.place === "last") return -1;
                        if (a.place === "last" || b.place === "first") return 1;
                        return 0;
                    }
                    return a.breakpoint - b.breakpoint;
                })); else {
                    arr.sort(((a, b) => {
                        if (a.breakpoint === b.breakpoint) {
                            if (a.place === b.place) return 0;
                            if (a.place === "first" || b.place === "last") return 1;
                            if (a.place === "last" || b.place === "first") return -1;
                            return 0;
                        }
                        return b.breakpoint - a.breakpoint;
                    }));
                    return;
                }
            }
        }
        const da = new DynamicAdapt("max");
        da.init();
        let inputs = document.querySelectorAll(".input");
        let buttons = document.querySelectorAll(".button");
        inputs.forEach((input => {
            let inputWrapper = document.createElement("div");
            inputWrapper.classList.add(...input.classList);
            input.after(inputWrapper);
            inputWrapper.append(input);
            input.className = "input__tag";
            let backgroundSVG = document.createElement("div");
            backgroundSVG.classList.add("input__background");
            backgroundSVG.innerHTML = `\n\t\t<svg width="324" height="48" viewBox="0 0 324 48" fill="none" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">\n\t\t\t<path d="M0.5434 47.5L4.46007 0.5H323.457L319.54 47.5H0.5434Z"/>\n\t\t</svg>\n\t`;
            inputWrapper.append(backgroundSVG);
            inputWrapper.addEventListener("click", (e => {
                input.focus();
            }));
        }));
        buttons.forEach((button => {
            let buttonInner = button.innerHTML;
            button.innerHTML = `<div class="button__inner">${buttonInner}</div>`;
            let backgroundSVG = document.createElement("div");
            backgroundSVG.classList.add("button__background");
            backgroundSVG.innerHTML = `\n\t\t<svg width="153" height="48" viewBox="0 0 153 48" fill="none" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">\n\t\t\t<path d="M8.77227 0H153L144.228 48H0L8.77227 0Z"/>\n\t\t\t<defs>\n\t\t\t\t<linearGradient id="dark" x1="4.06539" y1="-9.5" x2="30.8206" y2="131.64" gradientUnits="userSpaceOnUse">\n\t\t\t\t\t<stop stop-color="#0A1F35"/>\n\t\t\t\t\t<stop offset="1" stop-color="#040D17"/>\n\t\t\t\t</linearGradient>\n\t\t\t\t<linearGradient id="light" x1="-5.48837" y1="-6.75001" x2="242.355" y2="114.287" gradientUnits="userSpaceOnUse">\n\t\t\t\t\t<stop stop-color="#144558"/>\n\t\t\t\t\t<stop offset="1" stop-color="#0E3B4C"/>\n\t\t\t\t</linearGradient>\n\t\t\t\t<linearGradient id="hover" x1="4.06539" y1="-9.5" x2="30.8206" y2="131.64" gradientUnits="userSpaceOnUse">\n\t\t\t\t\t<stop stop-color="#173352"/>\n\t\t\t\t\t<stop offset="1" stop-color="#00eebd"/>\n\t\t\t\t</linearGradient>\n\t\t\t</defs>\n\t\t</svg>\n\t`;
            button.append(backgroundSVG);
        }));
        document.addEventListener("DOMContentLoaded", (eventGlobal => {
            let headerHeight = getHeaderHeight(document.querySelector(".header"));
            document.querySelector(".main-block").style.paddingTop = headerHeight + "px";
            window.addEventListener("resize", (resizeEvent => {
                let headerHeight = getHeaderHeight(document.querySelector(".header"));
                document.querySelector(".main-block").style.paddingTop = headerHeight + "px";
            }));
        }));
        function getHeaderHeight(header) {
            return header.getBoundingClientRect().height;
        }
        window["FLS"] = true;
        isWebp();
        menuInit();
    })();
})();